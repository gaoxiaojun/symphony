// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DTCProtocol.proto

#ifndef PROTOBUF_DTCProtocol_2eproto__INCLUDED
#define PROTOBUF_DTCProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace DTC_PB {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_DTCProtocol_2eproto();
void protobuf_AssignDesc_DTCProtocol_2eproto();
void protobuf_ShutdownFile_DTCProtocol_2eproto();

class EncodingRequest;
class EncodingResponse;
class LogonRequest;
class LogonResponse;
class Logoff;
class Heartbeat;
class MarketDataFeedStatus;
class MarketDataFeedSymbolStatus;
class MarketDataRequest;
class MarketDepthRequest;
class MarketDataReject;
class MarketDataSnapshot;
class MarketDataSnapshot_Int;
class DepthEntry;
class MarketDepthFullUpdate20;
class MarketDepthFullUpdate10;
class MarketDepthSnapshotLevel;
class MarketDepthSnapshotLevel_Int;
class MarketDepthUpdateLevel;
class MarketDepthUpdateLevel_Int;
class MarketDepthUpdateLevelCompact;
class MarketDataUpdateSessionSettlement;
class MarketDataUpdateSessionSettlement_Int;
class MarketDataUpdateSessionOpen;
class MarketDataUpdateSessionOpen_Int;
class MarketDepthReject;
class MarketDataUpdateTrade;
class MarketDataUpdateTrade_Int;
class MarketDataUpdateBidAsk;
class MarketDataUpdateBidAsk_Int;
class MarketDataUpdateBidAskCompact;
class MarketDataUpdateTradeCompact;
class MarketDataUpdateSessionVolume;
class MarketDataUpdateOpenInterest;
class MarketDataUpdateSessionHigh;
class MarketDataUpdateSessionHigh_Int;
class MarketDataUpdateSessionLow;
class MarketDataUpdateSessionLow_Int;
class MarketDataUpdateLastTradeSnapshot;
class SubmitNewSingleOrder;
class SubmitNewSingleOrderInt;
class CancelReplaceOrder;
class CancelReplaceOrderInt;
class CancelOrder;
class SubmitNewOCOOrder;
class SubmitNewOCOOrderInt;
class OpenOrdersRequest;
class HistoricalOrderFillsRequest;
class HistoricalOrderFillsReject;
class CurrentPositionsRequest;
class CurrentPositionsReject;
class OrderUpdate;
class OpenOrdersReject;
class HistoricalOrderFillResponse;
class PositionUpdate;
class TradeAccountsRequest;
class TradeAccountResponse;
class ExchangeListRequest;
class ExchangeListResponse;
class SymbolsForExchangeRequest;
class UnderlyingSymbolsForExchangeRequest;
class SymbolsForUnderlyingRequest;
class SymbolSearchRequest;
class SecurityDefinitionForSymbolRequest;
class SecurityDefinitionResponse;
class SecurityDefinitionReject;
class AccountBalanceRequest;
class AccountBalanceReject;
class AccountBalanceUpdate;
class UserMessage;
class GeneralLogMessage;
class HistoricalPriceDataRequest;
class HistoricalPriceDataResponseHeader;
class HistoricalPriceDataReject;
class HistoricalPriceDataRecordResponse;
class HistoricalPriceDataTickRecordResponse;
class HistoricalPriceDataRecordResponse_Int;
class HistoricalPriceDataTickRecordResponse_Int;
class HistoricalPriceDataResponseTrailer;

enum DTCVersion {
  CURRENT_VERSION = 7
};
bool DTCVersion_IsValid(int value);
const DTCVersion DTCVersion_MIN = CURRENT_VERSION;
const DTCVersion DTCVersion_MAX = CURRENT_VERSION;
const int DTCVersion_ARRAYSIZE = DTCVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* DTCVersion_descriptor();
inline const ::std::string& DTCVersion_Name(DTCVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    DTCVersion_descriptor(), value);
}
inline bool DTCVersion_Parse(
    const ::std::string& name, DTCVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DTCVersion>(
    DTCVersion_descriptor(), name, value);
}
enum DTCMessageType {
  LOGON_REQUEST = 1,
  LOGON_RESPONSE = 2,
  HEARTBEAT = 3,
  LOGOFF = 5,
  ENCODING_REQUEST = 6,
  ENCODING_RESPONSE = 7,
  MARKET_DATA_REQUEST = 101,
  MARKET_DATA_REJECT = 103,
  MARKET_DATA_SNAPSHOT = 104,
  MARKET_DATA_SNAPSHOT_INT = 125,
  MARKET_DATA_UPDATE_TRADE = 107,
  MARKET_DATA_UPDATE_TRADE_COMPACT = 112,
  MARKET_DATA_UPDATE_TRADE_INT = 126,
  MARKET_DATA_UPDATE_LAST_TRADE_SNAPSHOT = 134,
  MARKET_DATA_UPDATE_BID_ASK = 108,
  MARKET_DATA_UPDATE_BID_ASK_COMPACT = 117,
  MARKET_DATA_UPDATE_BID_ASK_INT = 127,
  MARKET_DATA_UPDATE_SESSION_OPEN = 120,
  MARKET_DATA_UPDATE_SESSION_OPEN_INT = 128,
  MARKET_DATA_UPDATE_SESSION_HIGH = 114,
  MARKET_DATA_UPDATE_SESSION_HIGH_INT = 129,
  MARKET_DATA_UPDATE_SESSION_LOW = 115,
  MARKET_DATA_UPDATE_SESSION_LOW_INT = 130,
  MARKET_DATA_UPDATE_SESSION_VOLUME = 113,
  MARKET_DATA_UPDATE_OPEN_INTEREST = 124,
  MARKET_DATA_UPDATE_DAILY_SETTLEMENT = 119,
  MARKET_DATA_UPDATE_DAILY_SETTLEMENT_INT = 131,
  MARKET_DEPTH_REQUEST = 102,
  MARKET_DEPTH_REJECT = 121,
  MARKET_DEPTH_SNAPSHOT_LEVEL = 122,
  MARKET_DEPTH_SNAPSHOT_LEVEL_INT = 132,
  MARKET_DEPTH_UPDATE_LEVEL = 106,
  MARKET_DEPTH_UPDATE_LEVEL_COMPACT = 118,
  MARKET_DEPTH_UPDATE_LEVEL_INT = 133,
  MARKET_DEPTH_FULL_UPDATE_10 = 123,
  MARKET_DEPTH_FULL_UPDATE_20 = 105,
  MARKET_DATA_FEED_STATUS = 100,
  MARKET_DATA_FEED_SYMBOL_STATUS = 116,
  SUBMIT_NEW_SINGLE_ORDER = 208,
  SUBMIT_NEW_SINGLE_ORDER_INT = 206,
  SUBMIT_NEW_OCO_ORDER = 201,
  SUBMIT_NEW_OCO_ORDER_INT = 207,
  CANCEL_ORDER = 203,
  CANCEL_REPLACE_ORDER = 204,
  CANCEL_REPLACE_ORDER_INT = 205,
  OPEN_ORDERS_REQUEST = 300,
  OPEN_ORDERS_REJECT = 302,
  ORDER_UPDATE = 301,
  HISTORICAL_ORDER_FILLS_REQUEST = 303,
  HISTORICAL_ORDER_FILL_RESPONSE = 304,
  CURRENT_POSITIONS_REQUEST = 305,
  CURRENT_POSITIONS_REJECT = 307,
  POSITION_UPDATE = 306,
  TRADE_ACCOUNTS_REQUEST = 400,
  TRADE_ACCOUNT_RESPONSE = 401,
  EXCHANGE_LIST_REQUEST = 500,
  EXCHANGE_LIST_RESPONSE = 501,
  SYMBOLS_FOR_EXCHANGE_REQUEST = 502,
  UNDERLYING_SYMBOLS_FOR_EXCHANGE_REQUEST = 503,
  SYMBOLS_FOR_UNDERLYING_REQUEST = 504,
  SECURITY_DEFINITION_FOR_SYMBOL_REQUEST = 506,
  SECURITY_DEFINITION_RESPONSE = 507,
  SYMBOL_SEARCH_REQUEST = 508,
  SECURITY_DEFINITION_REJECT = 509,
  ACCOUNT_BALANCE_REQUEST = 601,
  ACCOUNT_BALANCE_REJECT = 602,
  ACCOUNT_BALANCE_UPDATE = 600,
  USER_MESSAGE = 700,
  GENERAL_LOG_MESSAGE = 701,
  HISTORICAL_PRICE_DATA_REQUEST = 800,
  HISTORICAL_PRICE_DATA_RESPONSE_HEADER = 801,
  HISTORICAL_PRICE_DATA_REJECT = 802,
  HISTORICAL_PRICE_DATA_RECORD_RESPONSE = 803,
  HISTORICAL_PRICE_DATA_TICK_RECORD_RESPONSE = 804,
  HISTORICAL_PRICE_DATA_RECORD_RESPONSE_INT = 805,
  HISTORICAL_PRICE_DATA_TICK_RECORD_RESPONSE_INT = 806
};
bool DTCMessageType_IsValid(int value);
const DTCMessageType DTCMessageType_MIN = LOGON_REQUEST;
const DTCMessageType DTCMessageType_MAX = HISTORICAL_PRICE_DATA_TICK_RECORD_RESPONSE_INT;
const int DTCMessageType_ARRAYSIZE = DTCMessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DTCMessageType_descriptor();
inline const ::std::string& DTCMessageType_Name(DTCMessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DTCMessageType_descriptor(), value);
}
inline bool DTCMessageType_Parse(
    const ::std::string& name, DTCMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DTCMessageType>(
    DTCMessageType_descriptor(), name, value);
}
enum EncodingEnum {
  BINARY_ENCODING = 0,
  BINARY_WITH_VARIABLE_LENGTH_STRINGS = 1,
  JSON_ENCODING = 2,
  JSON_COMPACT_ENCODING = 3,
  PROTOCOL_BUFFERS = 4
};
bool EncodingEnum_IsValid(int value);
const EncodingEnum EncodingEnum_MIN = BINARY_ENCODING;
const EncodingEnum EncodingEnum_MAX = PROTOCOL_BUFFERS;
const int EncodingEnum_ARRAYSIZE = EncodingEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* EncodingEnum_descriptor();
inline const ::std::string& EncodingEnum_Name(EncodingEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    EncodingEnum_descriptor(), value);
}
inline bool EncodingEnum_Parse(
    const ::std::string& name, EncodingEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EncodingEnum>(
    EncodingEnum_descriptor(), name, value);
}
enum LogonStatusEnum {
  LOGON_SUCCESS = 1,
  LOGON_ERROR = 2,
  LOGON_ERROR_NO_RECONNECT = 3,
  LOGON_RECONNECT_NEW_ADDRESS = 4
};
bool LogonStatusEnum_IsValid(int value);
const LogonStatusEnum LogonStatusEnum_MIN = LOGON_SUCCESS;
const LogonStatusEnum LogonStatusEnum_MAX = LOGON_RECONNECT_NEW_ADDRESS;
const int LogonStatusEnum_ARRAYSIZE = LogonStatusEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogonStatusEnum_descriptor();
inline const ::std::string& LogonStatusEnum_Name(LogonStatusEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogonStatusEnum_descriptor(), value);
}
inline bool LogonStatusEnum_Parse(
    const ::std::string& name, LogonStatusEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogonStatusEnum>(
    LogonStatusEnum_descriptor(), name, value);
}
enum MessageSupportedEnum {
  MESSAGE_UNSUPPORTED = 0,
  MESSAGE_SUPPORTED = 1
};
bool MessageSupportedEnum_IsValid(int value);
const MessageSupportedEnum MessageSupportedEnum_MIN = MESSAGE_UNSUPPORTED;
const MessageSupportedEnum MessageSupportedEnum_MAX = MESSAGE_SUPPORTED;
const int MessageSupportedEnum_ARRAYSIZE = MessageSupportedEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageSupportedEnum_descriptor();
inline const ::std::string& MessageSupportedEnum_Name(MessageSupportedEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageSupportedEnum_descriptor(), value);
}
inline bool MessageSupportedEnum_Parse(
    const ::std::string& name, MessageSupportedEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageSupportedEnum>(
    MessageSupportedEnum_descriptor(), name, value);
}
enum TradeModeEnum {
  TRADE_MODE_DEMO = 1,
  TRADE_MODE_SIMULATED = 2,
  TRADE_MODE_LIVE = 3
};
bool TradeModeEnum_IsValid(int value);
const TradeModeEnum TradeModeEnum_MIN = TRADE_MODE_DEMO;
const TradeModeEnum TradeModeEnum_MAX = TRADE_MODE_LIVE;
const int TradeModeEnum_ARRAYSIZE = TradeModeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TradeModeEnum_descriptor();
inline const ::std::string& TradeModeEnum_Name(TradeModeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TradeModeEnum_descriptor(), value);
}
inline bool TradeModeEnum_Parse(
    const ::std::string& name, TradeModeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TradeModeEnum>(
    TradeModeEnum_descriptor(), name, value);
}
enum RequestActionEnum {
  SUBSCRIBE = 1,
  UNSUBSCRIBE = 2,
  SNAPSHOT = 3
};
bool RequestActionEnum_IsValid(int value);
const RequestActionEnum RequestActionEnum_MIN = SUBSCRIBE;
const RequestActionEnum RequestActionEnum_MAX = SNAPSHOT;
const int RequestActionEnum_ARRAYSIZE = RequestActionEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* RequestActionEnum_descriptor();
inline const ::std::string& RequestActionEnum_Name(RequestActionEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    RequestActionEnum_descriptor(), value);
}
inline bool RequestActionEnum_Parse(
    const ::std::string& name, RequestActionEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestActionEnum>(
    RequestActionEnum_descriptor(), name, value);
}
enum OrderStatusEnum {
  ORDER_STATUS_UNSPECIFIED = 0,
  ORDER_STATUS_ORDER_SENT = 1,
  ORDER_STATUS_PENDING_OPEN = 2,
  ORDER_STATUS_PENDING_CHILD = 3,
  ORDER_STATUS_OPEN = 4,
  ORDER_STATUS_PENDING_CANCEL_REPLACE = 5,
  ORDER_STATUS_PENDING_CANCEL = 6,
  ORDER_STATUS_FILLED = 7,
  ORDER_STATUS_CANCELED = 8,
  ORDER_STATUS_REJECTED = 9,
  ORDER_STATUS_PARTIALLY_FILLED = 10
};
bool OrderStatusEnum_IsValid(int value);
const OrderStatusEnum OrderStatusEnum_MIN = ORDER_STATUS_UNSPECIFIED;
const OrderStatusEnum OrderStatusEnum_MAX = ORDER_STATUS_PARTIALLY_FILLED;
const int OrderStatusEnum_ARRAYSIZE = OrderStatusEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderStatusEnum_descriptor();
inline const ::std::string& OrderStatusEnum_Name(OrderStatusEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderStatusEnum_descriptor(), value);
}
inline bool OrderStatusEnum_Parse(
    const ::std::string& name, OrderStatusEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderStatusEnum>(
    OrderStatusEnum_descriptor(), name, value);
}
enum OrderUpdateReasonEnum {
  ORDER_UPDATE_REASON_UNSET = 0,
  OPEN_ORDERS_REQUEST_RESPONSE = 1,
  NEW_ORDER_ACCEPTED = 2,
  GENERAL_ORDER_UPDATE = 3,
  ORDER_FILLED = 4,
  ORDER_FILLED_PARTIALLY = 5,
  ORDER_CANCELED = 6,
  ORDER_CANCEL_REPLACE_COMPLETE = 7,
  NEW_ORDER_REJECTED = 8,
  ORDER_CANCEL_REJECTED = 9,
  ORDER_CANCEL_REPLACE_REJECTED = 10
};
bool OrderUpdateReasonEnum_IsValid(int value);
const OrderUpdateReasonEnum OrderUpdateReasonEnum_MIN = ORDER_UPDATE_REASON_UNSET;
const OrderUpdateReasonEnum OrderUpdateReasonEnum_MAX = ORDER_CANCEL_REPLACE_REJECTED;
const int OrderUpdateReasonEnum_ARRAYSIZE = OrderUpdateReasonEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderUpdateReasonEnum_descriptor();
inline const ::std::string& OrderUpdateReasonEnum_Name(OrderUpdateReasonEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderUpdateReasonEnum_descriptor(), value);
}
inline bool OrderUpdateReasonEnum_Parse(
    const ::std::string& name, OrderUpdateReasonEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderUpdateReasonEnum>(
    OrderUpdateReasonEnum_descriptor(), name, value);
}
enum AtBidOrAskEnum {
  BID_ASK_UNSET = 0,
  AT_BID = 1,
  AT_ASK = 2
};
bool AtBidOrAskEnum_IsValid(int value);
const AtBidOrAskEnum AtBidOrAskEnum_MIN = BID_ASK_UNSET;
const AtBidOrAskEnum AtBidOrAskEnum_MAX = AT_ASK;
const int AtBidOrAskEnum_ARRAYSIZE = AtBidOrAskEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* AtBidOrAskEnum_descriptor();
inline const ::std::string& AtBidOrAskEnum_Name(AtBidOrAskEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    AtBidOrAskEnum_descriptor(), value);
}
inline bool AtBidOrAskEnum_Parse(
    const ::std::string& name, AtBidOrAskEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AtBidOrAskEnum>(
    AtBidOrAskEnum_descriptor(), name, value);
}
enum MarketDepthUpdateTypeEnum {
  DEPTH_UNSET = 0,
  MARKET_DEPTH_INSERT_UPDATE_LEVEL = 1,
  MARKET_DEPTH_DELETE_LEVEL = 2
};
bool MarketDepthUpdateTypeEnum_IsValid(int value);
const MarketDepthUpdateTypeEnum MarketDepthUpdateTypeEnum_MIN = DEPTH_UNSET;
const MarketDepthUpdateTypeEnum MarketDepthUpdateTypeEnum_MAX = MARKET_DEPTH_DELETE_LEVEL;
const int MarketDepthUpdateTypeEnum_ARRAYSIZE = MarketDepthUpdateTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* MarketDepthUpdateTypeEnum_descriptor();
inline const ::std::string& MarketDepthUpdateTypeEnum_Name(MarketDepthUpdateTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    MarketDepthUpdateTypeEnum_descriptor(), value);
}
inline bool MarketDepthUpdateTypeEnum_Parse(
    const ::std::string& name, MarketDepthUpdateTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MarketDepthUpdateTypeEnum>(
    MarketDepthUpdateTypeEnum_descriptor(), name, value);
}
enum OrderTypeEnum {
  ORDER_TYPE_UNSET = 0,
  ORDER_TYPE_MARKET = 1,
  ORDER_TYPE_LIMIT = 2,
  ORDER_TYPE_STOP = 3,
  ORDER_TYPE_STOP_LIMIT = 4,
  ORDER_TYPE_MARKET_IF_TOUCHED = 5
};
bool OrderTypeEnum_IsValid(int value);
const OrderTypeEnum OrderTypeEnum_MIN = ORDER_TYPE_UNSET;
const OrderTypeEnum OrderTypeEnum_MAX = ORDER_TYPE_MARKET_IF_TOUCHED;
const int OrderTypeEnum_ARRAYSIZE = OrderTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderTypeEnum_descriptor();
inline const ::std::string& OrderTypeEnum_Name(OrderTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderTypeEnum_descriptor(), value);
}
inline bool OrderTypeEnum_Parse(
    const ::std::string& name, OrderTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderTypeEnum>(
    OrderTypeEnum_descriptor(), name, value);
}
enum TimeInForceEnum {
  TIF_UNSET = 0,
  TIF_DAY = 1,
  TIF_GOOD_TILL_CANCELED = 2,
  TIF_GOOD_TILL_DATE_TIME = 3,
  TIF_IMMEDIATE_OR_CANCEL = 4,
  TIF_ALL_OR_NONE = 5,
  TIF_FILL_OR_KILL = 6
};
bool TimeInForceEnum_IsValid(int value);
const TimeInForceEnum TimeInForceEnum_MIN = TIF_UNSET;
const TimeInForceEnum TimeInForceEnum_MAX = TIF_FILL_OR_KILL;
const int TimeInForceEnum_ARRAYSIZE = TimeInForceEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimeInForceEnum_descriptor();
inline const ::std::string& TimeInForceEnum_Name(TimeInForceEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimeInForceEnum_descriptor(), value);
}
inline bool TimeInForceEnum_Parse(
    const ::std::string& name, TimeInForceEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimeInForceEnum>(
    TimeInForceEnum_descriptor(), name, value);
}
enum BuySellEnum {
  BUY_SELL_UNSET = 0,
  BUY = 1,
  SELL = 2
};
bool BuySellEnum_IsValid(int value);
const BuySellEnum BuySellEnum_MIN = BUY_SELL_UNSET;
const BuySellEnum BuySellEnum_MAX = SELL;
const int BuySellEnum_ARRAYSIZE = BuySellEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* BuySellEnum_descriptor();
inline const ::std::string& BuySellEnum_Name(BuySellEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    BuySellEnum_descriptor(), value);
}
inline bool BuySellEnum_Parse(
    const ::std::string& name, BuySellEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BuySellEnum>(
    BuySellEnum_descriptor(), name, value);
}
enum OpenCloseTradeEnum {
  TRADE_UNSET = 0,
  TRADE_OPEN = 1,
  TRADE_CLOSE = 2
};
bool OpenCloseTradeEnum_IsValid(int value);
const OpenCloseTradeEnum OpenCloseTradeEnum_MIN = TRADE_UNSET;
const OpenCloseTradeEnum OpenCloseTradeEnum_MAX = TRADE_CLOSE;
const int OpenCloseTradeEnum_ARRAYSIZE = OpenCloseTradeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* OpenCloseTradeEnum_descriptor();
inline const ::std::string& OpenCloseTradeEnum_Name(OpenCloseTradeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    OpenCloseTradeEnum_descriptor(), value);
}
inline bool OpenCloseTradeEnum_Parse(
    const ::std::string& name, OpenCloseTradeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OpenCloseTradeEnum>(
    OpenCloseTradeEnum_descriptor(), name, value);
}
enum MarketDataFeedStatusEnum {
  MARKET_DATA_FEED_UNAVAILABLE = 1,
  MARKET_DATA_FEED_AVAILABLE = 2
};
bool MarketDataFeedStatusEnum_IsValid(int value);
const MarketDataFeedStatusEnum MarketDataFeedStatusEnum_MIN = MARKET_DATA_FEED_UNAVAILABLE;
const MarketDataFeedStatusEnum MarketDataFeedStatusEnum_MAX = MARKET_DATA_FEED_AVAILABLE;
const int MarketDataFeedStatusEnum_ARRAYSIZE = MarketDataFeedStatusEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* MarketDataFeedStatusEnum_descriptor();
inline const ::std::string& MarketDataFeedStatusEnum_Name(MarketDataFeedStatusEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    MarketDataFeedStatusEnum_descriptor(), value);
}
inline bool MarketDataFeedStatusEnum_Parse(
    const ::std::string& name, MarketDataFeedStatusEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MarketDataFeedStatusEnum>(
    MarketDataFeedStatusEnum_descriptor(), name, value);
}
enum PriceDisplayFormatEnum {
  PRICE_DISPLAY_FORMAT_UNSET = -1,
  PRICE_DISPLAY_FORMAT_DECIMAL_0 = 0,
  PRICE_DISPLAY_FORMAT_DECIMAL_1 = 1,
  PRICE_DISPLAY_FORMAT_DECIMAL_2 = 2,
  PRICE_DISPLAY_FORMAT_DECIMAL_3 = 3,
  PRICE_DISPLAY_FORMAT_DECIMAL_4 = 4,
  PRICE_DISPLAY_FORMAT_DECIMAL_5 = 5,
  PRICE_DISPLAY_FORMAT_DECIMAL_6 = 6,
  PRICE_DISPLAY_FORMAT_DECIMAL_7 = 7,
  PRICE_DISPLAY_FORMAT_DECIMAL_8 = 8,
  PRICE_DISPLAY_FORMAT_DECIMAL_9 = 9,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_256 = 356,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_128 = 228,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_64 = 164,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_32_QUARTERS = 136,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_32_HALVES = 134,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_32 = 132,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_16 = 116,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_8 = 108,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_4 = 104,
  PRICE_DISPLAY_FORMAT_DENOMINATOR_2 = 102
};
bool PriceDisplayFormatEnum_IsValid(int value);
const PriceDisplayFormatEnum PriceDisplayFormatEnum_MIN = PRICE_DISPLAY_FORMAT_UNSET;
const PriceDisplayFormatEnum PriceDisplayFormatEnum_MAX = PRICE_DISPLAY_FORMAT_DENOMINATOR_256;
const int PriceDisplayFormatEnum_ARRAYSIZE = PriceDisplayFormatEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PriceDisplayFormatEnum_descriptor();
inline const ::std::string& PriceDisplayFormatEnum_Name(PriceDisplayFormatEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PriceDisplayFormatEnum_descriptor(), value);
}
inline bool PriceDisplayFormatEnum_Parse(
    const ::std::string& name, PriceDisplayFormatEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PriceDisplayFormatEnum>(
    PriceDisplayFormatEnum_descriptor(), name, value);
}
enum SecurityTypeEnum {
  SECURITY_TYPE_UNSET = 0,
  SECURITY_TYPE_FUTURE = 1,
  SECURITY_TYPE_STOCK = 2,
  SECURITY_TYPE_FOREX = 3,
  SECURITY_TYPE_INDEX = 4,
  SECURITY_TYPE_FUTURES_STRATEGY = 5,
  SECURITY_TYPE_FUTURES_OPTION = 7,
  SECURITY_TYPE_STOCK_OPTION = 6,
  SECURITY_TYPE_INDEX_OPTION = 8,
  SECURITY_TYPE_BOND = 9,
  SECURITY_TYPE_MUTUAL_FUND = 10
};
bool SecurityTypeEnum_IsValid(int value);
const SecurityTypeEnum SecurityTypeEnum_MIN = SECURITY_TYPE_UNSET;
const SecurityTypeEnum SecurityTypeEnum_MAX = SECURITY_TYPE_MUTUAL_FUND;
const int SecurityTypeEnum_ARRAYSIZE = SecurityTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SecurityTypeEnum_descriptor();
inline const ::std::string& SecurityTypeEnum_Name(SecurityTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SecurityTypeEnum_descriptor(), value);
}
inline bool SecurityTypeEnum_Parse(
    const ::std::string& name, SecurityTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SecurityTypeEnum>(
    SecurityTypeEnum_descriptor(), name, value);
}
enum PutCallEnum {
  PC_UNSET = 0,
  PC_CALL = 1,
  PC_PUT = 2
};
bool PutCallEnum_IsValid(int value);
const PutCallEnum PutCallEnum_MIN = PC_UNSET;
const PutCallEnum PutCallEnum_MAX = PC_PUT;
const int PutCallEnum_ARRAYSIZE = PutCallEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PutCallEnum_descriptor();
inline const ::std::string& PutCallEnum_Name(PutCallEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PutCallEnum_descriptor(), value);
}
inline bool PutCallEnum_Parse(
    const ::std::string& name, PutCallEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PutCallEnum>(
    PutCallEnum_descriptor(), name, value);
}
enum SearchTypeEnum {
  SEARCH_TYPE_UNSET = 0,
  SEARCH_TYPE_BY_SYMBOL = 1,
  SEARCH_TYPE_BY_DESCRIPTION = 2
};
bool SearchTypeEnum_IsValid(int value);
const SearchTypeEnum SearchTypeEnum_MIN = SEARCH_TYPE_UNSET;
const SearchTypeEnum SearchTypeEnum_MAX = SEARCH_TYPE_BY_DESCRIPTION;
const int SearchTypeEnum_ARRAYSIZE = SearchTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SearchTypeEnum_descriptor();
inline const ::std::string& SearchTypeEnum_Name(SearchTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SearchTypeEnum_descriptor(), value);
}
inline bool SearchTypeEnum_Parse(
    const ::std::string& name, SearchTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SearchTypeEnum>(
    SearchTypeEnum_descriptor(), name, value);
}
enum HistoricalDataIntervalEnum {
  INTERVAL_TICK = 0,
  INTERVAL_1_SECOND = 1,
  INTERVAL_2_SECONDS = 2,
  INTERVAL_4_SECONDS = 4,
  INTERVAL_5_SECONDS = 5,
  INTERVAL_10_SECONDS = 10,
  INTERVAL_30_SECONDS = 30,
  INTERVAL_1_MINUTE = 60,
  INTERVAL_1_DAY = 86400,
  INTERVAL_1_WEEK = 604800
};
bool HistoricalDataIntervalEnum_IsValid(int value);
const HistoricalDataIntervalEnum HistoricalDataIntervalEnum_MIN = INTERVAL_TICK;
const HistoricalDataIntervalEnum HistoricalDataIntervalEnum_MAX = INTERVAL_1_WEEK;
const int HistoricalDataIntervalEnum_ARRAYSIZE = HistoricalDataIntervalEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* HistoricalDataIntervalEnum_descriptor();
inline const ::std::string& HistoricalDataIntervalEnum_Name(HistoricalDataIntervalEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    HistoricalDataIntervalEnum_descriptor(), value);
}
inline bool HistoricalDataIntervalEnum_Parse(
    const ::std::string& name, HistoricalDataIntervalEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HistoricalDataIntervalEnum>(
    HistoricalDataIntervalEnum_descriptor(), name, value);
}
// ===================================================================

class EncodingRequest : public ::google::protobuf::Message {
 public:
  EncodingRequest();
  virtual ~EncodingRequest();

  EncodingRequest(const EncodingRequest& from);

  inline EncodingRequest& operator=(const EncodingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EncodingRequest& default_instance();

  void Swap(EncodingRequest* other);

  // implements Message ----------------------------------------------

  EncodingRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EncodingRequest& from);
  void MergeFrom(const EncodingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ProtocolVersion = 1;
  inline bool has_protocolversion() const;
  inline void clear_protocolversion();
  static const int kProtocolVersionFieldNumber = 1;
  inline ::google::protobuf::int32 protocolversion() const;
  inline void set_protocolversion(::google::protobuf::int32 value);

  // optional .DTC_PB.EncodingEnum Encoding = 2;
  inline bool has_encoding() const;
  inline void clear_encoding();
  static const int kEncodingFieldNumber = 2;
  inline ::DTC_PB::EncodingEnum encoding() const;
  inline void set_encoding(::DTC_PB::EncodingEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.EncodingRequest)
 private:
  inline void set_has_protocolversion();
  inline void clear_has_protocolversion();
  inline void set_has_encoding();
  inline void clear_has_encoding();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 protocolversion_;
  int encoding_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static EncodingRequest* default_instance_;
};
// -------------------------------------------------------------------

class EncodingResponse : public ::google::protobuf::Message {
 public:
  EncodingResponse();
  virtual ~EncodingResponse();

  EncodingResponse(const EncodingResponse& from);

  inline EncodingResponse& operator=(const EncodingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EncodingResponse& default_instance();

  void Swap(EncodingResponse* other);

  // implements Message ----------------------------------------------

  EncodingResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EncodingResponse& from);
  void MergeFrom(const EncodingResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ProtocolVersion = 1;
  inline bool has_protocolversion() const;
  inline void clear_protocolversion();
  static const int kProtocolVersionFieldNumber = 1;
  inline ::google::protobuf::int32 protocolversion() const;
  inline void set_protocolversion(::google::protobuf::int32 value);

  // optional .DTC_PB.EncodingEnum Encoding = 2;
  inline bool has_encoding() const;
  inline void clear_encoding();
  static const int kEncodingFieldNumber = 2;
  inline ::DTC_PB::EncodingEnum encoding() const;
  inline void set_encoding(::DTC_PB::EncodingEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.EncodingResponse)
 private:
  inline void set_has_protocolversion();
  inline void clear_has_protocolversion();
  inline void set_has_encoding();
  inline void clear_has_encoding();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 protocolversion_;
  int encoding_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static EncodingResponse* default_instance_;
};
// -------------------------------------------------------------------

class LogonRequest : public ::google::protobuf::Message {
 public:
  LogonRequest();
  virtual ~LogonRequest();

  LogonRequest(const LogonRequest& from);

  inline LogonRequest& operator=(const LogonRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogonRequest& default_instance();

  void Swap(LogonRequest* other);

  // implements Message ----------------------------------------------

  LogonRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogonRequest& from);
  void MergeFrom(const LogonRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ProtocolVersion = 1;
  inline bool has_protocolversion() const;
  inline void clear_protocolversion();
  static const int kProtocolVersionFieldNumber = 1;
  inline ::google::protobuf::int32 protocolversion() const;
  inline void set_protocolversion(::google::protobuf::int32 value);

  // optional string Username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string Password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string GeneralTextData = 4;
  inline bool has_generaltextdata() const;
  inline void clear_generaltextdata();
  static const int kGeneralTextDataFieldNumber = 4;
  inline const ::std::string& generaltextdata() const;
  inline void set_generaltextdata(const ::std::string& value);
  inline void set_generaltextdata(const char* value);
  inline void set_generaltextdata(const char* value, size_t size);
  inline ::std::string* mutable_generaltextdata();
  inline ::std::string* release_generaltextdata();
  inline void set_allocated_generaltextdata(::std::string* generaltextdata);

  // optional int32 Integer_1 = 5;
  inline bool has_integer_1() const;
  inline void clear_integer_1();
  static const int kInteger1FieldNumber = 5;
  inline ::google::protobuf::int32 integer_1() const;
  inline void set_integer_1(::google::protobuf::int32 value);

  // optional int32 Integer_2 = 6;
  inline bool has_integer_2() const;
  inline void clear_integer_2();
  static const int kInteger2FieldNumber = 6;
  inline ::google::protobuf::int32 integer_2() const;
  inline void set_integer_2(::google::protobuf::int32 value);

  // optional int32 HeartbeatIntervalInSeconds = 7;
  inline bool has_heartbeatintervalinseconds() const;
  inline void clear_heartbeatintervalinseconds();
  static const int kHeartbeatIntervalInSecondsFieldNumber = 7;
  inline ::google::protobuf::int32 heartbeatintervalinseconds() const;
  inline void set_heartbeatintervalinseconds(::google::protobuf::int32 value);

  // optional .DTC_PB.TradeModeEnum TradeMode = 8;
  inline bool has_trademode() const;
  inline void clear_trademode();
  static const int kTradeModeFieldNumber = 8;
  inline ::DTC_PB::TradeModeEnum trademode() const;
  inline void set_trademode(::DTC_PB::TradeModeEnum value);

  // optional string TradeAccount = 9;
  inline bool has_tradeaccount() const;
  inline void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 9;
  inline const ::std::string& tradeaccount() const;
  inline void set_tradeaccount(const ::std::string& value);
  inline void set_tradeaccount(const char* value);
  inline void set_tradeaccount(const char* value, size_t size);
  inline ::std::string* mutable_tradeaccount();
  inline ::std::string* release_tradeaccount();
  inline void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional string HardwareIdentifier = 10;
  inline bool has_hardwareidentifier() const;
  inline void clear_hardwareidentifier();
  static const int kHardwareIdentifierFieldNumber = 10;
  inline const ::std::string& hardwareidentifier() const;
  inline void set_hardwareidentifier(const ::std::string& value);
  inline void set_hardwareidentifier(const char* value);
  inline void set_hardwareidentifier(const char* value, size_t size);
  inline ::std::string* mutable_hardwareidentifier();
  inline ::std::string* release_hardwareidentifier();
  inline void set_allocated_hardwareidentifier(::std::string* hardwareidentifier);

  // optional string ClientName = 11;
  inline bool has_clientname() const;
  inline void clear_clientname();
  static const int kClientNameFieldNumber = 11;
  inline const ::std::string& clientname() const;
  inline void set_clientname(const ::std::string& value);
  inline void set_clientname(const char* value);
  inline void set_clientname(const char* value, size_t size);
  inline ::std::string* mutable_clientname();
  inline ::std::string* release_clientname();
  inline void set_allocated_clientname(::std::string* clientname);

  // @@protoc_insertion_point(class_scope:DTC_PB.LogonRequest)
 private:
  inline void set_has_protocolversion();
  inline void clear_has_protocolversion();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_generaltextdata();
  inline void clear_has_generaltextdata();
  inline void set_has_integer_1();
  inline void clear_has_integer_1();
  inline void set_has_integer_2();
  inline void clear_has_integer_2();
  inline void set_has_heartbeatintervalinseconds();
  inline void clear_has_heartbeatintervalinseconds();
  inline void set_has_trademode();
  inline void clear_has_trademode();
  inline void set_has_tradeaccount();
  inline void clear_has_tradeaccount();
  inline void set_has_hardwareidentifier();
  inline void clear_has_hardwareidentifier();
  inline void set_has_clientname();
  inline void clear_has_clientname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* username_;
  ::std::string* password_;
  ::google::protobuf::int32 protocolversion_;
  ::google::protobuf::int32 integer_1_;
  ::std::string* generaltextdata_;
  ::google::protobuf::int32 integer_2_;
  ::google::protobuf::int32 heartbeatintervalinseconds_;
  ::std::string* tradeaccount_;
  ::std::string* hardwareidentifier_;
  ::std::string* clientname_;
  int trademode_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static LogonRequest* default_instance_;
};
// -------------------------------------------------------------------

class LogonResponse : public ::google::protobuf::Message {
 public:
  LogonResponse();
  virtual ~LogonResponse();

  LogonResponse(const LogonResponse& from);

  inline LogonResponse& operator=(const LogonResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogonResponse& default_instance();

  void Swap(LogonResponse* other);

  // implements Message ----------------------------------------------

  LogonResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogonResponse& from);
  void MergeFrom(const LogonResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ProtocolVersion = 1;
  inline bool has_protocolversion() const;
  inline void clear_protocolversion();
  static const int kProtocolVersionFieldNumber = 1;
  inline ::google::protobuf::int32 protocolversion() const;
  inline void set_protocolversion(::google::protobuf::int32 value);

  // optional .DTC_PB.LogonStatusEnum Result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::DTC_PB::LogonStatusEnum result() const;
  inline void set_result(::DTC_PB::LogonStatusEnum value);

  // optional string ResultText = 3;
  inline bool has_resulttext() const;
  inline void clear_resulttext();
  static const int kResultTextFieldNumber = 3;
  inline const ::std::string& resulttext() const;
  inline void set_resulttext(const ::std::string& value);
  inline void set_resulttext(const char* value);
  inline void set_resulttext(const char* value, size_t size);
  inline ::std::string* mutable_resulttext();
  inline ::std::string* release_resulttext();
  inline void set_allocated_resulttext(::std::string* resulttext);

  // optional string ReconnectAddress = 4;
  inline bool has_reconnectaddress() const;
  inline void clear_reconnectaddress();
  static const int kReconnectAddressFieldNumber = 4;
  inline const ::std::string& reconnectaddress() const;
  inline void set_reconnectaddress(const ::std::string& value);
  inline void set_reconnectaddress(const char* value);
  inline void set_reconnectaddress(const char* value, size_t size);
  inline ::std::string* mutable_reconnectaddress();
  inline ::std::string* release_reconnectaddress();
  inline void set_allocated_reconnectaddress(::std::string* reconnectaddress);

  // optional int32 Integer_1 = 5;
  inline bool has_integer_1() const;
  inline void clear_integer_1();
  static const int kInteger1FieldNumber = 5;
  inline ::google::protobuf::int32 integer_1() const;
  inline void set_integer_1(::google::protobuf::int32 value);

  // optional string ServerName = 6;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServerNameFieldNumber = 6;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // optional uint32 MarketDepthUpdatesBestBidAndAsk = 7;
  inline bool has_marketdepthupdatesbestbidandask() const;
  inline void clear_marketdepthupdatesbestbidandask();
  static const int kMarketDepthUpdatesBestBidAndAskFieldNumber = 7;
  inline ::google::protobuf::uint32 marketdepthupdatesbestbidandask() const;
  inline void set_marketdepthupdatesbestbidandask(::google::protobuf::uint32 value);

  // optional uint32 TradingIsSupported = 8;
  inline bool has_tradingissupported() const;
  inline void clear_tradingissupported();
  static const int kTradingIsSupportedFieldNumber = 8;
  inline ::google::protobuf::uint32 tradingissupported() const;
  inline void set_tradingissupported(::google::protobuf::uint32 value);

  // optional uint32 OCOOrdersSupported = 9;
  inline bool has_ocoorderssupported() const;
  inline void clear_ocoorderssupported();
  static const int kOCOOrdersSupportedFieldNumber = 9;
  inline ::google::protobuf::uint32 ocoorderssupported() const;
  inline void set_ocoorderssupported(::google::protobuf::uint32 value);

  // optional uint32 OrderCancelReplaceSupported = 10;
  inline bool has_ordercancelreplacesupported() const;
  inline void clear_ordercancelreplacesupported();
  static const int kOrderCancelReplaceSupportedFieldNumber = 10;
  inline ::google::protobuf::uint32 ordercancelreplacesupported() const;
  inline void set_ordercancelreplacesupported(::google::protobuf::uint32 value);

  // optional string SymbolExchangeDelimiter = 11;
  inline bool has_symbolexchangedelimiter() const;
  inline void clear_symbolexchangedelimiter();
  static const int kSymbolExchangeDelimiterFieldNumber = 11;
  inline const ::std::string& symbolexchangedelimiter() const;
  inline void set_symbolexchangedelimiter(const ::std::string& value);
  inline void set_symbolexchangedelimiter(const char* value);
  inline void set_symbolexchangedelimiter(const char* value, size_t size);
  inline ::std::string* mutable_symbolexchangedelimiter();
  inline ::std::string* release_symbolexchangedelimiter();
  inline void set_allocated_symbolexchangedelimiter(::std::string* symbolexchangedelimiter);

  // optional uint32 SecurityDefinitionsSupported = 12;
  inline bool has_securitydefinitionssupported() const;
  inline void clear_securitydefinitionssupported();
  static const int kSecurityDefinitionsSupportedFieldNumber = 12;
  inline ::google::protobuf::uint32 securitydefinitionssupported() const;
  inline void set_securitydefinitionssupported(::google::protobuf::uint32 value);

  // optional uint32 HistoricalPriceDataSupported = 13;
  inline bool has_historicalpricedatasupported() const;
  inline void clear_historicalpricedatasupported();
  static const int kHistoricalPriceDataSupportedFieldNumber = 13;
  inline ::google::protobuf::uint32 historicalpricedatasupported() const;
  inline void set_historicalpricedatasupported(::google::protobuf::uint32 value);

  // optional uint32 ResubscribeWhenMarketDataFeedAvailable = 14;
  inline bool has_resubscribewhenmarketdatafeedavailable() const;
  inline void clear_resubscribewhenmarketdatafeedavailable();
  static const int kResubscribeWhenMarketDataFeedAvailableFieldNumber = 14;
  inline ::google::protobuf::uint32 resubscribewhenmarketdatafeedavailable() const;
  inline void set_resubscribewhenmarketdatafeedavailable(::google::protobuf::uint32 value);

  // optional uint32 MarketDepthIsSupported = 15;
  inline bool has_marketdepthissupported() const;
  inline void clear_marketdepthissupported();
  static const int kMarketDepthIsSupportedFieldNumber = 15;
  inline ::google::protobuf::uint32 marketdepthissupported() const;
  inline void set_marketdepthissupported(::google::protobuf::uint32 value);

  // optional uint32 OneHistoricalPriceDataRequestPerConnection = 16;
  inline bool has_onehistoricalpricedatarequestperconnection() const;
  inline void clear_onehistoricalpricedatarequestperconnection();
  static const int kOneHistoricalPriceDataRequestPerConnectionFieldNumber = 16;
  inline ::google::protobuf::uint32 onehistoricalpricedatarequestperconnection() const;
  inline void set_onehistoricalpricedatarequestperconnection(::google::protobuf::uint32 value);

  // optional uint32 BracketOrdersSupported = 17;
  inline bool has_bracketorderssupported() const;
  inline void clear_bracketorderssupported();
  static const int kBracketOrdersSupportedFieldNumber = 17;
  inline ::google::protobuf::uint32 bracketorderssupported() const;
  inline void set_bracketorderssupported(::google::protobuf::uint32 value);

  // optional uint32 UseIntegerPriceOrderMessages = 18;
  inline bool has_useintegerpriceordermessages() const;
  inline void clear_useintegerpriceordermessages();
  static const int kUseIntegerPriceOrderMessagesFieldNumber = 18;
  inline ::google::protobuf::uint32 useintegerpriceordermessages() const;
  inline void set_useintegerpriceordermessages(::google::protobuf::uint32 value);

  // optional uint32 UsesMultiplePositionsPerSymbolAndTradeAccount = 19;
  inline bool has_usesmultiplepositionspersymbolandtradeaccount() const;
  inline void clear_usesmultiplepositionspersymbolandtradeaccount();
  static const int kUsesMultiplePositionsPerSymbolAndTradeAccountFieldNumber = 19;
  inline ::google::protobuf::uint32 usesmultiplepositionspersymbolandtradeaccount() const;
  inline void set_usesmultiplepositionspersymbolandtradeaccount(::google::protobuf::uint32 value);

  // optional uint32 MarketDataSupported = 20;
  inline bool has_marketdatasupported() const;
  inline void clear_marketdatasupported();
  static const int kMarketDataSupportedFieldNumber = 20;
  inline ::google::protobuf::uint32 marketdatasupported() const;
  inline void set_marketdatasupported(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.LogonResponse)
 private:
  inline void set_has_protocolversion();
  inline void clear_has_protocolversion();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_resulttext();
  inline void clear_has_resulttext();
  inline void set_has_reconnectaddress();
  inline void clear_has_reconnectaddress();
  inline void set_has_integer_1();
  inline void clear_has_integer_1();
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_marketdepthupdatesbestbidandask();
  inline void clear_has_marketdepthupdatesbestbidandask();
  inline void set_has_tradingissupported();
  inline void clear_has_tradingissupported();
  inline void set_has_ocoorderssupported();
  inline void clear_has_ocoorderssupported();
  inline void set_has_ordercancelreplacesupported();
  inline void clear_has_ordercancelreplacesupported();
  inline void set_has_symbolexchangedelimiter();
  inline void clear_has_symbolexchangedelimiter();
  inline void set_has_securitydefinitionssupported();
  inline void clear_has_securitydefinitionssupported();
  inline void set_has_historicalpricedatasupported();
  inline void clear_has_historicalpricedatasupported();
  inline void set_has_resubscribewhenmarketdatafeedavailable();
  inline void clear_has_resubscribewhenmarketdatafeedavailable();
  inline void set_has_marketdepthissupported();
  inline void clear_has_marketdepthissupported();
  inline void set_has_onehistoricalpricedatarequestperconnection();
  inline void clear_has_onehistoricalpricedatarequestperconnection();
  inline void set_has_bracketorderssupported();
  inline void clear_has_bracketorderssupported();
  inline void set_has_useintegerpriceordermessages();
  inline void clear_has_useintegerpriceordermessages();
  inline void set_has_usesmultiplepositionspersymbolandtradeaccount();
  inline void clear_has_usesmultiplepositionspersymbolandtradeaccount();
  inline void set_has_marketdatasupported();
  inline void clear_has_marketdatasupported();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 protocolversion_;
  int result_;
  ::std::string* resulttext_;
  ::std::string* reconnectaddress_;
  ::std::string* servername_;
  ::google::protobuf::int32 integer_1_;
  ::google::protobuf::uint32 marketdepthupdatesbestbidandask_;
  ::google::protobuf::uint32 tradingissupported_;
  ::google::protobuf::uint32 ocoorderssupported_;
  ::std::string* symbolexchangedelimiter_;
  ::google::protobuf::uint32 ordercancelreplacesupported_;
  ::google::protobuf::uint32 securitydefinitionssupported_;
  ::google::protobuf::uint32 historicalpricedatasupported_;
  ::google::protobuf::uint32 resubscribewhenmarketdatafeedavailable_;
  ::google::protobuf::uint32 marketdepthissupported_;
  ::google::protobuf::uint32 onehistoricalpricedatarequestperconnection_;
  ::google::protobuf::uint32 bracketorderssupported_;
  ::google::protobuf::uint32 useintegerpriceordermessages_;
  ::google::protobuf::uint32 usesmultiplepositionspersymbolandtradeaccount_;
  ::google::protobuf::uint32 marketdatasupported_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static LogonResponse* default_instance_;
};
// -------------------------------------------------------------------

class Logoff : public ::google::protobuf::Message {
 public:
  Logoff();
  virtual ~Logoff();

  Logoff(const Logoff& from);

  inline Logoff& operator=(const Logoff& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Logoff& default_instance();

  void Swap(Logoff* other);

  // implements Message ----------------------------------------------

  Logoff* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Logoff& from);
  void MergeFrom(const Logoff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Reason = 1;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 1;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // optional uint32 DoNotReconnect = 2;
  inline bool has_donotreconnect() const;
  inline void clear_donotreconnect();
  static const int kDoNotReconnectFieldNumber = 2;
  inline ::google::protobuf::uint32 donotreconnect() const;
  inline void set_donotreconnect(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.Logoff)
 private:
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_donotreconnect();
  inline void clear_has_donotreconnect();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* reason_;
  ::google::protobuf::uint32 donotreconnect_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static Logoff* default_instance_;
};
// -------------------------------------------------------------------

class Heartbeat : public ::google::protobuf::Message {
 public:
  Heartbeat();
  virtual ~Heartbeat();

  Heartbeat(const Heartbeat& from);

  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Heartbeat& default_instance();

  void Swap(Heartbeat* other);

  // implements Message ----------------------------------------------

  Heartbeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Heartbeat& from);
  void MergeFrom(const Heartbeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 NumDroppedMessages = 1;
  inline bool has_numdroppedmessages() const;
  inline void clear_numdroppedmessages();
  static const int kNumDroppedMessagesFieldNumber = 1;
  inline ::google::protobuf::uint32 numdroppedmessages() const;
  inline void set_numdroppedmessages(::google::protobuf::uint32 value);

  // optional sfixed64 CurrentDateTime = 2;
  inline bool has_currentdatetime() const;
  inline void clear_currentdatetime();
  static const int kCurrentDateTimeFieldNumber = 2;
  inline ::google::protobuf::int64 currentdatetime() const;
  inline void set_currentdatetime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.Heartbeat)
 private:
  inline void set_has_numdroppedmessages();
  inline void clear_has_numdroppedmessages();
  inline void set_has_currentdatetime();
  inline void clear_has_currentdatetime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 currentdatetime_;
  ::google::protobuf::uint32 numdroppedmessages_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static Heartbeat* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataFeedStatus : public ::google::protobuf::Message {
 public:
  MarketDataFeedStatus();
  virtual ~MarketDataFeedStatus();

  MarketDataFeedStatus(const MarketDataFeedStatus& from);

  inline MarketDataFeedStatus& operator=(const MarketDataFeedStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataFeedStatus& default_instance();

  void Swap(MarketDataFeedStatus* other);

  // implements Message ----------------------------------------------

  MarketDataFeedStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataFeedStatus& from);
  void MergeFrom(const MarketDataFeedStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DTC_PB.MarketDataFeedStatusEnum Status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::DTC_PB::MarketDataFeedStatusEnum status() const;
  inline void set_status(::DTC_PB::MarketDataFeedStatusEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataFeedStatus)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataFeedStatus* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataFeedSymbolStatus : public ::google::protobuf::Message {
 public:
  MarketDataFeedSymbolStatus();
  virtual ~MarketDataFeedSymbolStatus();

  MarketDataFeedSymbolStatus(const MarketDataFeedSymbolStatus& from);

  inline MarketDataFeedSymbolStatus& operator=(const MarketDataFeedSymbolStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataFeedSymbolStatus& default_instance();

  void Swap(MarketDataFeedSymbolStatus* other);

  // implements Message ----------------------------------------------

  MarketDataFeedSymbolStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataFeedSymbolStatus& from);
  void MergeFrom(const MarketDataFeedSymbolStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.MarketDataFeedStatusEnum Status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::DTC_PB::MarketDataFeedStatusEnum status() const;
  inline void set_status(::DTC_PB::MarketDataFeedStatusEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataFeedSymbolStatus)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  int status_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataFeedSymbolStatus* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataRequest : public ::google::protobuf::Message {
 public:
  MarketDataRequest();
  virtual ~MarketDataRequest();

  MarketDataRequest(const MarketDataRequest& from);

  inline MarketDataRequest& operator=(const MarketDataRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataRequest& default_instance();

  void Swap(MarketDataRequest* other);

  // implements Message ----------------------------------------------

  MarketDataRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataRequest& from);
  void MergeFrom(const MarketDataRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DTC_PB.RequestActionEnum RequestAction = 1;
  inline bool has_requestaction() const;
  inline void clear_requestaction();
  static const int kRequestActionFieldNumber = 1;
  inline ::DTC_PB::RequestActionEnum requestaction() const;
  inline void set_requestaction(::DTC_PB::RequestActionEnum value);

  // optional uint32 SymbolID = 2;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 2;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional string Symbol = 3;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 3;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 4;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 4;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataRequest)
 private:
  inline void set_has_requestaction();
  inline void clear_has_requestaction();
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_exchange();
  inline void clear_has_exchange();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int requestaction_;
  ::google::protobuf::uint32 symbolid_;
  ::std::string* symbol_;
  ::std::string* exchange_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataRequest* default_instance_;
};
// -------------------------------------------------------------------

class MarketDepthRequest : public ::google::protobuf::Message {
 public:
  MarketDepthRequest();
  virtual ~MarketDepthRequest();

  MarketDepthRequest(const MarketDepthRequest& from);

  inline MarketDepthRequest& operator=(const MarketDepthRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDepthRequest& default_instance();

  void Swap(MarketDepthRequest* other);

  // implements Message ----------------------------------------------

  MarketDepthRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDepthRequest& from);
  void MergeFrom(const MarketDepthRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .DTC_PB.RequestActionEnum RequestAction = 1;
  inline bool has_requestaction() const;
  inline void clear_requestaction();
  static const int kRequestActionFieldNumber = 1;
  inline ::DTC_PB::RequestActionEnum requestaction() const;
  inline void set_requestaction(::DTC_PB::RequestActionEnum value);

  // optional uint32 SymbolID = 2;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 2;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional string Symbol = 3;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 3;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 4;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 4;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // optional int32 NumLevels = 5;
  inline bool has_numlevels() const;
  inline void clear_numlevels();
  static const int kNumLevelsFieldNumber = 5;
  inline ::google::protobuf::int32 numlevels() const;
  inline void set_numlevels(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDepthRequest)
 private:
  inline void set_has_requestaction();
  inline void clear_has_requestaction();
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_exchange();
  inline void clear_has_exchange();
  inline void set_has_numlevels();
  inline void clear_has_numlevels();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int requestaction_;
  ::google::protobuf::uint32 symbolid_;
  ::std::string* symbol_;
  ::std::string* exchange_;
  ::google::protobuf::int32 numlevels_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDepthRequest* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataReject : public ::google::protobuf::Message {
 public:
  MarketDataReject();
  virtual ~MarketDataReject();

  MarketDataReject(const MarketDataReject& from);

  inline MarketDataReject& operator=(const MarketDataReject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataReject& default_instance();

  void Swap(MarketDataReject* other);

  // implements Message ----------------------------------------------

  MarketDataReject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataReject& from);
  void MergeFrom(const MarketDataReject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional string RejectText = 2;
  inline bool has_rejecttext() const;
  inline void clear_rejecttext();
  static const int kRejectTextFieldNumber = 2;
  inline const ::std::string& rejecttext() const;
  inline void set_rejecttext(const ::std::string& value);
  inline void set_rejecttext(const char* value);
  inline void set_rejecttext(const char* value, size_t size);
  inline ::std::string* mutable_rejecttext();
  inline ::std::string* release_rejecttext();
  inline void set_allocated_rejecttext(::std::string* rejecttext);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataReject)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_rejecttext();
  inline void clear_has_rejecttext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* rejecttext_;
  ::google::protobuf::uint32 symbolid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataReject* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataSnapshot : public ::google::protobuf::Message {
 public:
  MarketDataSnapshot();
  virtual ~MarketDataSnapshot();

  MarketDataSnapshot(const MarketDataSnapshot& from);

  inline MarketDataSnapshot& operator=(const MarketDataSnapshot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataSnapshot& default_instance();

  void Swap(MarketDataSnapshot* other);

  // implements Message ----------------------------------------------

  MarketDataSnapshot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataSnapshot& from);
  void MergeFrom(const MarketDataSnapshot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional double SessionSettlementPrice = 2;
  inline bool has_sessionsettlementprice() const;
  inline void clear_sessionsettlementprice();
  static const int kSessionSettlementPriceFieldNumber = 2;
  inline double sessionsettlementprice() const;
  inline void set_sessionsettlementprice(double value);

  // optional double SessionOpenPrice = 3;
  inline bool has_sessionopenprice() const;
  inline void clear_sessionopenprice();
  static const int kSessionOpenPriceFieldNumber = 3;
  inline double sessionopenprice() const;
  inline void set_sessionopenprice(double value);

  // optional double SessionHighPrice = 4;
  inline bool has_sessionhighprice() const;
  inline void clear_sessionhighprice();
  static const int kSessionHighPriceFieldNumber = 4;
  inline double sessionhighprice() const;
  inline void set_sessionhighprice(double value);

  // optional double SessionLowPrice = 5;
  inline bool has_sessionlowprice() const;
  inline void clear_sessionlowprice();
  static const int kSessionLowPriceFieldNumber = 5;
  inline double sessionlowprice() const;
  inline void set_sessionlowprice(double value);

  // optional double SessionVolume = 6;
  inline bool has_sessionvolume() const;
  inline void clear_sessionvolume();
  static const int kSessionVolumeFieldNumber = 6;
  inline double sessionvolume() const;
  inline void set_sessionvolume(double value);

  // optional uint32 SessionNumTrades = 7;
  inline bool has_sessionnumtrades() const;
  inline void clear_sessionnumtrades();
  static const int kSessionNumTradesFieldNumber = 7;
  inline ::google::protobuf::uint32 sessionnumtrades() const;
  inline void set_sessionnumtrades(::google::protobuf::uint32 value);

  // optional uint32 OpenInterest = 8;
  inline bool has_openinterest() const;
  inline void clear_openinterest();
  static const int kOpenInterestFieldNumber = 8;
  inline ::google::protobuf::uint32 openinterest() const;
  inline void set_openinterest(::google::protobuf::uint32 value);

  // optional double BidPrice = 9;
  inline bool has_bidprice() const;
  inline void clear_bidprice();
  static const int kBidPriceFieldNumber = 9;
  inline double bidprice() const;
  inline void set_bidprice(double value);

  // optional double AskPrice = 10;
  inline bool has_askprice() const;
  inline void clear_askprice();
  static const int kAskPriceFieldNumber = 10;
  inline double askprice() const;
  inline void set_askprice(double value);

  // optional double AskQuantity = 11;
  inline bool has_askquantity() const;
  inline void clear_askquantity();
  static const int kAskQuantityFieldNumber = 11;
  inline double askquantity() const;
  inline void set_askquantity(double value);

  // optional double BidQuantity = 12;
  inline bool has_bidquantity() const;
  inline void clear_bidquantity();
  static const int kBidQuantityFieldNumber = 12;
  inline double bidquantity() const;
  inline void set_bidquantity(double value);

  // optional double LastTradePrice = 13;
  inline bool has_lasttradeprice() const;
  inline void clear_lasttradeprice();
  static const int kLastTradePriceFieldNumber = 13;
  inline double lasttradeprice() const;
  inline void set_lasttradeprice(double value);

  // optional double LastTradeVolume = 14;
  inline bool has_lasttradevolume() const;
  inline void clear_lasttradevolume();
  static const int kLastTradeVolumeFieldNumber = 14;
  inline double lasttradevolume() const;
  inline void set_lasttradevolume(double value);

  // optional double LastTradeDateTime = 15;
  inline bool has_lasttradedatetime() const;
  inline void clear_lasttradedatetime();
  static const int kLastTradeDateTimeFieldNumber = 15;
  inline double lasttradedatetime() const;
  inline void set_lasttradedatetime(double value);

  // optional double BidAskDateTime = 16;
  inline bool has_bidaskdatetime() const;
  inline void clear_bidaskdatetime();
  static const int kBidAskDateTimeFieldNumber = 16;
  inline double bidaskdatetime() const;
  inline void set_bidaskdatetime(double value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataSnapshot)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_sessionsettlementprice();
  inline void clear_has_sessionsettlementprice();
  inline void set_has_sessionopenprice();
  inline void clear_has_sessionopenprice();
  inline void set_has_sessionhighprice();
  inline void clear_has_sessionhighprice();
  inline void set_has_sessionlowprice();
  inline void clear_has_sessionlowprice();
  inline void set_has_sessionvolume();
  inline void clear_has_sessionvolume();
  inline void set_has_sessionnumtrades();
  inline void clear_has_sessionnumtrades();
  inline void set_has_openinterest();
  inline void clear_has_openinterest();
  inline void set_has_bidprice();
  inline void clear_has_bidprice();
  inline void set_has_askprice();
  inline void clear_has_askprice();
  inline void set_has_askquantity();
  inline void clear_has_askquantity();
  inline void set_has_bidquantity();
  inline void clear_has_bidquantity();
  inline void set_has_lasttradeprice();
  inline void clear_has_lasttradeprice();
  inline void set_has_lasttradevolume();
  inline void clear_has_lasttradevolume();
  inline void set_has_lasttradedatetime();
  inline void clear_has_lasttradedatetime();
  inline void set_has_bidaskdatetime();
  inline void clear_has_bidaskdatetime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double sessionsettlementprice_;
  double sessionopenprice_;
  double sessionhighprice_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::uint32 sessionnumtrades_;
  double sessionlowprice_;
  double sessionvolume_;
  double bidprice_;
  double askprice_;
  double askquantity_;
  double bidquantity_;
  double lasttradeprice_;
  double lasttradevolume_;
  double lasttradedatetime_;
  double bidaskdatetime_;
  ::google::protobuf::uint32 openinterest_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataSnapshot* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataSnapshot_Int : public ::google::protobuf::Message {
 public:
  MarketDataSnapshot_Int();
  virtual ~MarketDataSnapshot_Int();

  MarketDataSnapshot_Int(const MarketDataSnapshot_Int& from);

  inline MarketDataSnapshot_Int& operator=(const MarketDataSnapshot_Int& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataSnapshot_Int& default_instance();

  void Swap(MarketDataSnapshot_Int* other);

  // implements Message ----------------------------------------------

  MarketDataSnapshot_Int* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataSnapshot_Int& from);
  void MergeFrom(const MarketDataSnapshot_Int& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional int32 SessionSettlementPrice = 2;
  inline bool has_sessionsettlementprice() const;
  inline void clear_sessionsettlementprice();
  static const int kSessionSettlementPriceFieldNumber = 2;
  inline ::google::protobuf::int32 sessionsettlementprice() const;
  inline void set_sessionsettlementprice(::google::protobuf::int32 value);

  // optional int32 SessionOpenPrice = 3;
  inline bool has_sessionopenprice() const;
  inline void clear_sessionopenprice();
  static const int kSessionOpenPriceFieldNumber = 3;
  inline ::google::protobuf::int32 sessionopenprice() const;
  inline void set_sessionopenprice(::google::protobuf::int32 value);

  // optional int32 SessionHighPrice = 4;
  inline bool has_sessionhighprice() const;
  inline void clear_sessionhighprice();
  static const int kSessionHighPriceFieldNumber = 4;
  inline ::google::protobuf::int32 sessionhighprice() const;
  inline void set_sessionhighprice(::google::protobuf::int32 value);

  // optional int32 SessionLowPrice = 5;
  inline bool has_sessionlowprice() const;
  inline void clear_sessionlowprice();
  static const int kSessionLowPriceFieldNumber = 5;
  inline ::google::protobuf::int32 sessionlowprice() const;
  inline void set_sessionlowprice(::google::protobuf::int32 value);

  // optional int32 SessionVolume = 6;
  inline bool has_sessionvolume() const;
  inline void clear_sessionvolume();
  static const int kSessionVolumeFieldNumber = 6;
  inline ::google::protobuf::int32 sessionvolume() const;
  inline void set_sessionvolume(::google::protobuf::int32 value);

  // optional uint32 SessionNumTrades = 7;
  inline bool has_sessionnumtrades() const;
  inline void clear_sessionnumtrades();
  static const int kSessionNumTradesFieldNumber = 7;
  inline ::google::protobuf::uint32 sessionnumtrades() const;
  inline void set_sessionnumtrades(::google::protobuf::uint32 value);

  // optional uint32 OpenInterest = 8;
  inline bool has_openinterest() const;
  inline void clear_openinterest();
  static const int kOpenInterestFieldNumber = 8;
  inline ::google::protobuf::uint32 openinterest() const;
  inline void set_openinterest(::google::protobuf::uint32 value);

  // optional int32 BidPrice = 9;
  inline bool has_bidprice() const;
  inline void clear_bidprice();
  static const int kBidPriceFieldNumber = 9;
  inline ::google::protobuf::int32 bidprice() const;
  inline void set_bidprice(::google::protobuf::int32 value);

  // optional int32 AskPrice = 10;
  inline bool has_askprice() const;
  inline void clear_askprice();
  static const int kAskPriceFieldNumber = 10;
  inline ::google::protobuf::int32 askprice() const;
  inline void set_askprice(::google::protobuf::int32 value);

  // optional int32 AskQuantity = 11;
  inline bool has_askquantity() const;
  inline void clear_askquantity();
  static const int kAskQuantityFieldNumber = 11;
  inline ::google::protobuf::int32 askquantity() const;
  inline void set_askquantity(::google::protobuf::int32 value);

  // optional int32 BidQuantity = 12;
  inline bool has_bidquantity() const;
  inline void clear_bidquantity();
  static const int kBidQuantityFieldNumber = 12;
  inline ::google::protobuf::int32 bidquantity() const;
  inline void set_bidquantity(::google::protobuf::int32 value);

  // optional int32 LastTradePrice = 13;
  inline bool has_lasttradeprice() const;
  inline void clear_lasttradeprice();
  static const int kLastTradePriceFieldNumber = 13;
  inline ::google::protobuf::int32 lasttradeprice() const;
  inline void set_lasttradeprice(::google::protobuf::int32 value);

  // optional int32 LastTradeVolume = 14;
  inline bool has_lasttradevolume() const;
  inline void clear_lasttradevolume();
  static const int kLastTradeVolumeFieldNumber = 14;
  inline ::google::protobuf::int32 lasttradevolume() const;
  inline void set_lasttradevolume(::google::protobuf::int32 value);

  // optional double LastTradeDateTime = 15;
  inline bool has_lasttradedatetime() const;
  inline void clear_lasttradedatetime();
  static const int kLastTradeDateTimeFieldNumber = 15;
  inline double lasttradedatetime() const;
  inline void set_lasttradedatetime(double value);

  // optional double BidAskDateTime = 16;
  inline bool has_bidaskdatetime() const;
  inline void clear_bidaskdatetime();
  static const int kBidAskDateTimeFieldNumber = 16;
  inline double bidaskdatetime() const;
  inline void set_bidaskdatetime(double value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataSnapshot_Int)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_sessionsettlementprice();
  inline void clear_has_sessionsettlementprice();
  inline void set_has_sessionopenprice();
  inline void clear_has_sessionopenprice();
  inline void set_has_sessionhighprice();
  inline void clear_has_sessionhighprice();
  inline void set_has_sessionlowprice();
  inline void clear_has_sessionlowprice();
  inline void set_has_sessionvolume();
  inline void clear_has_sessionvolume();
  inline void set_has_sessionnumtrades();
  inline void clear_has_sessionnumtrades();
  inline void set_has_openinterest();
  inline void clear_has_openinterest();
  inline void set_has_bidprice();
  inline void clear_has_bidprice();
  inline void set_has_askprice();
  inline void clear_has_askprice();
  inline void set_has_askquantity();
  inline void clear_has_askquantity();
  inline void set_has_bidquantity();
  inline void clear_has_bidquantity();
  inline void set_has_lasttradeprice();
  inline void clear_has_lasttradeprice();
  inline void set_has_lasttradevolume();
  inline void clear_has_lasttradevolume();
  inline void set_has_lasttradedatetime();
  inline void clear_has_lasttradedatetime();
  inline void set_has_bidaskdatetime();
  inline void clear_has_bidaskdatetime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::int32 sessionsettlementprice_;
  ::google::protobuf::int32 sessionopenprice_;
  ::google::protobuf::int32 sessionhighprice_;
  ::google::protobuf::int32 sessionlowprice_;
  ::google::protobuf::int32 sessionvolume_;
  ::google::protobuf::uint32 sessionnumtrades_;
  ::google::protobuf::uint32 openinterest_;
  ::google::protobuf::int32 bidprice_;
  ::google::protobuf::int32 askprice_;
  ::google::protobuf::int32 askquantity_;
  ::google::protobuf::int32 bidquantity_;
  ::google::protobuf::int32 lasttradeprice_;
  ::google::protobuf::int32 lasttradevolume_;
  double lasttradedatetime_;
  double bidaskdatetime_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataSnapshot_Int* default_instance_;
};
// -------------------------------------------------------------------

class DepthEntry : public ::google::protobuf::Message {
 public:
  DepthEntry();
  virtual ~DepthEntry();

  DepthEntry(const DepthEntry& from);

  inline DepthEntry& operator=(const DepthEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DepthEntry& default_instance();

  void Swap(DepthEntry* other);

  // implements Message ----------------------------------------------

  DepthEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DepthEntry& from);
  void MergeFrom(const DepthEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double Price = 1;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 1;
  inline double price() const;
  inline void set_price(double value);

  // optional float Quantity = 12;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 12;
  inline float quantity() const;
  inline void set_quantity(float value);

  // @@protoc_insertion_point(class_scope:DTC_PB.DepthEntry)
 private:
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_quantity();
  inline void clear_has_quantity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double price_;
  float quantity_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static DepthEntry* default_instance_;
};
// -------------------------------------------------------------------

class MarketDepthFullUpdate20 : public ::google::protobuf::Message {
 public:
  MarketDepthFullUpdate20();
  virtual ~MarketDepthFullUpdate20();

  MarketDepthFullUpdate20(const MarketDepthFullUpdate20& from);

  inline MarketDepthFullUpdate20& operator=(const MarketDepthFullUpdate20& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDepthFullUpdate20& default_instance();

  void Swap(MarketDepthFullUpdate20* other);

  // implements Message ----------------------------------------------

  MarketDepthFullUpdate20* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDepthFullUpdate20& from);
  void MergeFrom(const MarketDepthFullUpdate20& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // repeated .DTC_PB.DepthEntry BidDepth = 2;
  inline int biddepth_size() const;
  inline void clear_biddepth();
  static const int kBidDepthFieldNumber = 2;
  inline const ::DTC_PB::DepthEntry& biddepth(int index) const;
  inline ::DTC_PB::DepthEntry* mutable_biddepth(int index);
  inline ::DTC_PB::DepthEntry* add_biddepth();
  inline const ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >&
      biddepth() const;
  inline ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >*
      mutable_biddepth();

  // repeated .DTC_PB.DepthEntry AskDepth = 3;
  inline int askdepth_size() const;
  inline void clear_askdepth();
  static const int kAskDepthFieldNumber = 3;
  inline const ::DTC_PB::DepthEntry& askdepth(int index) const;
  inline ::DTC_PB::DepthEntry* mutable_askdepth(int index);
  inline ::DTC_PB::DepthEntry* add_askdepth();
  inline const ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >&
      askdepth() const;
  inline ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >*
      mutable_askdepth();

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDepthFullUpdate20)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry > biddepth_;
  ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry > askdepth_;
  ::google::protobuf::uint32 symbolid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDepthFullUpdate20* default_instance_;
};
// -------------------------------------------------------------------

class MarketDepthFullUpdate10 : public ::google::protobuf::Message {
 public:
  MarketDepthFullUpdate10();
  virtual ~MarketDepthFullUpdate10();

  MarketDepthFullUpdate10(const MarketDepthFullUpdate10& from);

  inline MarketDepthFullUpdate10& operator=(const MarketDepthFullUpdate10& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDepthFullUpdate10& default_instance();

  void Swap(MarketDepthFullUpdate10* other);

  // implements Message ----------------------------------------------

  MarketDepthFullUpdate10* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDepthFullUpdate10& from);
  void MergeFrom(const MarketDepthFullUpdate10& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // repeated .DTC_PB.DepthEntry BidDepth = 2;
  inline int biddepth_size() const;
  inline void clear_biddepth();
  static const int kBidDepthFieldNumber = 2;
  inline const ::DTC_PB::DepthEntry& biddepth(int index) const;
  inline ::DTC_PB::DepthEntry* mutable_biddepth(int index);
  inline ::DTC_PB::DepthEntry* add_biddepth();
  inline const ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >&
      biddepth() const;
  inline ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >*
      mutable_biddepth();

  // repeated .DTC_PB.DepthEntry AskDepth = 3;
  inline int askdepth_size() const;
  inline void clear_askdepth();
  static const int kAskDepthFieldNumber = 3;
  inline const ::DTC_PB::DepthEntry& askdepth(int index) const;
  inline ::DTC_PB::DepthEntry* mutable_askdepth(int index);
  inline ::DTC_PB::DepthEntry* add_askdepth();
  inline const ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >&
      askdepth() const;
  inline ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >*
      mutable_askdepth();

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDepthFullUpdate10)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry > biddepth_;
  ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry > askdepth_;
  ::google::protobuf::uint32 symbolid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDepthFullUpdate10* default_instance_;
};
// -------------------------------------------------------------------

class MarketDepthSnapshotLevel : public ::google::protobuf::Message {
 public:
  MarketDepthSnapshotLevel();
  virtual ~MarketDepthSnapshotLevel();

  MarketDepthSnapshotLevel(const MarketDepthSnapshotLevel& from);

  inline MarketDepthSnapshotLevel& operator=(const MarketDepthSnapshotLevel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDepthSnapshotLevel& default_instance();

  void Swap(MarketDepthSnapshotLevel* other);

  // implements Message ----------------------------------------------

  MarketDepthSnapshotLevel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDepthSnapshotLevel& from);
  void MergeFrom(const MarketDepthSnapshotLevel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.AtBidOrAskEnum Side = 2;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 2;
  inline ::DTC_PB::AtBidOrAskEnum side() const;
  inline void set_side(::DTC_PB::AtBidOrAskEnum value);

  // optional double Price = 3;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 3;
  inline double price() const;
  inline void set_price(double value);

  // optional double Quantity = 4;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 4;
  inline double quantity() const;
  inline void set_quantity(double value);

  // optional uint32 Level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 IsFirstMessageInBatch = 6;
  inline bool has_isfirstmessageinbatch() const;
  inline void clear_isfirstmessageinbatch();
  static const int kIsFirstMessageInBatchFieldNumber = 6;
  inline ::google::protobuf::uint32 isfirstmessageinbatch() const;
  inline void set_isfirstmessageinbatch(::google::protobuf::uint32 value);

  // optional uint32 IsLastMessageInBatch = 7;
  inline bool has_islastmessageinbatch() const;
  inline void clear_islastmessageinbatch();
  static const int kIsLastMessageInBatchFieldNumber = 7;
  inline ::google::protobuf::uint32 islastmessageinbatch() const;
  inline void set_islastmessageinbatch(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDepthSnapshotLevel)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_isfirstmessageinbatch();
  inline void clear_has_isfirstmessageinbatch();
  inline void set_has_islastmessageinbatch();
  inline void clear_has_islastmessageinbatch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  int side_;
  double price_;
  double quantity_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 isfirstmessageinbatch_;
  ::google::protobuf::uint32 islastmessageinbatch_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDepthSnapshotLevel* default_instance_;
};
// -------------------------------------------------------------------

class MarketDepthSnapshotLevel_Int : public ::google::protobuf::Message {
 public:
  MarketDepthSnapshotLevel_Int();
  virtual ~MarketDepthSnapshotLevel_Int();

  MarketDepthSnapshotLevel_Int(const MarketDepthSnapshotLevel_Int& from);

  inline MarketDepthSnapshotLevel_Int& operator=(const MarketDepthSnapshotLevel_Int& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDepthSnapshotLevel_Int& default_instance();

  void Swap(MarketDepthSnapshotLevel_Int* other);

  // implements Message ----------------------------------------------

  MarketDepthSnapshotLevel_Int* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDepthSnapshotLevel_Int& from);
  void MergeFrom(const MarketDepthSnapshotLevel_Int& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.AtBidOrAskEnum Side = 2;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 2;
  inline ::DTC_PB::AtBidOrAskEnum side() const;
  inline void set_side(::DTC_PB::AtBidOrAskEnum value);

  // optional int32 Price = 3;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 3;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional int32 Quantity = 4;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 4;
  inline ::google::protobuf::int32 quantity() const;
  inline void set_quantity(::google::protobuf::int32 value);

  // optional uint32 Level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 IsFirstMessageInBatch = 6;
  inline bool has_isfirstmessageinbatch() const;
  inline void clear_isfirstmessageinbatch();
  static const int kIsFirstMessageInBatchFieldNumber = 6;
  inline ::google::protobuf::uint32 isfirstmessageinbatch() const;
  inline void set_isfirstmessageinbatch(::google::protobuf::uint32 value);

  // optional uint32 IsLastMessageInBatch = 7;
  inline bool has_islastmessageinbatch() const;
  inline void clear_islastmessageinbatch();
  static const int kIsLastMessageInBatchFieldNumber = 7;
  inline ::google::protobuf::uint32 islastmessageinbatch() const;
  inline void set_islastmessageinbatch(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDepthSnapshotLevel_Int)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_isfirstmessageinbatch();
  inline void clear_has_isfirstmessageinbatch();
  inline void set_has_islastmessageinbatch();
  inline void clear_has_islastmessageinbatch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  int side_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 quantity_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 isfirstmessageinbatch_;
  ::google::protobuf::uint32 islastmessageinbatch_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDepthSnapshotLevel_Int* default_instance_;
};
// -------------------------------------------------------------------

class MarketDepthUpdateLevel : public ::google::protobuf::Message {
 public:
  MarketDepthUpdateLevel();
  virtual ~MarketDepthUpdateLevel();

  MarketDepthUpdateLevel(const MarketDepthUpdateLevel& from);

  inline MarketDepthUpdateLevel& operator=(const MarketDepthUpdateLevel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDepthUpdateLevel& default_instance();

  void Swap(MarketDepthUpdateLevel* other);

  // implements Message ----------------------------------------------

  MarketDepthUpdateLevel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDepthUpdateLevel& from);
  void MergeFrom(const MarketDepthUpdateLevel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.AtBidOrAskEnum Side = 2;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 2;
  inline ::DTC_PB::AtBidOrAskEnum side() const;
  inline void set_side(::DTC_PB::AtBidOrAskEnum value);

  // optional double Price = 3;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 3;
  inline double price() const;
  inline void set_price(double value);

  // optional double Quantity = 4;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 4;
  inline double quantity() const;
  inline void set_quantity(double value);

  // optional .DTC_PB.MarketDepthUpdateTypeEnum UpdateType = 5;
  inline bool has_updatetype() const;
  inline void clear_updatetype();
  static const int kUpdateTypeFieldNumber = 5;
  inline ::DTC_PB::MarketDepthUpdateTypeEnum updatetype() const;
  inline void set_updatetype(::DTC_PB::MarketDepthUpdateTypeEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDepthUpdateLevel)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_updatetype();
  inline void clear_has_updatetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  int side_;
  double price_;
  double quantity_;
  int updatetype_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDepthUpdateLevel* default_instance_;
};
// -------------------------------------------------------------------

class MarketDepthUpdateLevel_Int : public ::google::protobuf::Message {
 public:
  MarketDepthUpdateLevel_Int();
  virtual ~MarketDepthUpdateLevel_Int();

  MarketDepthUpdateLevel_Int(const MarketDepthUpdateLevel_Int& from);

  inline MarketDepthUpdateLevel_Int& operator=(const MarketDepthUpdateLevel_Int& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDepthUpdateLevel_Int& default_instance();

  void Swap(MarketDepthUpdateLevel_Int* other);

  // implements Message ----------------------------------------------

  MarketDepthUpdateLevel_Int* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDepthUpdateLevel_Int& from);
  void MergeFrom(const MarketDepthUpdateLevel_Int& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.AtBidOrAskEnum Side = 2;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 2;
  inline ::DTC_PB::AtBidOrAskEnum side() const;
  inline void set_side(::DTC_PB::AtBidOrAskEnum value);

  // optional int32 Price = 3;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 3;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional int32 Quantity = 4;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 4;
  inline ::google::protobuf::int32 quantity() const;
  inline void set_quantity(::google::protobuf::int32 value);

  // optional .DTC_PB.MarketDepthUpdateTypeEnum UpdateType = 5;
  inline bool has_updatetype() const;
  inline void clear_updatetype();
  static const int kUpdateTypeFieldNumber = 5;
  inline ::DTC_PB::MarketDepthUpdateTypeEnum updatetype() const;
  inline void set_updatetype(::DTC_PB::MarketDepthUpdateTypeEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDepthUpdateLevel_Int)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_updatetype();
  inline void clear_has_updatetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  int side_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 quantity_;
  int updatetype_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDepthUpdateLevel_Int* default_instance_;
};
// -------------------------------------------------------------------

class MarketDepthUpdateLevelCompact : public ::google::protobuf::Message {
 public:
  MarketDepthUpdateLevelCompact();
  virtual ~MarketDepthUpdateLevelCompact();

  MarketDepthUpdateLevelCompact(const MarketDepthUpdateLevelCompact& from);

  inline MarketDepthUpdateLevelCompact& operator=(const MarketDepthUpdateLevelCompact& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDepthUpdateLevelCompact& default_instance();

  void Swap(MarketDepthUpdateLevelCompact* other);

  // implements Message ----------------------------------------------

  MarketDepthUpdateLevelCompact* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDepthUpdateLevelCompact& from);
  void MergeFrom(const MarketDepthUpdateLevelCompact& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.AtBidOrAskEnum Side = 2;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 2;
  inline ::DTC_PB::AtBidOrAskEnum side() const;
  inline void set_side(::DTC_PB::AtBidOrAskEnum value);

  // optional float Price = 3;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 3;
  inline float price() const;
  inline void set_price(float value);

  // optional float Quantity = 4;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 4;
  inline float quantity() const;
  inline void set_quantity(float value);

  // optional .DTC_PB.MarketDepthUpdateTypeEnum UpdateType = 5;
  inline bool has_updatetype() const;
  inline void clear_updatetype();
  static const int kUpdateTypeFieldNumber = 5;
  inline ::DTC_PB::MarketDepthUpdateTypeEnum updatetype() const;
  inline void set_updatetype(::DTC_PB::MarketDepthUpdateTypeEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDepthUpdateLevelCompact)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_updatetype();
  inline void clear_has_updatetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  int side_;
  float price_;
  float quantity_;
  int updatetype_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDepthUpdateLevelCompact* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataUpdateSessionSettlement : public ::google::protobuf::Message {
 public:
  MarketDataUpdateSessionSettlement();
  virtual ~MarketDataUpdateSessionSettlement();

  MarketDataUpdateSessionSettlement(const MarketDataUpdateSessionSettlement& from);

  inline MarketDataUpdateSessionSettlement& operator=(const MarketDataUpdateSessionSettlement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateSessionSettlement& default_instance();

  void Swap(MarketDataUpdateSessionSettlement* other);

  // implements Message ----------------------------------------------

  MarketDataUpdateSessionSettlement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataUpdateSessionSettlement& from);
  void MergeFrom(const MarketDataUpdateSessionSettlement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional double Price = 2;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 2;
  inline double price() const;
  inline void set_price(double value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateSessionSettlement)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_price();
  inline void clear_has_price();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double price_;
  ::google::protobuf::uint32 symbolid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataUpdateSessionSettlement* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataUpdateSessionSettlement_Int : public ::google::protobuf::Message {
 public:
  MarketDataUpdateSessionSettlement_Int();
  virtual ~MarketDataUpdateSessionSettlement_Int();

  MarketDataUpdateSessionSettlement_Int(const MarketDataUpdateSessionSettlement_Int& from);

  inline MarketDataUpdateSessionSettlement_Int& operator=(const MarketDataUpdateSessionSettlement_Int& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateSessionSettlement_Int& default_instance();

  void Swap(MarketDataUpdateSessionSettlement_Int* other);

  // implements Message ----------------------------------------------

  MarketDataUpdateSessionSettlement_Int* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataUpdateSessionSettlement_Int& from);
  void MergeFrom(const MarketDataUpdateSessionSettlement_Int& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional int32 Price = 2;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 2;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateSessionSettlement_Int)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_price();
  inline void clear_has_price();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::int32 price_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataUpdateSessionSettlement_Int* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataUpdateSessionOpen : public ::google::protobuf::Message {
 public:
  MarketDataUpdateSessionOpen();
  virtual ~MarketDataUpdateSessionOpen();

  MarketDataUpdateSessionOpen(const MarketDataUpdateSessionOpen& from);

  inline MarketDataUpdateSessionOpen& operator=(const MarketDataUpdateSessionOpen& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateSessionOpen& default_instance();

  void Swap(MarketDataUpdateSessionOpen* other);

  // implements Message ----------------------------------------------

  MarketDataUpdateSessionOpen* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataUpdateSessionOpen& from);
  void MergeFrom(const MarketDataUpdateSessionOpen& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional double Price = 2;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 2;
  inline double price() const;
  inline void set_price(double value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateSessionOpen)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_price();
  inline void clear_has_price();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double price_;
  ::google::protobuf::uint32 symbolid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataUpdateSessionOpen* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataUpdateSessionOpen_Int : public ::google::protobuf::Message {
 public:
  MarketDataUpdateSessionOpen_Int();
  virtual ~MarketDataUpdateSessionOpen_Int();

  MarketDataUpdateSessionOpen_Int(const MarketDataUpdateSessionOpen_Int& from);

  inline MarketDataUpdateSessionOpen_Int& operator=(const MarketDataUpdateSessionOpen_Int& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateSessionOpen_Int& default_instance();

  void Swap(MarketDataUpdateSessionOpen_Int* other);

  // implements Message ----------------------------------------------

  MarketDataUpdateSessionOpen_Int* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataUpdateSessionOpen_Int& from);
  void MergeFrom(const MarketDataUpdateSessionOpen_Int& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional int32 Price = 2;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 2;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateSessionOpen_Int)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_price();
  inline void clear_has_price();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::int32 price_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataUpdateSessionOpen_Int* default_instance_;
};
// -------------------------------------------------------------------

class MarketDepthReject : public ::google::protobuf::Message {
 public:
  MarketDepthReject();
  virtual ~MarketDepthReject();

  MarketDepthReject(const MarketDepthReject& from);

  inline MarketDepthReject& operator=(const MarketDepthReject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDepthReject& default_instance();

  void Swap(MarketDepthReject* other);

  // implements Message ----------------------------------------------

  MarketDepthReject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDepthReject& from);
  void MergeFrom(const MarketDepthReject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional string RejectText = 2;
  inline bool has_rejecttext() const;
  inline void clear_rejecttext();
  static const int kRejectTextFieldNumber = 2;
  inline const ::std::string& rejecttext() const;
  inline void set_rejecttext(const ::std::string& value);
  inline void set_rejecttext(const char* value);
  inline void set_rejecttext(const char* value, size_t size);
  inline ::std::string* mutable_rejecttext();
  inline ::std::string* release_rejecttext();
  inline void set_allocated_rejecttext(::std::string* rejecttext);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDepthReject)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_rejecttext();
  inline void clear_has_rejecttext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* rejecttext_;
  ::google::protobuf::uint32 symbolid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDepthReject* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataUpdateTrade : public ::google::protobuf::Message {
 public:
  MarketDataUpdateTrade();
  virtual ~MarketDataUpdateTrade();

  MarketDataUpdateTrade(const MarketDataUpdateTrade& from);

  inline MarketDataUpdateTrade& operator=(const MarketDataUpdateTrade& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateTrade& default_instance();

  void Swap(MarketDataUpdateTrade* other);

  // implements Message ----------------------------------------------

  MarketDataUpdateTrade* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataUpdateTrade& from);
  void MergeFrom(const MarketDataUpdateTrade& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 2;
  inline bool has_atbidorask() const;
  inline void clear_atbidorask();
  static const int kAtBidOrAskFieldNumber = 2;
  inline ::DTC_PB::AtBidOrAskEnum atbidorask() const;
  inline void set_atbidorask(::DTC_PB::AtBidOrAskEnum value);

  // optional double Price = 3;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 3;
  inline double price() const;
  inline void set_price(double value);

  // optional double Volume = 4;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 4;
  inline double volume() const;
  inline void set_volume(double value);

  // optional double DateTime = 5;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDateTimeFieldNumber = 5;
  inline double datetime() const;
  inline void set_datetime(double value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateTrade)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_atbidorask();
  inline void clear_has_atbidorask();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_datetime();
  inline void clear_has_datetime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  int atbidorask_;
  double price_;
  double volume_;
  double datetime_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataUpdateTrade* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataUpdateTrade_Int : public ::google::protobuf::Message {
 public:
  MarketDataUpdateTrade_Int();
  virtual ~MarketDataUpdateTrade_Int();

  MarketDataUpdateTrade_Int(const MarketDataUpdateTrade_Int& from);

  inline MarketDataUpdateTrade_Int& operator=(const MarketDataUpdateTrade_Int& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateTrade_Int& default_instance();

  void Swap(MarketDataUpdateTrade_Int* other);

  // implements Message ----------------------------------------------

  MarketDataUpdateTrade_Int* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataUpdateTrade_Int& from);
  void MergeFrom(const MarketDataUpdateTrade_Int& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 2;
  inline bool has_atbidorask() const;
  inline void clear_atbidorask();
  static const int kAtBidOrAskFieldNumber = 2;
  inline ::DTC_PB::AtBidOrAskEnum atbidorask() const;
  inline void set_atbidorask(::DTC_PB::AtBidOrAskEnum value);

  // optional int32 Price = 3;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 3;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional int32 Volume = 4;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 4;
  inline ::google::protobuf::int32 volume() const;
  inline void set_volume(::google::protobuf::int32 value);

  // optional double DateTime = 5;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDateTimeFieldNumber = 5;
  inline double datetime() const;
  inline void set_datetime(double value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateTrade_Int)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_atbidorask();
  inline void clear_has_atbidorask();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_datetime();
  inline void clear_has_datetime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  int atbidorask_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 volume_;
  double datetime_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataUpdateTrade_Int* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataUpdateBidAsk : public ::google::protobuf::Message {
 public:
  MarketDataUpdateBidAsk();
  virtual ~MarketDataUpdateBidAsk();

  MarketDataUpdateBidAsk(const MarketDataUpdateBidAsk& from);

  inline MarketDataUpdateBidAsk& operator=(const MarketDataUpdateBidAsk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateBidAsk& default_instance();

  void Swap(MarketDataUpdateBidAsk* other);

  // implements Message ----------------------------------------------

  MarketDataUpdateBidAsk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataUpdateBidAsk& from);
  void MergeFrom(const MarketDataUpdateBidAsk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional double BidPrice = 2;
  inline bool has_bidprice() const;
  inline void clear_bidprice();
  static const int kBidPriceFieldNumber = 2;
  inline double bidprice() const;
  inline void set_bidprice(double value);

  // optional float BidQuantity = 3;
  inline bool has_bidquantity() const;
  inline void clear_bidquantity();
  static const int kBidQuantityFieldNumber = 3;
  inline float bidquantity() const;
  inline void set_bidquantity(float value);

  // optional double AskPrice = 4;
  inline bool has_askprice() const;
  inline void clear_askprice();
  static const int kAskPriceFieldNumber = 4;
  inline double askprice() const;
  inline void set_askprice(double value);

  // optional float AskQuantity = 5;
  inline bool has_askquantity() const;
  inline void clear_askquantity();
  static const int kAskQuantityFieldNumber = 5;
  inline float askquantity() const;
  inline void set_askquantity(float value);

  // optional sfixed32 DateTime = 6;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDateTimeFieldNumber = 6;
  inline ::google::protobuf::int32 datetime() const;
  inline void set_datetime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateBidAsk)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_bidprice();
  inline void clear_has_bidprice();
  inline void set_has_bidquantity();
  inline void clear_has_bidquantity();
  inline void set_has_askprice();
  inline void clear_has_askprice();
  inline void set_has_askquantity();
  inline void clear_has_askquantity();
  inline void set_has_datetime();
  inline void clear_has_datetime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double bidprice_;
  ::google::protobuf::uint32 symbolid_;
  float bidquantity_;
  double askprice_;
  float askquantity_;
  ::google::protobuf::int32 datetime_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataUpdateBidAsk* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataUpdateBidAsk_Int : public ::google::protobuf::Message {
 public:
  MarketDataUpdateBidAsk_Int();
  virtual ~MarketDataUpdateBidAsk_Int();

  MarketDataUpdateBidAsk_Int(const MarketDataUpdateBidAsk_Int& from);

  inline MarketDataUpdateBidAsk_Int& operator=(const MarketDataUpdateBidAsk_Int& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateBidAsk_Int& default_instance();

  void Swap(MarketDataUpdateBidAsk_Int* other);

  // implements Message ----------------------------------------------

  MarketDataUpdateBidAsk_Int* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataUpdateBidAsk_Int& from);
  void MergeFrom(const MarketDataUpdateBidAsk_Int& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional int32 BidPrice = 2;
  inline bool has_bidprice() const;
  inline void clear_bidprice();
  static const int kBidPriceFieldNumber = 2;
  inline ::google::protobuf::int32 bidprice() const;
  inline void set_bidprice(::google::protobuf::int32 value);

  // optional int32 BidQuantity = 3;
  inline bool has_bidquantity() const;
  inline void clear_bidquantity();
  static const int kBidQuantityFieldNumber = 3;
  inline ::google::protobuf::int32 bidquantity() const;
  inline void set_bidquantity(::google::protobuf::int32 value);

  // optional int32 AskPrice = 4;
  inline bool has_askprice() const;
  inline void clear_askprice();
  static const int kAskPriceFieldNumber = 4;
  inline ::google::protobuf::int32 askprice() const;
  inline void set_askprice(::google::protobuf::int32 value);

  // optional int32 AskQuantity = 5;
  inline bool has_askquantity() const;
  inline void clear_askquantity();
  static const int kAskQuantityFieldNumber = 5;
  inline ::google::protobuf::int32 askquantity() const;
  inline void set_askquantity(::google::protobuf::int32 value);

  // optional sfixed32 DateTime = 6;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDateTimeFieldNumber = 6;
  inline ::google::protobuf::int32 datetime() const;
  inline void set_datetime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateBidAsk_Int)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_bidprice();
  inline void clear_has_bidprice();
  inline void set_has_bidquantity();
  inline void clear_has_bidquantity();
  inline void set_has_askprice();
  inline void clear_has_askprice();
  inline void set_has_askquantity();
  inline void clear_has_askquantity();
  inline void set_has_datetime();
  inline void clear_has_datetime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::int32 bidprice_;
  ::google::protobuf::int32 bidquantity_;
  ::google::protobuf::int32 askprice_;
  ::google::protobuf::int32 askquantity_;
  ::google::protobuf::int32 datetime_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataUpdateBidAsk_Int* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataUpdateBidAskCompact : public ::google::protobuf::Message {
 public:
  MarketDataUpdateBidAskCompact();
  virtual ~MarketDataUpdateBidAskCompact();

  MarketDataUpdateBidAskCompact(const MarketDataUpdateBidAskCompact& from);

  inline MarketDataUpdateBidAskCompact& operator=(const MarketDataUpdateBidAskCompact& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateBidAskCompact& default_instance();

  void Swap(MarketDataUpdateBidAskCompact* other);

  // implements Message ----------------------------------------------

  MarketDataUpdateBidAskCompact* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataUpdateBidAskCompact& from);
  void MergeFrom(const MarketDataUpdateBidAskCompact& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float BidPrice = 1;
  inline bool has_bidprice() const;
  inline void clear_bidprice();
  static const int kBidPriceFieldNumber = 1;
  inline float bidprice() const;
  inline void set_bidprice(float value);

  // optional float BidQuantity = 2;
  inline bool has_bidquantity() const;
  inline void clear_bidquantity();
  static const int kBidQuantityFieldNumber = 2;
  inline float bidquantity() const;
  inline void set_bidquantity(float value);

  // optional float AskPrice = 3;
  inline bool has_askprice() const;
  inline void clear_askprice();
  static const int kAskPriceFieldNumber = 3;
  inline float askprice() const;
  inline void set_askprice(float value);

  // optional float AskQuantity = 4;
  inline bool has_askquantity() const;
  inline void clear_askquantity();
  static const int kAskQuantityFieldNumber = 4;
  inline float askquantity() const;
  inline void set_askquantity(float value);

  // optional sfixed32 DateTime = 5;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDateTimeFieldNumber = 5;
  inline ::google::protobuf::int32 datetime() const;
  inline void set_datetime(::google::protobuf::int32 value);

  // optional uint32 SymbolID = 6;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 6;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateBidAskCompact)
 private:
  inline void set_has_bidprice();
  inline void clear_has_bidprice();
  inline void set_has_bidquantity();
  inline void clear_has_bidquantity();
  inline void set_has_askprice();
  inline void clear_has_askprice();
  inline void set_has_askquantity();
  inline void clear_has_askquantity();
  inline void set_has_datetime();
  inline void clear_has_datetime();
  inline void set_has_symbolid();
  inline void clear_has_symbolid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float bidprice_;
  float bidquantity_;
  float askprice_;
  float askquantity_;
  ::google::protobuf::int32 datetime_;
  ::google::protobuf::uint32 symbolid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataUpdateBidAskCompact* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataUpdateTradeCompact : public ::google::protobuf::Message {
 public:
  MarketDataUpdateTradeCompact();
  virtual ~MarketDataUpdateTradeCompact();

  MarketDataUpdateTradeCompact(const MarketDataUpdateTradeCompact& from);

  inline MarketDataUpdateTradeCompact& operator=(const MarketDataUpdateTradeCompact& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateTradeCompact& default_instance();

  void Swap(MarketDataUpdateTradeCompact* other);

  // implements Message ----------------------------------------------

  MarketDataUpdateTradeCompact* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataUpdateTradeCompact& from);
  void MergeFrom(const MarketDataUpdateTradeCompact& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float Price = 1;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 1;
  inline float price() const;
  inline void set_price(float value);

  // optional float Volume = 2;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 2;
  inline float volume() const;
  inline void set_volume(float value);

  // optional sfixed32 DateTime = 3;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDateTimeFieldNumber = 3;
  inline ::google::protobuf::int32 datetime() const;
  inline void set_datetime(::google::protobuf::int32 value);

  // optional uint32 SymbolID = 4;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 4;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 5;
  inline bool has_atbidorask() const;
  inline void clear_atbidorask();
  static const int kAtBidOrAskFieldNumber = 5;
  inline ::DTC_PB::AtBidOrAskEnum atbidorask() const;
  inline void set_atbidorask(::DTC_PB::AtBidOrAskEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateTradeCompact)
 private:
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_datetime();
  inline void clear_has_datetime();
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_atbidorask();
  inline void clear_has_atbidorask();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float price_;
  float volume_;
  ::google::protobuf::int32 datetime_;
  ::google::protobuf::uint32 symbolid_;
  int atbidorask_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataUpdateTradeCompact* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataUpdateSessionVolume : public ::google::protobuf::Message {
 public:
  MarketDataUpdateSessionVolume();
  virtual ~MarketDataUpdateSessionVolume();

  MarketDataUpdateSessionVolume(const MarketDataUpdateSessionVolume& from);

  inline MarketDataUpdateSessionVolume& operator=(const MarketDataUpdateSessionVolume& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateSessionVolume& default_instance();

  void Swap(MarketDataUpdateSessionVolume* other);

  // implements Message ----------------------------------------------

  MarketDataUpdateSessionVolume* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataUpdateSessionVolume& from);
  void MergeFrom(const MarketDataUpdateSessionVolume& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional double Volume = 2;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 2;
  inline double volume() const;
  inline void set_volume(double value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateSessionVolume)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_volume();
  inline void clear_has_volume();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double volume_;
  ::google::protobuf::uint32 symbolid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataUpdateSessionVolume* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataUpdateOpenInterest : public ::google::protobuf::Message {
 public:
  MarketDataUpdateOpenInterest();
  virtual ~MarketDataUpdateOpenInterest();

  MarketDataUpdateOpenInterest(const MarketDataUpdateOpenInterest& from);

  inline MarketDataUpdateOpenInterest& operator=(const MarketDataUpdateOpenInterest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateOpenInterest& default_instance();

  void Swap(MarketDataUpdateOpenInterest* other);

  // implements Message ----------------------------------------------

  MarketDataUpdateOpenInterest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataUpdateOpenInterest& from);
  void MergeFrom(const MarketDataUpdateOpenInterest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional uint32 OpenInterest = 2;
  inline bool has_openinterest() const;
  inline void clear_openinterest();
  static const int kOpenInterestFieldNumber = 2;
  inline ::google::protobuf::uint32 openinterest() const;
  inline void set_openinterest(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateOpenInterest)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_openinterest();
  inline void clear_has_openinterest();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::uint32 openinterest_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataUpdateOpenInterest* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataUpdateSessionHigh : public ::google::protobuf::Message {
 public:
  MarketDataUpdateSessionHigh();
  virtual ~MarketDataUpdateSessionHigh();

  MarketDataUpdateSessionHigh(const MarketDataUpdateSessionHigh& from);

  inline MarketDataUpdateSessionHigh& operator=(const MarketDataUpdateSessionHigh& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateSessionHigh& default_instance();

  void Swap(MarketDataUpdateSessionHigh* other);

  // implements Message ----------------------------------------------

  MarketDataUpdateSessionHigh* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataUpdateSessionHigh& from);
  void MergeFrom(const MarketDataUpdateSessionHigh& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional double Price = 2;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 2;
  inline double price() const;
  inline void set_price(double value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateSessionHigh)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_price();
  inline void clear_has_price();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double price_;
  ::google::protobuf::uint32 symbolid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataUpdateSessionHigh* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataUpdateSessionHigh_Int : public ::google::protobuf::Message {
 public:
  MarketDataUpdateSessionHigh_Int();
  virtual ~MarketDataUpdateSessionHigh_Int();

  MarketDataUpdateSessionHigh_Int(const MarketDataUpdateSessionHigh_Int& from);

  inline MarketDataUpdateSessionHigh_Int& operator=(const MarketDataUpdateSessionHigh_Int& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateSessionHigh_Int& default_instance();

  void Swap(MarketDataUpdateSessionHigh_Int* other);

  // implements Message ----------------------------------------------

  MarketDataUpdateSessionHigh_Int* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataUpdateSessionHigh_Int& from);
  void MergeFrom(const MarketDataUpdateSessionHigh_Int& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional int32 Price = 2;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 2;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateSessionHigh_Int)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_price();
  inline void clear_has_price();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::int32 price_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataUpdateSessionHigh_Int* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataUpdateSessionLow : public ::google::protobuf::Message {
 public:
  MarketDataUpdateSessionLow();
  virtual ~MarketDataUpdateSessionLow();

  MarketDataUpdateSessionLow(const MarketDataUpdateSessionLow& from);

  inline MarketDataUpdateSessionLow& operator=(const MarketDataUpdateSessionLow& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateSessionLow& default_instance();

  void Swap(MarketDataUpdateSessionLow* other);

  // implements Message ----------------------------------------------

  MarketDataUpdateSessionLow* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataUpdateSessionLow& from);
  void MergeFrom(const MarketDataUpdateSessionLow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional double Price = 2;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 2;
  inline double price() const;
  inline void set_price(double value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateSessionLow)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_price();
  inline void clear_has_price();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double price_;
  ::google::protobuf::uint32 symbolid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataUpdateSessionLow* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataUpdateSessionLow_Int : public ::google::protobuf::Message {
 public:
  MarketDataUpdateSessionLow_Int();
  virtual ~MarketDataUpdateSessionLow_Int();

  MarketDataUpdateSessionLow_Int(const MarketDataUpdateSessionLow_Int& from);

  inline MarketDataUpdateSessionLow_Int& operator=(const MarketDataUpdateSessionLow_Int& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateSessionLow_Int& default_instance();

  void Swap(MarketDataUpdateSessionLow_Int* other);

  // implements Message ----------------------------------------------

  MarketDataUpdateSessionLow_Int* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataUpdateSessionLow_Int& from);
  void MergeFrom(const MarketDataUpdateSessionLow_Int& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional int32 Price = 2;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 2;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateSessionLow_Int)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_price();
  inline void clear_has_price();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 symbolid_;
  ::google::protobuf::int32 price_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataUpdateSessionLow_Int* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataUpdateLastTradeSnapshot : public ::google::protobuf::Message {
 public:
  MarketDataUpdateLastTradeSnapshot();
  virtual ~MarketDataUpdateLastTradeSnapshot();

  MarketDataUpdateLastTradeSnapshot(const MarketDataUpdateLastTradeSnapshot& from);

  inline MarketDataUpdateLastTradeSnapshot& operator=(const MarketDataUpdateLastTradeSnapshot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataUpdateLastTradeSnapshot& default_instance();

  void Swap(MarketDataUpdateLastTradeSnapshot* other);

  // implements Message ----------------------------------------------

  MarketDataUpdateLastTradeSnapshot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataUpdateLastTradeSnapshot& from);
  void MergeFrom(const MarketDataUpdateLastTradeSnapshot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SymbolID = 1;
  inline bool has_symbolid() const;
  inline void clear_symbolid();
  static const int kSymbolIDFieldNumber = 1;
  inline ::google::protobuf::uint32 symbolid() const;
  inline void set_symbolid(::google::protobuf::uint32 value);

  // optional double LastTradePrice = 2;
  inline bool has_lasttradeprice() const;
  inline void clear_lasttradeprice();
  static const int kLastTradePriceFieldNumber = 2;
  inline double lasttradeprice() const;
  inline void set_lasttradeprice(double value);

  // optional double LastTradeVolume = 3;
  inline bool has_lasttradevolume() const;
  inline void clear_lasttradevolume();
  static const int kLastTradeVolumeFieldNumber = 3;
  inline double lasttradevolume() const;
  inline void set_lasttradevolume(double value);

  // optional double LastTradeDateTime = 4;
  inline bool has_lasttradedatetime() const;
  inline void clear_lasttradedatetime();
  static const int kLastTradeDateTimeFieldNumber = 4;
  inline double lasttradedatetime() const;
  inline void set_lasttradedatetime(double value);

  // @@protoc_insertion_point(class_scope:DTC_PB.MarketDataUpdateLastTradeSnapshot)
 private:
  inline void set_has_symbolid();
  inline void clear_has_symbolid();
  inline void set_has_lasttradeprice();
  inline void clear_has_lasttradeprice();
  inline void set_has_lasttradevolume();
  inline void clear_has_lasttradevolume();
  inline void set_has_lasttradedatetime();
  inline void clear_has_lasttradedatetime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double lasttradeprice_;
  double lasttradevolume_;
  double lasttradedatetime_;
  ::google::protobuf::uint32 symbolid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static MarketDataUpdateLastTradeSnapshot* default_instance_;
};
// -------------------------------------------------------------------

class SubmitNewSingleOrder : public ::google::protobuf::Message {
 public:
  SubmitNewSingleOrder();
  virtual ~SubmitNewSingleOrder();

  SubmitNewSingleOrder(const SubmitNewSingleOrder& from);

  inline SubmitNewSingleOrder& operator=(const SubmitNewSingleOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubmitNewSingleOrder& default_instance();

  void Swap(SubmitNewSingleOrder* other);

  // implements Message ----------------------------------------------

  SubmitNewSingleOrder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubmitNewSingleOrder& from);
  void MergeFrom(const SubmitNewSingleOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Symbol = 1;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 2;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 2;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // optional string TradeAccount = 3;
  inline bool has_tradeaccount() const;
  inline void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 3;
  inline const ::std::string& tradeaccount() const;
  inline void set_tradeaccount(const ::std::string& value);
  inline void set_tradeaccount(const char* value);
  inline void set_tradeaccount(const char* value, size_t size);
  inline ::std::string* mutable_tradeaccount();
  inline ::std::string* release_tradeaccount();
  inline void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional string ClientOrderID = 4;
  inline bool has_clientorderid() const;
  inline void clear_clientorderid();
  static const int kClientOrderIDFieldNumber = 4;
  inline const ::std::string& clientorderid() const;
  inline void set_clientorderid(const ::std::string& value);
  inline void set_clientorderid(const char* value);
  inline void set_clientorderid(const char* value, size_t size);
  inline ::std::string* mutable_clientorderid();
  inline ::std::string* release_clientorderid();
  inline void set_allocated_clientorderid(::std::string* clientorderid);

  // optional .DTC_PB.OrderTypeEnum OrderType = 5;
  inline bool has_ordertype() const;
  inline void clear_ordertype();
  static const int kOrderTypeFieldNumber = 5;
  inline ::DTC_PB::OrderTypeEnum ordertype() const;
  inline void set_ordertype(::DTC_PB::OrderTypeEnum value);

  // optional .DTC_PB.BuySellEnum BuySell = 6;
  inline bool has_buysell() const;
  inline void clear_buysell();
  static const int kBuySellFieldNumber = 6;
  inline ::DTC_PB::BuySellEnum buysell() const;
  inline void set_buysell(::DTC_PB::BuySellEnum value);

  // optional double Price1 = 7;
  inline bool has_price1() const;
  inline void clear_price1();
  static const int kPrice1FieldNumber = 7;
  inline double price1() const;
  inline void set_price1(double value);

  // optional double Price2 = 8;
  inline bool has_price2() const;
  inline void clear_price2();
  static const int kPrice2FieldNumber = 8;
  inline double price2() const;
  inline void set_price2(double value);

  // optional double Quantity = 9;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 9;
  inline double quantity() const;
  inline void set_quantity(double value);

  // optional .DTC_PB.TimeInForceEnum TimeInForce = 10;
  inline bool has_timeinforce() const;
  inline void clear_timeinforce();
  static const int kTimeInForceFieldNumber = 10;
  inline ::DTC_PB::TimeInForceEnum timeinforce() const;
  inline void set_timeinforce(::DTC_PB::TimeInForceEnum value);

  // optional sfixed64 GoodTillDateTime = 11;
  inline bool has_goodtilldatetime() const;
  inline void clear_goodtilldatetime();
  static const int kGoodTillDateTimeFieldNumber = 11;
  inline ::google::protobuf::int64 goodtilldatetime() const;
  inline void set_goodtilldatetime(::google::protobuf::int64 value);

  // optional uint32 IsAutomatedOrder = 12;
  inline bool has_isautomatedorder() const;
  inline void clear_isautomatedorder();
  static const int kIsAutomatedOrderFieldNumber = 12;
  inline ::google::protobuf::uint32 isautomatedorder() const;
  inline void set_isautomatedorder(::google::protobuf::uint32 value);

  // optional uint32 IsParentOrder = 13;
  inline bool has_isparentorder() const;
  inline void clear_isparentorder();
  static const int kIsParentOrderFieldNumber = 13;
  inline ::google::protobuf::uint32 isparentorder() const;
  inline void set_isparentorder(::google::protobuf::uint32 value);

  // optional string FreeFormText = 14;
  inline bool has_freeformtext() const;
  inline void clear_freeformtext();
  static const int kFreeFormTextFieldNumber = 14;
  inline const ::std::string& freeformtext() const;
  inline void set_freeformtext(const ::std::string& value);
  inline void set_freeformtext(const char* value);
  inline void set_freeformtext(const char* value, size_t size);
  inline ::std::string* mutable_freeformtext();
  inline ::std::string* release_freeformtext();
  inline void set_allocated_freeformtext(::std::string* freeformtext);

  // optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 15;
  inline bool has_openorclose() const;
  inline void clear_openorclose();
  static const int kOpenOrCloseFieldNumber = 15;
  inline ::DTC_PB::OpenCloseTradeEnum openorclose() const;
  inline void set_openorclose(::DTC_PB::OpenCloseTradeEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.SubmitNewSingleOrder)
 private:
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_exchange();
  inline void clear_has_exchange();
  inline void set_has_tradeaccount();
  inline void clear_has_tradeaccount();
  inline void set_has_clientorderid();
  inline void clear_has_clientorderid();
  inline void set_has_ordertype();
  inline void clear_has_ordertype();
  inline void set_has_buysell();
  inline void clear_has_buysell();
  inline void set_has_price1();
  inline void clear_has_price1();
  inline void set_has_price2();
  inline void clear_has_price2();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_timeinforce();
  inline void clear_has_timeinforce();
  inline void set_has_goodtilldatetime();
  inline void clear_has_goodtilldatetime();
  inline void set_has_isautomatedorder();
  inline void clear_has_isautomatedorder();
  inline void set_has_isparentorder();
  inline void clear_has_isparentorder();
  inline void set_has_freeformtext();
  inline void clear_has_freeformtext();
  inline void set_has_openorclose();
  inline void clear_has_openorclose();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* symbol_;
  ::std::string* exchange_;
  ::std::string* tradeaccount_;
  ::std::string* clientorderid_;
  int ordertype_;
  int buysell_;
  double price1_;
  double price2_;
  double quantity_;
  ::google::protobuf::int64 goodtilldatetime_;
  int timeinforce_;
  ::google::protobuf::uint32 isautomatedorder_;
  ::std::string* freeformtext_;
  ::google::protobuf::uint32 isparentorder_;
  int openorclose_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static SubmitNewSingleOrder* default_instance_;
};
// -------------------------------------------------------------------

class SubmitNewSingleOrderInt : public ::google::protobuf::Message {
 public:
  SubmitNewSingleOrderInt();
  virtual ~SubmitNewSingleOrderInt();

  SubmitNewSingleOrderInt(const SubmitNewSingleOrderInt& from);

  inline SubmitNewSingleOrderInt& operator=(const SubmitNewSingleOrderInt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubmitNewSingleOrderInt& default_instance();

  void Swap(SubmitNewSingleOrderInt* other);

  // implements Message ----------------------------------------------

  SubmitNewSingleOrderInt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubmitNewSingleOrderInt& from);
  void MergeFrom(const SubmitNewSingleOrderInt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Symbol = 1;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 2;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 2;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // optional string TradeAccount = 3;
  inline bool has_tradeaccount() const;
  inline void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 3;
  inline const ::std::string& tradeaccount() const;
  inline void set_tradeaccount(const ::std::string& value);
  inline void set_tradeaccount(const char* value);
  inline void set_tradeaccount(const char* value, size_t size);
  inline ::std::string* mutable_tradeaccount();
  inline ::std::string* release_tradeaccount();
  inline void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional string ClientOrderID = 4;
  inline bool has_clientorderid() const;
  inline void clear_clientorderid();
  static const int kClientOrderIDFieldNumber = 4;
  inline const ::std::string& clientorderid() const;
  inline void set_clientorderid(const ::std::string& value);
  inline void set_clientorderid(const char* value);
  inline void set_clientorderid(const char* value, size_t size);
  inline ::std::string* mutable_clientorderid();
  inline ::std::string* release_clientorderid();
  inline void set_allocated_clientorderid(::std::string* clientorderid);

  // optional .DTC_PB.OrderTypeEnum OrderType = 5;
  inline bool has_ordertype() const;
  inline void clear_ordertype();
  static const int kOrderTypeFieldNumber = 5;
  inline ::DTC_PB::OrderTypeEnum ordertype() const;
  inline void set_ordertype(::DTC_PB::OrderTypeEnum value);

  // optional .DTC_PB.BuySellEnum BuySell = 6;
  inline bool has_buysell() const;
  inline void clear_buysell();
  static const int kBuySellFieldNumber = 6;
  inline ::DTC_PB::BuySellEnum buysell() const;
  inline void set_buysell(::DTC_PB::BuySellEnum value);

  // optional int64 Price1 = 7;
  inline bool has_price1() const;
  inline void clear_price1();
  static const int kPrice1FieldNumber = 7;
  inline ::google::protobuf::int64 price1() const;
  inline void set_price1(::google::protobuf::int64 value);

  // optional int64 Price2 = 8;
  inline bool has_price2() const;
  inline void clear_price2();
  static const int kPrice2FieldNumber = 8;
  inline ::google::protobuf::int64 price2() const;
  inline void set_price2(::google::protobuf::int64 value);

  // optional float Divisor = 9;
  inline bool has_divisor() const;
  inline void clear_divisor();
  static const int kDivisorFieldNumber = 9;
  inline float divisor() const;
  inline void set_divisor(float value);

  // optional int64 Quantity = 10;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 10;
  inline ::google::protobuf::int64 quantity() const;
  inline void set_quantity(::google::protobuf::int64 value);

  // optional .DTC_PB.TimeInForceEnum TimeInForce = 11;
  inline bool has_timeinforce() const;
  inline void clear_timeinforce();
  static const int kTimeInForceFieldNumber = 11;
  inline ::DTC_PB::TimeInForceEnum timeinforce() const;
  inline void set_timeinforce(::DTC_PB::TimeInForceEnum value);

  // optional sfixed64 GoodTillDateTime = 12;
  inline bool has_goodtilldatetime() const;
  inline void clear_goodtilldatetime();
  static const int kGoodTillDateTimeFieldNumber = 12;
  inline ::google::protobuf::int64 goodtilldatetime() const;
  inline void set_goodtilldatetime(::google::protobuf::int64 value);

  // optional uint32 IsAutomatedOrder = 13;
  inline bool has_isautomatedorder() const;
  inline void clear_isautomatedorder();
  static const int kIsAutomatedOrderFieldNumber = 13;
  inline ::google::protobuf::uint32 isautomatedorder() const;
  inline void set_isautomatedorder(::google::protobuf::uint32 value);

  // optional uint32 IsParentOrder = 14;
  inline bool has_isparentorder() const;
  inline void clear_isparentorder();
  static const int kIsParentOrderFieldNumber = 14;
  inline ::google::protobuf::uint32 isparentorder() const;
  inline void set_isparentorder(::google::protobuf::uint32 value);

  // optional string FreeFormText = 15;
  inline bool has_freeformtext() const;
  inline void clear_freeformtext();
  static const int kFreeFormTextFieldNumber = 15;
  inline const ::std::string& freeformtext() const;
  inline void set_freeformtext(const ::std::string& value);
  inline void set_freeformtext(const char* value);
  inline void set_freeformtext(const char* value, size_t size);
  inline ::std::string* mutable_freeformtext();
  inline ::std::string* release_freeformtext();
  inline void set_allocated_freeformtext(::std::string* freeformtext);

  // optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 16;
  inline bool has_openorclose() const;
  inline void clear_openorclose();
  static const int kOpenOrCloseFieldNumber = 16;
  inline ::DTC_PB::OpenCloseTradeEnum openorclose() const;
  inline void set_openorclose(::DTC_PB::OpenCloseTradeEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.SubmitNewSingleOrderInt)
 private:
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_exchange();
  inline void clear_has_exchange();
  inline void set_has_tradeaccount();
  inline void clear_has_tradeaccount();
  inline void set_has_clientorderid();
  inline void clear_has_clientorderid();
  inline void set_has_ordertype();
  inline void clear_has_ordertype();
  inline void set_has_buysell();
  inline void clear_has_buysell();
  inline void set_has_price1();
  inline void clear_has_price1();
  inline void set_has_price2();
  inline void clear_has_price2();
  inline void set_has_divisor();
  inline void clear_has_divisor();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_timeinforce();
  inline void clear_has_timeinforce();
  inline void set_has_goodtilldatetime();
  inline void clear_has_goodtilldatetime();
  inline void set_has_isautomatedorder();
  inline void clear_has_isautomatedorder();
  inline void set_has_isparentorder();
  inline void clear_has_isparentorder();
  inline void set_has_freeformtext();
  inline void clear_has_freeformtext();
  inline void set_has_openorclose();
  inline void clear_has_openorclose();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* symbol_;
  ::std::string* exchange_;
  ::std::string* tradeaccount_;
  ::std::string* clientorderid_;
  int ordertype_;
  int buysell_;
  ::google::protobuf::int64 price1_;
  ::google::protobuf::int64 price2_;
  ::google::protobuf::int64 quantity_;
  float divisor_;
  int timeinforce_;
  ::google::protobuf::int64 goodtilldatetime_;
  ::google::protobuf::uint32 isautomatedorder_;
  ::google::protobuf::uint32 isparentorder_;
  ::std::string* freeformtext_;
  int openorclose_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static SubmitNewSingleOrderInt* default_instance_;
};
// -------------------------------------------------------------------

class CancelReplaceOrder : public ::google::protobuf::Message {
 public:
  CancelReplaceOrder();
  virtual ~CancelReplaceOrder();

  CancelReplaceOrder(const CancelReplaceOrder& from);

  inline CancelReplaceOrder& operator=(const CancelReplaceOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelReplaceOrder& default_instance();

  void Swap(CancelReplaceOrder* other);

  // implements Message ----------------------------------------------

  CancelReplaceOrder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CancelReplaceOrder& from);
  void MergeFrom(const CancelReplaceOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ServerOrderID = 1;
  inline bool has_serverorderid() const;
  inline void clear_serverorderid();
  static const int kServerOrderIDFieldNumber = 1;
  inline const ::std::string& serverorderid() const;
  inline void set_serverorderid(const ::std::string& value);
  inline void set_serverorderid(const char* value);
  inline void set_serverorderid(const char* value, size_t size);
  inline ::std::string* mutable_serverorderid();
  inline ::std::string* release_serverorderid();
  inline void set_allocated_serverorderid(::std::string* serverorderid);

  // optional string ClientOrderID = 2;
  inline bool has_clientorderid() const;
  inline void clear_clientorderid();
  static const int kClientOrderIDFieldNumber = 2;
  inline const ::std::string& clientorderid() const;
  inline void set_clientorderid(const ::std::string& value);
  inline void set_clientorderid(const char* value);
  inline void set_clientorderid(const char* value, size_t size);
  inline ::std::string* mutable_clientorderid();
  inline ::std::string* release_clientorderid();
  inline void set_allocated_clientorderid(::std::string* clientorderid);

  // optional double Price1 = 3;
  inline bool has_price1() const;
  inline void clear_price1();
  static const int kPrice1FieldNumber = 3;
  inline double price1() const;
  inline void set_price1(double value);

  // optional double Price2 = 4;
  inline bool has_price2() const;
  inline void clear_price2();
  static const int kPrice2FieldNumber = 4;
  inline double price2() const;
  inline void set_price2(double value);

  // optional double Quantity = 5;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 5;
  inline double quantity() const;
  inline void set_quantity(double value);

  // optional uint32 Price1IsSet = 6;
  inline bool has_price1isset() const;
  inline void clear_price1isset();
  static const int kPrice1IsSetFieldNumber = 6;
  inline ::google::protobuf::uint32 price1isset() const;
  inline void set_price1isset(::google::protobuf::uint32 value);

  // optional uint32 Price2IsSet = 7;
  inline bool has_price2isset() const;
  inline void clear_price2isset();
  static const int kPrice2IsSetFieldNumber = 7;
  inline ::google::protobuf::uint32 price2isset() const;
  inline void set_price2isset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.CancelReplaceOrder)
 private:
  inline void set_has_serverorderid();
  inline void clear_has_serverorderid();
  inline void set_has_clientorderid();
  inline void clear_has_clientorderid();
  inline void set_has_price1();
  inline void clear_has_price1();
  inline void set_has_price2();
  inline void clear_has_price2();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_price1isset();
  inline void clear_has_price1isset();
  inline void set_has_price2isset();
  inline void clear_has_price2isset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* serverorderid_;
  ::std::string* clientorderid_;
  double price1_;
  double price2_;
  double quantity_;
  ::google::protobuf::uint32 price1isset_;
  ::google::protobuf::uint32 price2isset_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static CancelReplaceOrder* default_instance_;
};
// -------------------------------------------------------------------

class CancelReplaceOrderInt : public ::google::protobuf::Message {
 public:
  CancelReplaceOrderInt();
  virtual ~CancelReplaceOrderInt();

  CancelReplaceOrderInt(const CancelReplaceOrderInt& from);

  inline CancelReplaceOrderInt& operator=(const CancelReplaceOrderInt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelReplaceOrderInt& default_instance();

  void Swap(CancelReplaceOrderInt* other);

  // implements Message ----------------------------------------------

  CancelReplaceOrderInt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CancelReplaceOrderInt& from);
  void MergeFrom(const CancelReplaceOrderInt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ServerOrderID = 1;
  inline bool has_serverorderid() const;
  inline void clear_serverorderid();
  static const int kServerOrderIDFieldNumber = 1;
  inline const ::std::string& serverorderid() const;
  inline void set_serverorderid(const ::std::string& value);
  inline void set_serverorderid(const char* value);
  inline void set_serverorderid(const char* value, size_t size);
  inline ::std::string* mutable_serverorderid();
  inline ::std::string* release_serverorderid();
  inline void set_allocated_serverorderid(::std::string* serverorderid);

  // optional string ClientOrderID = 2;
  inline bool has_clientorderid() const;
  inline void clear_clientorderid();
  static const int kClientOrderIDFieldNumber = 2;
  inline const ::std::string& clientorderid() const;
  inline void set_clientorderid(const ::std::string& value);
  inline void set_clientorderid(const char* value);
  inline void set_clientorderid(const char* value, size_t size);
  inline ::std::string* mutable_clientorderid();
  inline ::std::string* release_clientorderid();
  inline void set_allocated_clientorderid(::std::string* clientorderid);

  // optional int64 Price1 = 3;
  inline bool has_price1() const;
  inline void clear_price1();
  static const int kPrice1FieldNumber = 3;
  inline ::google::protobuf::int64 price1() const;
  inline void set_price1(::google::protobuf::int64 value);

  // optional int64 Price2 = 4;
  inline bool has_price2() const;
  inline void clear_price2();
  static const int kPrice2FieldNumber = 4;
  inline ::google::protobuf::int64 price2() const;
  inline void set_price2(::google::protobuf::int64 value);

  // optional float Divisor = 5;
  inline bool has_divisor() const;
  inline void clear_divisor();
  static const int kDivisorFieldNumber = 5;
  inline float divisor() const;
  inline void set_divisor(float value);

  // optional int64 Quantity = 6;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 6;
  inline ::google::protobuf::int64 quantity() const;
  inline void set_quantity(::google::protobuf::int64 value);

  // optional uint32 Price1IsSet = 7;
  inline bool has_price1isset() const;
  inline void clear_price1isset();
  static const int kPrice1IsSetFieldNumber = 7;
  inline ::google::protobuf::uint32 price1isset() const;
  inline void set_price1isset(::google::protobuf::uint32 value);

  // optional uint32 Price2IsSet = 8;
  inline bool has_price2isset() const;
  inline void clear_price2isset();
  static const int kPrice2IsSetFieldNumber = 8;
  inline ::google::protobuf::uint32 price2isset() const;
  inline void set_price2isset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.CancelReplaceOrderInt)
 private:
  inline void set_has_serverorderid();
  inline void clear_has_serverorderid();
  inline void set_has_clientorderid();
  inline void clear_has_clientorderid();
  inline void set_has_price1();
  inline void clear_has_price1();
  inline void set_has_price2();
  inline void clear_has_price2();
  inline void set_has_divisor();
  inline void clear_has_divisor();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_price1isset();
  inline void clear_has_price1isset();
  inline void set_has_price2isset();
  inline void clear_has_price2isset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* serverorderid_;
  ::std::string* clientorderid_;
  ::google::protobuf::int64 price1_;
  ::google::protobuf::int64 price2_;
  ::google::protobuf::int64 quantity_;
  float divisor_;
  ::google::protobuf::uint32 price1isset_;
  ::google::protobuf::uint32 price2isset_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static CancelReplaceOrderInt* default_instance_;
};
// -------------------------------------------------------------------

class CancelOrder : public ::google::protobuf::Message {
 public:
  CancelOrder();
  virtual ~CancelOrder();

  CancelOrder(const CancelOrder& from);

  inline CancelOrder& operator=(const CancelOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelOrder& default_instance();

  void Swap(CancelOrder* other);

  // implements Message ----------------------------------------------

  CancelOrder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CancelOrder& from);
  void MergeFrom(const CancelOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ServerOrderID = 1;
  inline bool has_serverorderid() const;
  inline void clear_serverorderid();
  static const int kServerOrderIDFieldNumber = 1;
  inline const ::std::string& serverorderid() const;
  inline void set_serverorderid(const ::std::string& value);
  inline void set_serverorderid(const char* value);
  inline void set_serverorderid(const char* value, size_t size);
  inline ::std::string* mutable_serverorderid();
  inline ::std::string* release_serverorderid();
  inline void set_allocated_serverorderid(::std::string* serverorderid);

  // optional string ClientOrderID = 2;
  inline bool has_clientorderid() const;
  inline void clear_clientorderid();
  static const int kClientOrderIDFieldNumber = 2;
  inline const ::std::string& clientorderid() const;
  inline void set_clientorderid(const ::std::string& value);
  inline void set_clientorderid(const char* value);
  inline void set_clientorderid(const char* value, size_t size);
  inline ::std::string* mutable_clientorderid();
  inline ::std::string* release_clientorderid();
  inline void set_allocated_clientorderid(::std::string* clientorderid);

  // @@protoc_insertion_point(class_scope:DTC_PB.CancelOrder)
 private:
  inline void set_has_serverorderid();
  inline void clear_has_serverorderid();
  inline void set_has_clientorderid();
  inline void clear_has_clientorderid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* serverorderid_;
  ::std::string* clientorderid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static CancelOrder* default_instance_;
};
// -------------------------------------------------------------------

class SubmitNewOCOOrder : public ::google::protobuf::Message {
 public:
  SubmitNewOCOOrder();
  virtual ~SubmitNewOCOOrder();

  SubmitNewOCOOrder(const SubmitNewOCOOrder& from);

  inline SubmitNewOCOOrder& operator=(const SubmitNewOCOOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubmitNewOCOOrder& default_instance();

  void Swap(SubmitNewOCOOrder* other);

  // implements Message ----------------------------------------------

  SubmitNewOCOOrder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubmitNewOCOOrder& from);
  void MergeFrom(const SubmitNewOCOOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Symbol = 1;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 2;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 2;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // optional string ClientOrderID_1 = 3;
  inline bool has_clientorderid_1() const;
  inline void clear_clientorderid_1();
  static const int kClientOrderID1FieldNumber = 3;
  inline const ::std::string& clientorderid_1() const;
  inline void set_clientorderid_1(const ::std::string& value);
  inline void set_clientorderid_1(const char* value);
  inline void set_clientorderid_1(const char* value, size_t size);
  inline ::std::string* mutable_clientorderid_1();
  inline ::std::string* release_clientorderid_1();
  inline void set_allocated_clientorderid_1(::std::string* clientorderid_1);

  // optional .DTC_PB.OrderTypeEnum OrderType_1 = 4;
  inline bool has_ordertype_1() const;
  inline void clear_ordertype_1();
  static const int kOrderType1FieldNumber = 4;
  inline ::DTC_PB::OrderTypeEnum ordertype_1() const;
  inline void set_ordertype_1(::DTC_PB::OrderTypeEnum value);

  // optional .DTC_PB.BuySellEnum BuySell_1 = 5;
  inline bool has_buysell_1() const;
  inline void clear_buysell_1();
  static const int kBuySell1FieldNumber = 5;
  inline ::DTC_PB::BuySellEnum buysell_1() const;
  inline void set_buysell_1(::DTC_PB::BuySellEnum value);

  // optional double Price1_1 = 6;
  inline bool has_price1_1() const;
  inline void clear_price1_1();
  static const int kPrice11FieldNumber = 6;
  inline double price1_1() const;
  inline void set_price1_1(double value);

  // optional double Price2_1 = 7;
  inline bool has_price2_1() const;
  inline void clear_price2_1();
  static const int kPrice21FieldNumber = 7;
  inline double price2_1() const;
  inline void set_price2_1(double value);

  // optional double Quantity_1 = 8;
  inline bool has_quantity_1() const;
  inline void clear_quantity_1();
  static const int kQuantity1FieldNumber = 8;
  inline double quantity_1() const;
  inline void set_quantity_1(double value);

  // optional string ClientOrderID_2 = 9;
  inline bool has_clientorderid_2() const;
  inline void clear_clientorderid_2();
  static const int kClientOrderID2FieldNumber = 9;
  inline const ::std::string& clientorderid_2() const;
  inline void set_clientorderid_2(const ::std::string& value);
  inline void set_clientorderid_2(const char* value);
  inline void set_clientorderid_2(const char* value, size_t size);
  inline ::std::string* mutable_clientorderid_2();
  inline ::std::string* release_clientorderid_2();
  inline void set_allocated_clientorderid_2(::std::string* clientorderid_2);

  // optional .DTC_PB.OrderTypeEnum OrderType_2 = 10;
  inline bool has_ordertype_2() const;
  inline void clear_ordertype_2();
  static const int kOrderType2FieldNumber = 10;
  inline ::DTC_PB::OrderTypeEnum ordertype_2() const;
  inline void set_ordertype_2(::DTC_PB::OrderTypeEnum value);

  // optional .DTC_PB.BuySellEnum BuySell_2 = 11;
  inline bool has_buysell_2() const;
  inline void clear_buysell_2();
  static const int kBuySell2FieldNumber = 11;
  inline ::DTC_PB::BuySellEnum buysell_2() const;
  inline void set_buysell_2(::DTC_PB::BuySellEnum value);

  // optional double Price1_2 = 12;
  inline bool has_price1_2() const;
  inline void clear_price1_2();
  static const int kPrice12FieldNumber = 12;
  inline double price1_2() const;
  inline void set_price1_2(double value);

  // optional double Price2_2 = 13;
  inline bool has_price2_2() const;
  inline void clear_price2_2();
  static const int kPrice22FieldNumber = 13;
  inline double price2_2() const;
  inline void set_price2_2(double value);

  // optional double Quantity_2 = 14;
  inline bool has_quantity_2() const;
  inline void clear_quantity_2();
  static const int kQuantity2FieldNumber = 14;
  inline double quantity_2() const;
  inline void set_quantity_2(double value);

  // optional .DTC_PB.TimeInForceEnum TimeInForce = 15;
  inline bool has_timeinforce() const;
  inline void clear_timeinforce();
  static const int kTimeInForceFieldNumber = 15;
  inline ::DTC_PB::TimeInForceEnum timeinforce() const;
  inline void set_timeinforce(::DTC_PB::TimeInForceEnum value);

  // optional sfixed64 GoodTillDateTime = 16;
  inline bool has_goodtilldatetime() const;
  inline void clear_goodtilldatetime();
  static const int kGoodTillDateTimeFieldNumber = 16;
  inline ::google::protobuf::int64 goodtilldatetime() const;
  inline void set_goodtilldatetime(::google::protobuf::int64 value);

  // optional string TradeAccount = 17;
  inline bool has_tradeaccount() const;
  inline void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 17;
  inline const ::std::string& tradeaccount() const;
  inline void set_tradeaccount(const ::std::string& value);
  inline void set_tradeaccount(const char* value);
  inline void set_tradeaccount(const char* value, size_t size);
  inline ::std::string* mutable_tradeaccount();
  inline ::std::string* release_tradeaccount();
  inline void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional uint32 IsAutomatedOrder = 18;
  inline bool has_isautomatedorder() const;
  inline void clear_isautomatedorder();
  static const int kIsAutomatedOrderFieldNumber = 18;
  inline ::google::protobuf::uint32 isautomatedorder() const;
  inline void set_isautomatedorder(::google::protobuf::uint32 value);

  // optional string ParentTriggerClientOrderID = 19;
  inline bool has_parenttriggerclientorderid() const;
  inline void clear_parenttriggerclientorderid();
  static const int kParentTriggerClientOrderIDFieldNumber = 19;
  inline const ::std::string& parenttriggerclientorderid() const;
  inline void set_parenttriggerclientorderid(const ::std::string& value);
  inline void set_parenttriggerclientorderid(const char* value);
  inline void set_parenttriggerclientorderid(const char* value, size_t size);
  inline ::std::string* mutable_parenttriggerclientorderid();
  inline ::std::string* release_parenttriggerclientorderid();
  inline void set_allocated_parenttriggerclientorderid(::std::string* parenttriggerclientorderid);

  // optional string FreeFormText = 20;
  inline bool has_freeformtext() const;
  inline void clear_freeformtext();
  static const int kFreeFormTextFieldNumber = 20;
  inline const ::std::string& freeformtext() const;
  inline void set_freeformtext(const ::std::string& value);
  inline void set_freeformtext(const char* value);
  inline void set_freeformtext(const char* value, size_t size);
  inline ::std::string* mutable_freeformtext();
  inline ::std::string* release_freeformtext();
  inline void set_allocated_freeformtext(::std::string* freeformtext);

  // optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 21;
  inline bool has_openorclose() const;
  inline void clear_openorclose();
  static const int kOpenOrCloseFieldNumber = 21;
  inline ::DTC_PB::OpenCloseTradeEnum openorclose() const;
  inline void set_openorclose(::DTC_PB::OpenCloseTradeEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.SubmitNewOCOOrder)
 private:
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_exchange();
  inline void clear_has_exchange();
  inline void set_has_clientorderid_1();
  inline void clear_has_clientorderid_1();
  inline void set_has_ordertype_1();
  inline void clear_has_ordertype_1();
  inline void set_has_buysell_1();
  inline void clear_has_buysell_1();
  inline void set_has_price1_1();
  inline void clear_has_price1_1();
  inline void set_has_price2_1();
  inline void clear_has_price2_1();
  inline void set_has_quantity_1();
  inline void clear_has_quantity_1();
  inline void set_has_clientorderid_2();
  inline void clear_has_clientorderid_2();
  inline void set_has_ordertype_2();
  inline void clear_has_ordertype_2();
  inline void set_has_buysell_2();
  inline void clear_has_buysell_2();
  inline void set_has_price1_2();
  inline void clear_has_price1_2();
  inline void set_has_price2_2();
  inline void clear_has_price2_2();
  inline void set_has_quantity_2();
  inline void clear_has_quantity_2();
  inline void set_has_timeinforce();
  inline void clear_has_timeinforce();
  inline void set_has_goodtilldatetime();
  inline void clear_has_goodtilldatetime();
  inline void set_has_tradeaccount();
  inline void clear_has_tradeaccount();
  inline void set_has_isautomatedorder();
  inline void clear_has_isautomatedorder();
  inline void set_has_parenttriggerclientorderid();
  inline void clear_has_parenttriggerclientorderid();
  inline void set_has_freeformtext();
  inline void clear_has_freeformtext();
  inline void set_has_openorclose();
  inline void clear_has_openorclose();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* symbol_;
  ::std::string* exchange_;
  ::std::string* clientorderid_1_;
  int ordertype_1_;
  int buysell_1_;
  double price1_1_;
  double price2_1_;
  double quantity_1_;
  ::std::string* clientorderid_2_;
  int ordertype_2_;
  int buysell_2_;
  double price1_2_;
  double price2_2_;
  double quantity_2_;
  ::google::protobuf::int64 goodtilldatetime_;
  int timeinforce_;
  ::google::protobuf::uint32 isautomatedorder_;
  ::std::string* tradeaccount_;
  ::std::string* parenttriggerclientorderid_;
  ::std::string* freeformtext_;
  int openorclose_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static SubmitNewOCOOrder* default_instance_;
};
// -------------------------------------------------------------------

class SubmitNewOCOOrderInt : public ::google::protobuf::Message {
 public:
  SubmitNewOCOOrderInt();
  virtual ~SubmitNewOCOOrderInt();

  SubmitNewOCOOrderInt(const SubmitNewOCOOrderInt& from);

  inline SubmitNewOCOOrderInt& operator=(const SubmitNewOCOOrderInt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubmitNewOCOOrderInt& default_instance();

  void Swap(SubmitNewOCOOrderInt* other);

  // implements Message ----------------------------------------------

  SubmitNewOCOOrderInt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubmitNewOCOOrderInt& from);
  void MergeFrom(const SubmitNewOCOOrderInt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Symbol = 1;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 2;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 2;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // optional string ClientOrderID_1 = 3;
  inline bool has_clientorderid_1() const;
  inline void clear_clientorderid_1();
  static const int kClientOrderID1FieldNumber = 3;
  inline const ::std::string& clientorderid_1() const;
  inline void set_clientorderid_1(const ::std::string& value);
  inline void set_clientorderid_1(const char* value);
  inline void set_clientorderid_1(const char* value, size_t size);
  inline ::std::string* mutable_clientorderid_1();
  inline ::std::string* release_clientorderid_1();
  inline void set_allocated_clientorderid_1(::std::string* clientorderid_1);

  // optional .DTC_PB.OrderTypeEnum OrderType_1 = 4;
  inline bool has_ordertype_1() const;
  inline void clear_ordertype_1();
  static const int kOrderType1FieldNumber = 4;
  inline ::DTC_PB::OrderTypeEnum ordertype_1() const;
  inline void set_ordertype_1(::DTC_PB::OrderTypeEnum value);

  // optional .DTC_PB.BuySellEnum BuySell_1 = 5;
  inline bool has_buysell_1() const;
  inline void clear_buysell_1();
  static const int kBuySell1FieldNumber = 5;
  inline ::DTC_PB::BuySellEnum buysell_1() const;
  inline void set_buysell_1(::DTC_PB::BuySellEnum value);

  // optional int64 Price1_1 = 6;
  inline bool has_price1_1() const;
  inline void clear_price1_1();
  static const int kPrice11FieldNumber = 6;
  inline ::google::protobuf::int64 price1_1() const;
  inline void set_price1_1(::google::protobuf::int64 value);

  // optional int64 Price2_1 = 7;
  inline bool has_price2_1() const;
  inline void clear_price2_1();
  static const int kPrice21FieldNumber = 7;
  inline ::google::protobuf::int64 price2_1() const;
  inline void set_price2_1(::google::protobuf::int64 value);

  // optional int64 Quantity_1 = 8;
  inline bool has_quantity_1() const;
  inline void clear_quantity_1();
  static const int kQuantity1FieldNumber = 8;
  inline ::google::protobuf::int64 quantity_1() const;
  inline void set_quantity_1(::google::protobuf::int64 value);

  // optional string ClientOrderID_2 = 9;
  inline bool has_clientorderid_2() const;
  inline void clear_clientorderid_2();
  static const int kClientOrderID2FieldNumber = 9;
  inline const ::std::string& clientorderid_2() const;
  inline void set_clientorderid_2(const ::std::string& value);
  inline void set_clientorderid_2(const char* value);
  inline void set_clientorderid_2(const char* value, size_t size);
  inline ::std::string* mutable_clientorderid_2();
  inline ::std::string* release_clientorderid_2();
  inline void set_allocated_clientorderid_2(::std::string* clientorderid_2);

  // optional .DTC_PB.OrderTypeEnum OrderType_2 = 10;
  inline bool has_ordertype_2() const;
  inline void clear_ordertype_2();
  static const int kOrderType2FieldNumber = 10;
  inline ::DTC_PB::OrderTypeEnum ordertype_2() const;
  inline void set_ordertype_2(::DTC_PB::OrderTypeEnum value);

  // optional .DTC_PB.BuySellEnum BuySell_2 = 11;
  inline bool has_buysell_2() const;
  inline void clear_buysell_2();
  static const int kBuySell2FieldNumber = 11;
  inline ::DTC_PB::BuySellEnum buysell_2() const;
  inline void set_buysell_2(::DTC_PB::BuySellEnum value);

  // optional int64 Price1_2 = 12;
  inline bool has_price1_2() const;
  inline void clear_price1_2();
  static const int kPrice12FieldNumber = 12;
  inline ::google::protobuf::int64 price1_2() const;
  inline void set_price1_2(::google::protobuf::int64 value);

  // optional int64 Price2_2 = 13;
  inline bool has_price2_2() const;
  inline void clear_price2_2();
  static const int kPrice22FieldNumber = 13;
  inline ::google::protobuf::int64 price2_2() const;
  inline void set_price2_2(::google::protobuf::int64 value);

  // optional int64 Quantity_2 = 14;
  inline bool has_quantity_2() const;
  inline void clear_quantity_2();
  static const int kQuantity2FieldNumber = 14;
  inline ::google::protobuf::int64 quantity_2() const;
  inline void set_quantity_2(::google::protobuf::int64 value);

  // optional .DTC_PB.TimeInForceEnum TimeInForce = 15;
  inline bool has_timeinforce() const;
  inline void clear_timeinforce();
  static const int kTimeInForceFieldNumber = 15;
  inline ::DTC_PB::TimeInForceEnum timeinforce() const;
  inline void set_timeinforce(::DTC_PB::TimeInForceEnum value);

  // optional sfixed64 GoodTillDateTime = 16;
  inline bool has_goodtilldatetime() const;
  inline void clear_goodtilldatetime();
  static const int kGoodTillDateTimeFieldNumber = 16;
  inline ::google::protobuf::int64 goodtilldatetime() const;
  inline void set_goodtilldatetime(::google::protobuf::int64 value);

  // optional string TradeAccount = 17;
  inline bool has_tradeaccount() const;
  inline void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 17;
  inline const ::std::string& tradeaccount() const;
  inline void set_tradeaccount(const ::std::string& value);
  inline void set_tradeaccount(const char* value);
  inline void set_tradeaccount(const char* value, size_t size);
  inline ::std::string* mutable_tradeaccount();
  inline ::std::string* release_tradeaccount();
  inline void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional uint32 IsAutomatedOrder = 18;
  inline bool has_isautomatedorder() const;
  inline void clear_isautomatedorder();
  static const int kIsAutomatedOrderFieldNumber = 18;
  inline ::google::protobuf::uint32 isautomatedorder() const;
  inline void set_isautomatedorder(::google::protobuf::uint32 value);

  // optional string ParentTriggerClientOrderID = 19;
  inline bool has_parenttriggerclientorderid() const;
  inline void clear_parenttriggerclientorderid();
  static const int kParentTriggerClientOrderIDFieldNumber = 19;
  inline const ::std::string& parenttriggerclientorderid() const;
  inline void set_parenttriggerclientorderid(const ::std::string& value);
  inline void set_parenttriggerclientorderid(const char* value);
  inline void set_parenttriggerclientorderid(const char* value, size_t size);
  inline ::std::string* mutable_parenttriggerclientorderid();
  inline ::std::string* release_parenttriggerclientorderid();
  inline void set_allocated_parenttriggerclientorderid(::std::string* parenttriggerclientorderid);

  // optional string FreeFormText = 20;
  inline bool has_freeformtext() const;
  inline void clear_freeformtext();
  static const int kFreeFormTextFieldNumber = 20;
  inline const ::std::string& freeformtext() const;
  inline void set_freeformtext(const ::std::string& value);
  inline void set_freeformtext(const char* value);
  inline void set_freeformtext(const char* value, size_t size);
  inline ::std::string* mutable_freeformtext();
  inline ::std::string* release_freeformtext();
  inline void set_allocated_freeformtext(::std::string* freeformtext);

  // optional float Divisor = 21;
  inline bool has_divisor() const;
  inline void clear_divisor();
  static const int kDivisorFieldNumber = 21;
  inline float divisor() const;
  inline void set_divisor(float value);

  // optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 22;
  inline bool has_openorclose() const;
  inline void clear_openorclose();
  static const int kOpenOrCloseFieldNumber = 22;
  inline ::DTC_PB::OpenCloseTradeEnum openorclose() const;
  inline void set_openorclose(::DTC_PB::OpenCloseTradeEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.SubmitNewOCOOrderInt)
 private:
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_exchange();
  inline void clear_has_exchange();
  inline void set_has_clientorderid_1();
  inline void clear_has_clientorderid_1();
  inline void set_has_ordertype_1();
  inline void clear_has_ordertype_1();
  inline void set_has_buysell_1();
  inline void clear_has_buysell_1();
  inline void set_has_price1_1();
  inline void clear_has_price1_1();
  inline void set_has_price2_1();
  inline void clear_has_price2_1();
  inline void set_has_quantity_1();
  inline void clear_has_quantity_1();
  inline void set_has_clientorderid_2();
  inline void clear_has_clientorderid_2();
  inline void set_has_ordertype_2();
  inline void clear_has_ordertype_2();
  inline void set_has_buysell_2();
  inline void clear_has_buysell_2();
  inline void set_has_price1_2();
  inline void clear_has_price1_2();
  inline void set_has_price2_2();
  inline void clear_has_price2_2();
  inline void set_has_quantity_2();
  inline void clear_has_quantity_2();
  inline void set_has_timeinforce();
  inline void clear_has_timeinforce();
  inline void set_has_goodtilldatetime();
  inline void clear_has_goodtilldatetime();
  inline void set_has_tradeaccount();
  inline void clear_has_tradeaccount();
  inline void set_has_isautomatedorder();
  inline void clear_has_isautomatedorder();
  inline void set_has_parenttriggerclientorderid();
  inline void clear_has_parenttriggerclientorderid();
  inline void set_has_freeformtext();
  inline void clear_has_freeformtext();
  inline void set_has_divisor();
  inline void clear_has_divisor();
  inline void set_has_openorclose();
  inline void clear_has_openorclose();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* symbol_;
  ::std::string* exchange_;
  ::std::string* clientorderid_1_;
  int ordertype_1_;
  int buysell_1_;
  ::google::protobuf::int64 price1_1_;
  ::google::protobuf::int64 price2_1_;
  ::google::protobuf::int64 quantity_1_;
  ::std::string* clientorderid_2_;
  int ordertype_2_;
  int buysell_2_;
  ::google::protobuf::int64 price1_2_;
  ::google::protobuf::int64 price2_2_;
  ::google::protobuf::int64 quantity_2_;
  ::google::protobuf::int64 goodtilldatetime_;
  int timeinforce_;
  ::google::protobuf::uint32 isautomatedorder_;
  ::std::string* tradeaccount_;
  ::std::string* parenttriggerclientorderid_;
  ::std::string* freeformtext_;
  float divisor_;
  int openorclose_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static SubmitNewOCOOrderInt* default_instance_;
};
// -------------------------------------------------------------------

class OpenOrdersRequest : public ::google::protobuf::Message {
 public:
  OpenOrdersRequest();
  virtual ~OpenOrdersRequest();

  OpenOrdersRequest(const OpenOrdersRequest& from);

  inline OpenOrdersRequest& operator=(const OpenOrdersRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenOrdersRequest& default_instance();

  void Swap(OpenOrdersRequest* other);

  // implements Message ----------------------------------------------

  OpenOrdersRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenOrdersRequest& from);
  void MergeFrom(const OpenOrdersRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional int32 RequestAllOrders = 2;
  inline bool has_requestallorders() const;
  inline void clear_requestallorders();
  static const int kRequestAllOrdersFieldNumber = 2;
  inline ::google::protobuf::int32 requestallorders() const;
  inline void set_requestallorders(::google::protobuf::int32 value);

  // optional string ServerOrderID = 3;
  inline bool has_serverorderid() const;
  inline void clear_serverorderid();
  static const int kServerOrderIDFieldNumber = 3;
  inline const ::std::string& serverorderid() const;
  inline void set_serverorderid(const ::std::string& value);
  inline void set_serverorderid(const char* value);
  inline void set_serverorderid(const char* value, size_t size);
  inline ::std::string* mutable_serverorderid();
  inline ::std::string* release_serverorderid();
  inline void set_allocated_serverorderid(::std::string* serverorderid);

  // @@protoc_insertion_point(class_scope:DTC_PB.OpenOrdersRequest)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_requestallorders();
  inline void clear_has_requestallorders();
  inline void set_has_serverorderid();
  inline void clear_has_serverorderid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 requestallorders_;
  ::std::string* serverorderid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static OpenOrdersRequest* default_instance_;
};
// -------------------------------------------------------------------

class HistoricalOrderFillsRequest : public ::google::protobuf::Message {
 public:
  HistoricalOrderFillsRequest();
  virtual ~HistoricalOrderFillsRequest();

  HistoricalOrderFillsRequest(const HistoricalOrderFillsRequest& from);

  inline HistoricalOrderFillsRequest& operator=(const HistoricalOrderFillsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalOrderFillsRequest& default_instance();

  void Swap(HistoricalOrderFillsRequest* other);

  // implements Message ----------------------------------------------

  HistoricalOrderFillsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoricalOrderFillsRequest& from);
  void MergeFrom(const HistoricalOrderFillsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string ServerOrderID = 2;
  inline bool has_serverorderid() const;
  inline void clear_serverorderid();
  static const int kServerOrderIDFieldNumber = 2;
  inline const ::std::string& serverorderid() const;
  inline void set_serverorderid(const ::std::string& value);
  inline void set_serverorderid(const char* value);
  inline void set_serverorderid(const char* value, size_t size);
  inline ::std::string* mutable_serverorderid();
  inline ::std::string* release_serverorderid();
  inline void set_allocated_serverorderid(::std::string* serverorderid);

  // optional int32 NumberOfDays = 3;
  inline bool has_numberofdays() const;
  inline void clear_numberofdays();
  static const int kNumberOfDaysFieldNumber = 3;
  inline ::google::protobuf::int32 numberofdays() const;
  inline void set_numberofdays(::google::protobuf::int32 value);

  // optional string TradeAccount = 4;
  inline bool has_tradeaccount() const;
  inline void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 4;
  inline const ::std::string& tradeaccount() const;
  inline void set_tradeaccount(const ::std::string& value);
  inline void set_tradeaccount(const char* value);
  inline void set_tradeaccount(const char* value, size_t size);
  inline ::std::string* mutable_tradeaccount();
  inline ::std::string* release_tradeaccount();
  inline void set_allocated_tradeaccount(::std::string* tradeaccount);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalOrderFillsRequest)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_serverorderid();
  inline void clear_has_serverorderid();
  inline void set_has_numberofdays();
  inline void clear_has_numberofdays();
  inline void set_has_tradeaccount();
  inline void clear_has_tradeaccount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* serverorderid_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 numberofdays_;
  ::std::string* tradeaccount_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static HistoricalOrderFillsRequest* default_instance_;
};
// -------------------------------------------------------------------

class HistoricalOrderFillsReject : public ::google::protobuf::Message {
 public:
  HistoricalOrderFillsReject();
  virtual ~HistoricalOrderFillsReject();

  HistoricalOrderFillsReject(const HistoricalOrderFillsReject& from);

  inline HistoricalOrderFillsReject& operator=(const HistoricalOrderFillsReject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalOrderFillsReject& default_instance();

  void Swap(HistoricalOrderFillsReject* other);

  // implements Message ----------------------------------------------

  HistoricalOrderFillsReject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoricalOrderFillsReject& from);
  void MergeFrom(const HistoricalOrderFillsReject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string RejectText = 2;
  inline bool has_rejecttext() const;
  inline void clear_rejecttext();
  static const int kRejectTextFieldNumber = 2;
  inline const ::std::string& rejecttext() const;
  inline void set_rejecttext(const ::std::string& value);
  inline void set_rejecttext(const char* value);
  inline void set_rejecttext(const char* value, size_t size);
  inline ::std::string* mutable_rejecttext();
  inline ::std::string* release_rejecttext();
  inline void set_allocated_rejecttext(::std::string* rejecttext);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalOrderFillsReject)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_rejecttext();
  inline void clear_has_rejecttext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* rejecttext_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static HistoricalOrderFillsReject* default_instance_;
};
// -------------------------------------------------------------------

class CurrentPositionsRequest : public ::google::protobuf::Message {
 public:
  CurrentPositionsRequest();
  virtual ~CurrentPositionsRequest();

  CurrentPositionsRequest(const CurrentPositionsRequest& from);

  inline CurrentPositionsRequest& operator=(const CurrentPositionsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurrentPositionsRequest& default_instance();

  void Swap(CurrentPositionsRequest* other);

  // implements Message ----------------------------------------------

  CurrentPositionsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CurrentPositionsRequest& from);
  void MergeFrom(const CurrentPositionsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string TradeAccount = 2;
  inline bool has_tradeaccount() const;
  inline void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 2;
  inline const ::std::string& tradeaccount() const;
  inline void set_tradeaccount(const ::std::string& value);
  inline void set_tradeaccount(const char* value);
  inline void set_tradeaccount(const char* value, size_t size);
  inline ::std::string* mutable_tradeaccount();
  inline ::std::string* release_tradeaccount();
  inline void set_allocated_tradeaccount(::std::string* tradeaccount);

  // @@protoc_insertion_point(class_scope:DTC_PB.CurrentPositionsRequest)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_tradeaccount();
  inline void clear_has_tradeaccount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* tradeaccount_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static CurrentPositionsRequest* default_instance_;
};
// -------------------------------------------------------------------

class CurrentPositionsReject : public ::google::protobuf::Message {
 public:
  CurrentPositionsReject();
  virtual ~CurrentPositionsReject();

  CurrentPositionsReject(const CurrentPositionsReject& from);

  inline CurrentPositionsReject& operator=(const CurrentPositionsReject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurrentPositionsReject& default_instance();

  void Swap(CurrentPositionsReject* other);

  // implements Message ----------------------------------------------

  CurrentPositionsReject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CurrentPositionsReject& from);
  void MergeFrom(const CurrentPositionsReject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string RejectText = 2;
  inline bool has_rejecttext() const;
  inline void clear_rejecttext();
  static const int kRejectTextFieldNumber = 2;
  inline const ::std::string& rejecttext() const;
  inline void set_rejecttext(const ::std::string& value);
  inline void set_rejecttext(const char* value);
  inline void set_rejecttext(const char* value, size_t size);
  inline ::std::string* mutable_rejecttext();
  inline ::std::string* release_rejecttext();
  inline void set_allocated_rejecttext(::std::string* rejecttext);

  // @@protoc_insertion_point(class_scope:DTC_PB.CurrentPositionsReject)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_rejecttext();
  inline void clear_has_rejecttext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* rejecttext_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static CurrentPositionsReject* default_instance_;
};
// -------------------------------------------------------------------

class OrderUpdate : public ::google::protobuf::Message {
 public:
  OrderUpdate();
  virtual ~OrderUpdate();

  OrderUpdate(const OrderUpdate& from);

  inline OrderUpdate& operator=(const OrderUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderUpdate& default_instance();

  void Swap(OrderUpdate* other);

  // implements Message ----------------------------------------------

  OrderUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderUpdate& from);
  void MergeFrom(const OrderUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional int32 TotalNumMessages = 2;
  inline bool has_totalnummessages() const;
  inline void clear_totalnummessages();
  static const int kTotalNumMessagesFieldNumber = 2;
  inline ::google::protobuf::int32 totalnummessages() const;
  inline void set_totalnummessages(::google::protobuf::int32 value);

  // optional int32 MessageNumber = 3;
  inline bool has_messagenumber() const;
  inline void clear_messagenumber();
  static const int kMessageNumberFieldNumber = 3;
  inline ::google::protobuf::int32 messagenumber() const;
  inline void set_messagenumber(::google::protobuf::int32 value);

  // optional string Symbol = 4;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 4;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 5;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 5;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // optional string PreviousServerOrderID = 6;
  inline bool has_previousserverorderid() const;
  inline void clear_previousserverorderid();
  static const int kPreviousServerOrderIDFieldNumber = 6;
  inline const ::std::string& previousserverorderid() const;
  inline void set_previousserverorderid(const ::std::string& value);
  inline void set_previousserverorderid(const char* value);
  inline void set_previousserverorderid(const char* value, size_t size);
  inline ::std::string* mutable_previousserverorderid();
  inline ::std::string* release_previousserverorderid();
  inline void set_allocated_previousserverorderid(::std::string* previousserverorderid);

  // optional string ServerOrderID = 7;
  inline bool has_serverorderid() const;
  inline void clear_serverorderid();
  static const int kServerOrderIDFieldNumber = 7;
  inline const ::std::string& serverorderid() const;
  inline void set_serverorderid(const ::std::string& value);
  inline void set_serverorderid(const char* value);
  inline void set_serverorderid(const char* value, size_t size);
  inline ::std::string* mutable_serverorderid();
  inline ::std::string* release_serverorderid();
  inline void set_allocated_serverorderid(::std::string* serverorderid);

  // optional string ClientOrderID = 8;
  inline bool has_clientorderid() const;
  inline void clear_clientorderid();
  static const int kClientOrderIDFieldNumber = 8;
  inline const ::std::string& clientorderid() const;
  inline void set_clientorderid(const ::std::string& value);
  inline void set_clientorderid(const char* value);
  inline void set_clientorderid(const char* value, size_t size);
  inline ::std::string* mutable_clientorderid();
  inline ::std::string* release_clientorderid();
  inline void set_allocated_clientorderid(::std::string* clientorderid);

  // optional string ExchangeOrderID = 9;
  inline bool has_exchangeorderid() const;
  inline void clear_exchangeorderid();
  static const int kExchangeOrderIDFieldNumber = 9;
  inline const ::std::string& exchangeorderid() const;
  inline void set_exchangeorderid(const ::std::string& value);
  inline void set_exchangeorderid(const char* value);
  inline void set_exchangeorderid(const char* value, size_t size);
  inline ::std::string* mutable_exchangeorderid();
  inline ::std::string* release_exchangeorderid();
  inline void set_allocated_exchangeorderid(::std::string* exchangeorderid);

  // optional .DTC_PB.OrderStatusEnum OrderStatus = 10;
  inline bool has_orderstatus() const;
  inline void clear_orderstatus();
  static const int kOrderStatusFieldNumber = 10;
  inline ::DTC_PB::OrderStatusEnum orderstatus() const;
  inline void set_orderstatus(::DTC_PB::OrderStatusEnum value);

  // optional .DTC_PB.OrderUpdateReasonEnum OrderUpdateReason = 11;
  inline bool has_orderupdatereason() const;
  inline void clear_orderupdatereason();
  static const int kOrderUpdateReasonFieldNumber = 11;
  inline ::DTC_PB::OrderUpdateReasonEnum orderupdatereason() const;
  inline void set_orderupdatereason(::DTC_PB::OrderUpdateReasonEnum value);

  // optional .DTC_PB.OrderTypeEnum OrderType = 12;
  inline bool has_ordertype() const;
  inline void clear_ordertype();
  static const int kOrderTypeFieldNumber = 12;
  inline ::DTC_PB::OrderTypeEnum ordertype() const;
  inline void set_ordertype(::DTC_PB::OrderTypeEnum value);

  // optional .DTC_PB.BuySellEnum BuySell = 13;
  inline bool has_buysell() const;
  inline void clear_buysell();
  static const int kBuySellFieldNumber = 13;
  inline ::DTC_PB::BuySellEnum buysell() const;
  inline void set_buysell(::DTC_PB::BuySellEnum value);

  // optional double Price1 = 14;
  inline bool has_price1() const;
  inline void clear_price1();
  static const int kPrice1FieldNumber = 14;
  inline double price1() const;
  inline void set_price1(double value);

  // optional double Price2 = 15;
  inline bool has_price2() const;
  inline void clear_price2();
  static const int kPrice2FieldNumber = 15;
  inline double price2() const;
  inline void set_price2(double value);

  // optional .DTC_PB.TimeInForceEnum TimeInForce = 16;
  inline bool has_timeinforce() const;
  inline void clear_timeinforce();
  static const int kTimeInForceFieldNumber = 16;
  inline ::DTC_PB::TimeInForceEnum timeinforce() const;
  inline void set_timeinforce(::DTC_PB::TimeInForceEnum value);

  // optional sfixed64 GoodTillDateTime = 17;
  inline bool has_goodtilldatetime() const;
  inline void clear_goodtilldatetime();
  static const int kGoodTillDateTimeFieldNumber = 17;
  inline ::google::protobuf::int64 goodtilldatetime() const;
  inline void set_goodtilldatetime(::google::protobuf::int64 value);

  // optional double OrderQuantity = 18;
  inline bool has_orderquantity() const;
  inline void clear_orderquantity();
  static const int kOrderQuantityFieldNumber = 18;
  inline double orderquantity() const;
  inline void set_orderquantity(double value);

  // optional double FilledQuantity = 19;
  inline bool has_filledquantity() const;
  inline void clear_filledquantity();
  static const int kFilledQuantityFieldNumber = 19;
  inline double filledquantity() const;
  inline void set_filledquantity(double value);

  // optional double RemainingQuantity = 20;
  inline bool has_remainingquantity() const;
  inline void clear_remainingquantity();
  static const int kRemainingQuantityFieldNumber = 20;
  inline double remainingquantity() const;
  inline void set_remainingquantity(double value);

  // optional double AverageFillPrice = 21;
  inline bool has_averagefillprice() const;
  inline void clear_averagefillprice();
  static const int kAverageFillPriceFieldNumber = 21;
  inline double averagefillprice() const;
  inline void set_averagefillprice(double value);

  // optional double LastFillPrice = 22;
  inline bool has_lastfillprice() const;
  inline void clear_lastfillprice();
  static const int kLastFillPriceFieldNumber = 22;
  inline double lastfillprice() const;
  inline void set_lastfillprice(double value);

  // optional sfixed64 LastFillDateTime = 23;
  inline bool has_lastfilldatetime() const;
  inline void clear_lastfilldatetime();
  static const int kLastFillDateTimeFieldNumber = 23;
  inline ::google::protobuf::int64 lastfilldatetime() const;
  inline void set_lastfilldatetime(::google::protobuf::int64 value);

  // optional double LastFillQuantity = 24;
  inline bool has_lastfillquantity() const;
  inline void clear_lastfillquantity();
  static const int kLastFillQuantityFieldNumber = 24;
  inline double lastfillquantity() const;
  inline void set_lastfillquantity(double value);

  // optional string LastFillExecutionID = 25;
  inline bool has_lastfillexecutionid() const;
  inline void clear_lastfillexecutionid();
  static const int kLastFillExecutionIDFieldNumber = 25;
  inline const ::std::string& lastfillexecutionid() const;
  inline void set_lastfillexecutionid(const ::std::string& value);
  inline void set_lastfillexecutionid(const char* value);
  inline void set_lastfillexecutionid(const char* value, size_t size);
  inline ::std::string* mutable_lastfillexecutionid();
  inline ::std::string* release_lastfillexecutionid();
  inline void set_allocated_lastfillexecutionid(::std::string* lastfillexecutionid);

  // optional string TradeAccount = 26;
  inline bool has_tradeaccount() const;
  inline void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 26;
  inline const ::std::string& tradeaccount() const;
  inline void set_tradeaccount(const ::std::string& value);
  inline void set_tradeaccount(const char* value);
  inline void set_tradeaccount(const char* value, size_t size);
  inline ::std::string* mutable_tradeaccount();
  inline ::std::string* release_tradeaccount();
  inline void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional string InfoText = 27;
  inline bool has_infotext() const;
  inline void clear_infotext();
  static const int kInfoTextFieldNumber = 27;
  inline const ::std::string& infotext() const;
  inline void set_infotext(const ::std::string& value);
  inline void set_infotext(const char* value);
  inline void set_infotext(const char* value, size_t size);
  inline ::std::string* mutable_infotext();
  inline ::std::string* release_infotext();
  inline void set_allocated_infotext(::std::string* infotext);

  // optional uint32 NoOrders = 28;
  inline bool has_noorders() const;
  inline void clear_noorders();
  static const int kNoOrdersFieldNumber = 28;
  inline ::google::protobuf::uint32 noorders() const;
  inline void set_noorders(::google::protobuf::uint32 value);

  // optional string ParentServerOrderID = 29;
  inline bool has_parentserverorderid() const;
  inline void clear_parentserverorderid();
  static const int kParentServerOrderIDFieldNumber = 29;
  inline const ::std::string& parentserverorderid() const;
  inline void set_parentserverorderid(const ::std::string& value);
  inline void set_parentserverorderid(const char* value);
  inline void set_parentserverorderid(const char* value, size_t size);
  inline ::std::string* mutable_parentserverorderid();
  inline ::std::string* release_parentserverorderid();
  inline void set_allocated_parentserverorderid(::std::string* parentserverorderid);

  // optional string OCOLinkedOrderServerOrderID = 30;
  inline bool has_ocolinkedorderserverorderid() const;
  inline void clear_ocolinkedorderserverorderid();
  static const int kOCOLinkedOrderServerOrderIDFieldNumber = 30;
  inline const ::std::string& ocolinkedorderserverorderid() const;
  inline void set_ocolinkedorderserverorderid(const ::std::string& value);
  inline void set_ocolinkedorderserverorderid(const char* value);
  inline void set_ocolinkedorderserverorderid(const char* value, size_t size);
  inline ::std::string* mutable_ocolinkedorderserverorderid();
  inline ::std::string* release_ocolinkedorderserverorderid();
  inline void set_allocated_ocolinkedorderserverorderid(::std::string* ocolinkedorderserverorderid);

  // optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 31;
  inline bool has_openorclose() const;
  inline void clear_openorclose();
  static const int kOpenOrCloseFieldNumber = 31;
  inline ::DTC_PB::OpenCloseTradeEnum openorclose() const;
  inline void set_openorclose(::DTC_PB::OpenCloseTradeEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.OrderUpdate)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_totalnummessages();
  inline void clear_has_totalnummessages();
  inline void set_has_messagenumber();
  inline void clear_has_messagenumber();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_exchange();
  inline void clear_has_exchange();
  inline void set_has_previousserverorderid();
  inline void clear_has_previousserverorderid();
  inline void set_has_serverorderid();
  inline void clear_has_serverorderid();
  inline void set_has_clientorderid();
  inline void clear_has_clientorderid();
  inline void set_has_exchangeorderid();
  inline void clear_has_exchangeorderid();
  inline void set_has_orderstatus();
  inline void clear_has_orderstatus();
  inline void set_has_orderupdatereason();
  inline void clear_has_orderupdatereason();
  inline void set_has_ordertype();
  inline void clear_has_ordertype();
  inline void set_has_buysell();
  inline void clear_has_buysell();
  inline void set_has_price1();
  inline void clear_has_price1();
  inline void set_has_price2();
  inline void clear_has_price2();
  inline void set_has_timeinforce();
  inline void clear_has_timeinforce();
  inline void set_has_goodtilldatetime();
  inline void clear_has_goodtilldatetime();
  inline void set_has_orderquantity();
  inline void clear_has_orderquantity();
  inline void set_has_filledquantity();
  inline void clear_has_filledquantity();
  inline void set_has_remainingquantity();
  inline void clear_has_remainingquantity();
  inline void set_has_averagefillprice();
  inline void clear_has_averagefillprice();
  inline void set_has_lastfillprice();
  inline void clear_has_lastfillprice();
  inline void set_has_lastfilldatetime();
  inline void clear_has_lastfilldatetime();
  inline void set_has_lastfillquantity();
  inline void clear_has_lastfillquantity();
  inline void set_has_lastfillexecutionid();
  inline void clear_has_lastfillexecutionid();
  inline void set_has_tradeaccount();
  inline void clear_has_tradeaccount();
  inline void set_has_infotext();
  inline void clear_has_infotext();
  inline void set_has_noorders();
  inline void clear_has_noorders();
  inline void set_has_parentserverorderid();
  inline void clear_has_parentserverorderid();
  inline void set_has_ocolinkedorderserverorderid();
  inline void clear_has_ocolinkedorderserverorderid();
  inline void set_has_openorclose();
  inline void clear_has_openorclose();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 totalnummessages_;
  ::std::string* symbol_;
  ::std::string* exchange_;
  ::std::string* previousserverorderid_;
  ::google::protobuf::int32 messagenumber_;
  int orderstatus_;
  ::std::string* serverorderid_;
  ::std::string* clientorderid_;
  ::std::string* exchangeorderid_;
  int orderupdatereason_;
  int ordertype_;
  double price1_;
  int buysell_;
  int timeinforce_;
  double price2_;
  ::google::protobuf::int64 goodtilldatetime_;
  double orderquantity_;
  double filledquantity_;
  double remainingquantity_;
  double averagefillprice_;
  double lastfillprice_;
  ::google::protobuf::int64 lastfilldatetime_;
  double lastfillquantity_;
  ::std::string* lastfillexecutionid_;
  ::std::string* tradeaccount_;
  ::std::string* infotext_;
  ::std::string* parentserverorderid_;
  ::google::protobuf::uint32 noorders_;
  int openorclose_;
  ::std::string* ocolinkedorderserverorderid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static OrderUpdate* default_instance_;
};
// -------------------------------------------------------------------

class OpenOrdersReject : public ::google::protobuf::Message {
 public:
  OpenOrdersReject();
  virtual ~OpenOrdersReject();

  OpenOrdersReject(const OpenOrdersReject& from);

  inline OpenOrdersReject& operator=(const OpenOrdersReject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenOrdersReject& default_instance();

  void Swap(OpenOrdersReject* other);

  // implements Message ----------------------------------------------

  OpenOrdersReject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenOrdersReject& from);
  void MergeFrom(const OpenOrdersReject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string RejectText = 2;
  inline bool has_rejecttext() const;
  inline void clear_rejecttext();
  static const int kRejectTextFieldNumber = 2;
  inline const ::std::string& rejecttext() const;
  inline void set_rejecttext(const ::std::string& value);
  inline void set_rejecttext(const char* value);
  inline void set_rejecttext(const char* value, size_t size);
  inline ::std::string* mutable_rejecttext();
  inline ::std::string* release_rejecttext();
  inline void set_allocated_rejecttext(::std::string* rejecttext);

  // @@protoc_insertion_point(class_scope:DTC_PB.OpenOrdersReject)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_rejecttext();
  inline void clear_has_rejecttext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* rejecttext_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static OpenOrdersReject* default_instance_;
};
// -------------------------------------------------------------------

class HistoricalOrderFillResponse : public ::google::protobuf::Message {
 public:
  HistoricalOrderFillResponse();
  virtual ~HistoricalOrderFillResponse();

  HistoricalOrderFillResponse(const HistoricalOrderFillResponse& from);

  inline HistoricalOrderFillResponse& operator=(const HistoricalOrderFillResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalOrderFillResponse& default_instance();

  void Swap(HistoricalOrderFillResponse* other);

  // implements Message ----------------------------------------------

  HistoricalOrderFillResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoricalOrderFillResponse& from);
  void MergeFrom(const HistoricalOrderFillResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional int32 TotalNumberMessages = 2;
  inline bool has_totalnumbermessages() const;
  inline void clear_totalnumbermessages();
  static const int kTotalNumberMessagesFieldNumber = 2;
  inline ::google::protobuf::int32 totalnumbermessages() const;
  inline void set_totalnumbermessages(::google::protobuf::int32 value);

  // optional int32 MessageNumber = 3;
  inline bool has_messagenumber() const;
  inline void clear_messagenumber();
  static const int kMessageNumberFieldNumber = 3;
  inline ::google::protobuf::int32 messagenumber() const;
  inline void set_messagenumber(::google::protobuf::int32 value);

  // optional string Symbol = 4;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 4;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 5;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 5;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // optional string ServerOrderID = 6;
  inline bool has_serverorderid() const;
  inline void clear_serverorderid();
  static const int kServerOrderIDFieldNumber = 6;
  inline const ::std::string& serverorderid() const;
  inline void set_serverorderid(const ::std::string& value);
  inline void set_serverorderid(const char* value);
  inline void set_serverorderid(const char* value, size_t size);
  inline ::std::string* mutable_serverorderid();
  inline ::std::string* release_serverorderid();
  inline void set_allocated_serverorderid(::std::string* serverorderid);

  // optional .DTC_PB.BuySellEnum BuySell = 7;
  inline bool has_buysell() const;
  inline void clear_buysell();
  static const int kBuySellFieldNumber = 7;
  inline ::DTC_PB::BuySellEnum buysell() const;
  inline void set_buysell(::DTC_PB::BuySellEnum value);

  // optional double Price = 8;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 8;
  inline double price() const;
  inline void set_price(double value);

  // optional sfixed64 DateTime = 9;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDateTimeFieldNumber = 9;
  inline ::google::protobuf::int64 datetime() const;
  inline void set_datetime(::google::protobuf::int64 value);

  // optional double Quantity = 10;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 10;
  inline double quantity() const;
  inline void set_quantity(double value);

  // optional string UniqueExecutionID = 11;
  inline bool has_uniqueexecutionid() const;
  inline void clear_uniqueexecutionid();
  static const int kUniqueExecutionIDFieldNumber = 11;
  inline const ::std::string& uniqueexecutionid() const;
  inline void set_uniqueexecutionid(const ::std::string& value);
  inline void set_uniqueexecutionid(const char* value);
  inline void set_uniqueexecutionid(const char* value, size_t size);
  inline ::std::string* mutable_uniqueexecutionid();
  inline ::std::string* release_uniqueexecutionid();
  inline void set_allocated_uniqueexecutionid(::std::string* uniqueexecutionid);

  // optional string TradeAccount = 12;
  inline bool has_tradeaccount() const;
  inline void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 12;
  inline const ::std::string& tradeaccount() const;
  inline void set_tradeaccount(const ::std::string& value);
  inline void set_tradeaccount(const char* value);
  inline void set_tradeaccount(const char* value, size_t size);
  inline ::std::string* mutable_tradeaccount();
  inline ::std::string* release_tradeaccount();
  inline void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional .DTC_PB.OpenCloseTradeEnum OpenClose = 13;
  inline bool has_openclose() const;
  inline void clear_openclose();
  static const int kOpenCloseFieldNumber = 13;
  inline ::DTC_PB::OpenCloseTradeEnum openclose() const;
  inline void set_openclose(::DTC_PB::OpenCloseTradeEnum value);

  // optional uint32 NoOrderFills = 14;
  inline bool has_noorderfills() const;
  inline void clear_noorderfills();
  static const int kNoOrderFillsFieldNumber = 14;
  inline ::google::protobuf::uint32 noorderfills() const;
  inline void set_noorderfills(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalOrderFillResponse)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_totalnumbermessages();
  inline void clear_has_totalnumbermessages();
  inline void set_has_messagenumber();
  inline void clear_has_messagenumber();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_exchange();
  inline void clear_has_exchange();
  inline void set_has_serverorderid();
  inline void clear_has_serverorderid();
  inline void set_has_buysell();
  inline void clear_has_buysell();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_datetime();
  inline void clear_has_datetime();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_uniqueexecutionid();
  inline void clear_has_uniqueexecutionid();
  inline void set_has_tradeaccount();
  inline void clear_has_tradeaccount();
  inline void set_has_openclose();
  inline void clear_has_openclose();
  inline void set_has_noorderfills();
  inline void clear_has_noorderfills();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 totalnumbermessages_;
  ::std::string* symbol_;
  ::std::string* exchange_;
  ::google::protobuf::int32 messagenumber_;
  int buysell_;
  ::std::string* serverorderid_;
  double price_;
  ::google::protobuf::int64 datetime_;
  double quantity_;
  ::std::string* uniqueexecutionid_;
  ::std::string* tradeaccount_;
  int openclose_;
  ::google::protobuf::uint32 noorderfills_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static HistoricalOrderFillResponse* default_instance_;
};
// -------------------------------------------------------------------

class PositionUpdate : public ::google::protobuf::Message {
 public:
  PositionUpdate();
  virtual ~PositionUpdate();

  PositionUpdate(const PositionUpdate& from);

  inline PositionUpdate& operator=(const PositionUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PositionUpdate& default_instance();

  void Swap(PositionUpdate* other);

  // implements Message ----------------------------------------------

  PositionUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PositionUpdate& from);
  void MergeFrom(const PositionUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional int32 TotalNumberMessages = 2;
  inline bool has_totalnumbermessages() const;
  inline void clear_totalnumbermessages();
  static const int kTotalNumberMessagesFieldNumber = 2;
  inline ::google::protobuf::int32 totalnumbermessages() const;
  inline void set_totalnumbermessages(::google::protobuf::int32 value);

  // optional int32 MessageNumber = 3;
  inline bool has_messagenumber() const;
  inline void clear_messagenumber();
  static const int kMessageNumberFieldNumber = 3;
  inline ::google::protobuf::int32 messagenumber() const;
  inline void set_messagenumber(::google::protobuf::int32 value);

  // optional string Symbol = 4;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 4;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 5;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 5;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // optional double Quantity = 6;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 6;
  inline double quantity() const;
  inline void set_quantity(double value);

  // optional double AveragePrice = 7;
  inline bool has_averageprice() const;
  inline void clear_averageprice();
  static const int kAveragePriceFieldNumber = 7;
  inline double averageprice() const;
  inline void set_averageprice(double value);

  // optional string PositionIdentifier = 8;
  inline bool has_positionidentifier() const;
  inline void clear_positionidentifier();
  static const int kPositionIdentifierFieldNumber = 8;
  inline const ::std::string& positionidentifier() const;
  inline void set_positionidentifier(const ::std::string& value);
  inline void set_positionidentifier(const char* value);
  inline void set_positionidentifier(const char* value, size_t size);
  inline ::std::string* mutable_positionidentifier();
  inline ::std::string* release_positionidentifier();
  inline void set_allocated_positionidentifier(::std::string* positionidentifier);

  // optional string TradeAccount = 9;
  inline bool has_tradeaccount() const;
  inline void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 9;
  inline const ::std::string& tradeaccount() const;
  inline void set_tradeaccount(const ::std::string& value);
  inline void set_tradeaccount(const char* value);
  inline void set_tradeaccount(const char* value, size_t size);
  inline ::std::string* mutable_tradeaccount();
  inline ::std::string* release_tradeaccount();
  inline void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional uint32 NoPositions = 10;
  inline bool has_nopositions() const;
  inline void clear_nopositions();
  static const int kNoPositionsFieldNumber = 10;
  inline ::google::protobuf::uint32 nopositions() const;
  inline void set_nopositions(::google::protobuf::uint32 value);

  // optional uint32 Unsolicited = 11;
  inline bool has_unsolicited() const;
  inline void clear_unsolicited();
  static const int kUnsolicitedFieldNumber = 11;
  inline ::google::protobuf::uint32 unsolicited() const;
  inline void set_unsolicited(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.PositionUpdate)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_totalnumbermessages();
  inline void clear_has_totalnumbermessages();
  inline void set_has_messagenumber();
  inline void clear_has_messagenumber();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_exchange();
  inline void clear_has_exchange();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_averageprice();
  inline void clear_has_averageprice();
  inline void set_has_positionidentifier();
  inline void clear_has_positionidentifier();
  inline void set_has_tradeaccount();
  inline void clear_has_tradeaccount();
  inline void set_has_nopositions();
  inline void clear_has_nopositions();
  inline void set_has_unsolicited();
  inline void clear_has_unsolicited();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 totalnumbermessages_;
  ::std::string* symbol_;
  ::std::string* exchange_;
  double quantity_;
  ::google::protobuf::int32 messagenumber_;
  ::google::protobuf::uint32 nopositions_;
  double averageprice_;
  ::std::string* positionidentifier_;
  ::std::string* tradeaccount_;
  ::google::protobuf::uint32 unsolicited_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static PositionUpdate* default_instance_;
};
// -------------------------------------------------------------------

class TradeAccountsRequest : public ::google::protobuf::Message {
 public:
  TradeAccountsRequest();
  virtual ~TradeAccountsRequest();

  TradeAccountsRequest(const TradeAccountsRequest& from);

  inline TradeAccountsRequest& operator=(const TradeAccountsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeAccountsRequest& default_instance();

  void Swap(TradeAccountsRequest* other);

  // implements Message ----------------------------------------------

  TradeAccountsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TradeAccountsRequest& from);
  void MergeFrom(const TradeAccountsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.TradeAccountsRequest)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static TradeAccountsRequest* default_instance_;
};
// -------------------------------------------------------------------

class TradeAccountResponse : public ::google::protobuf::Message {
 public:
  TradeAccountResponse();
  virtual ~TradeAccountResponse();

  TradeAccountResponse(const TradeAccountResponse& from);

  inline TradeAccountResponse& operator=(const TradeAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeAccountResponse& default_instance();

  void Swap(TradeAccountResponse* other);

  // implements Message ----------------------------------------------

  TradeAccountResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TradeAccountResponse& from);
  void MergeFrom(const TradeAccountResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 TotalNumberMessages = 1;
  inline bool has_totalnumbermessages() const;
  inline void clear_totalnumbermessages();
  static const int kTotalNumberMessagesFieldNumber = 1;
  inline ::google::protobuf::int32 totalnumbermessages() const;
  inline void set_totalnumbermessages(::google::protobuf::int32 value);

  // optional int32 MessageNumber = 2;
  inline bool has_messagenumber() const;
  inline void clear_messagenumber();
  static const int kMessageNumberFieldNumber = 2;
  inline ::google::protobuf::int32 messagenumber() const;
  inline void set_messagenumber(::google::protobuf::int32 value);

  // optional string TradeAccount = 3;
  inline bool has_tradeaccount() const;
  inline void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 3;
  inline const ::std::string& tradeaccount() const;
  inline void set_tradeaccount(const ::std::string& value);
  inline void set_tradeaccount(const char* value);
  inline void set_tradeaccount(const char* value, size_t size);
  inline ::std::string* mutable_tradeaccount();
  inline ::std::string* release_tradeaccount();
  inline void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional int32 RequestID = 4;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 4;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.TradeAccountResponse)
 private:
  inline void set_has_totalnumbermessages();
  inline void clear_has_totalnumbermessages();
  inline void set_has_messagenumber();
  inline void clear_has_messagenumber();
  inline void set_has_tradeaccount();
  inline void clear_has_tradeaccount();
  inline void set_has_requestid();
  inline void clear_has_requestid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 totalnumbermessages_;
  ::google::protobuf::int32 messagenumber_;
  ::std::string* tradeaccount_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static TradeAccountResponse* default_instance_;
};
// -------------------------------------------------------------------

class ExchangeListRequest : public ::google::protobuf::Message {
 public:
  ExchangeListRequest();
  virtual ~ExchangeListRequest();

  ExchangeListRequest(const ExchangeListRequest& from);

  inline ExchangeListRequest& operator=(const ExchangeListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeListRequest& default_instance();

  void Swap(ExchangeListRequest* other);

  // implements Message ----------------------------------------------

  ExchangeListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExchangeListRequest& from);
  void MergeFrom(const ExchangeListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.ExchangeListRequest)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static ExchangeListRequest* default_instance_;
};
// -------------------------------------------------------------------

class ExchangeListResponse : public ::google::protobuf::Message {
 public:
  ExchangeListResponse();
  virtual ~ExchangeListResponse();

  ExchangeListResponse(const ExchangeListResponse& from);

  inline ExchangeListResponse& operator=(const ExchangeListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeListResponse& default_instance();

  void Swap(ExchangeListResponse* other);

  // implements Message ----------------------------------------------

  ExchangeListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExchangeListResponse& from);
  void MergeFrom(const ExchangeListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string Exchange = 2;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 2;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // optional uint32 IsFinalMessage = 3;
  inline bool has_isfinalmessage() const;
  inline void clear_isfinalmessage();
  static const int kIsFinalMessageFieldNumber = 3;
  inline ::google::protobuf::uint32 isfinalmessage() const;
  inline void set_isfinalmessage(::google::protobuf::uint32 value);

  // optional string Description = 4;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 4;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:DTC_PB.ExchangeListResponse)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_exchange();
  inline void clear_has_exchange();
  inline void set_has_isfinalmessage();
  inline void clear_has_isfinalmessage();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* exchange_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::uint32 isfinalmessage_;
  ::std::string* description_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static ExchangeListResponse* default_instance_;
};
// -------------------------------------------------------------------

class SymbolsForExchangeRequest : public ::google::protobuf::Message {
 public:
  SymbolsForExchangeRequest();
  virtual ~SymbolsForExchangeRequest();

  SymbolsForExchangeRequest(const SymbolsForExchangeRequest& from);

  inline SymbolsForExchangeRequest& operator=(const SymbolsForExchangeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolsForExchangeRequest& default_instance();

  void Swap(SymbolsForExchangeRequest* other);

  // implements Message ----------------------------------------------

  SymbolsForExchangeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SymbolsForExchangeRequest& from);
  void MergeFrom(const SymbolsForExchangeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string Exchange = 2;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 2;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // optional .DTC_PB.SecurityTypeEnum SecurityType = 3;
  inline bool has_securitytype() const;
  inline void clear_securitytype();
  static const int kSecurityTypeFieldNumber = 3;
  inline ::DTC_PB::SecurityTypeEnum securitytype() const;
  inline void set_securitytype(::DTC_PB::SecurityTypeEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.SymbolsForExchangeRequest)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_exchange();
  inline void clear_has_exchange();
  inline void set_has_securitytype();
  inline void clear_has_securitytype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* exchange_;
  ::google::protobuf::int32 requestid_;
  int securitytype_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static SymbolsForExchangeRequest* default_instance_;
};
// -------------------------------------------------------------------

class UnderlyingSymbolsForExchangeRequest : public ::google::protobuf::Message {
 public:
  UnderlyingSymbolsForExchangeRequest();
  virtual ~UnderlyingSymbolsForExchangeRequest();

  UnderlyingSymbolsForExchangeRequest(const UnderlyingSymbolsForExchangeRequest& from);

  inline UnderlyingSymbolsForExchangeRequest& operator=(const UnderlyingSymbolsForExchangeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnderlyingSymbolsForExchangeRequest& default_instance();

  void Swap(UnderlyingSymbolsForExchangeRequest* other);

  // implements Message ----------------------------------------------

  UnderlyingSymbolsForExchangeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnderlyingSymbolsForExchangeRequest& from);
  void MergeFrom(const UnderlyingSymbolsForExchangeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string Exchange = 2;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 2;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // optional .DTC_PB.SecurityTypeEnum SecurityType = 3;
  inline bool has_securitytype() const;
  inline void clear_securitytype();
  static const int kSecurityTypeFieldNumber = 3;
  inline ::DTC_PB::SecurityTypeEnum securitytype() const;
  inline void set_securitytype(::DTC_PB::SecurityTypeEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.UnderlyingSymbolsForExchangeRequest)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_exchange();
  inline void clear_has_exchange();
  inline void set_has_securitytype();
  inline void clear_has_securitytype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* exchange_;
  ::google::protobuf::int32 requestid_;
  int securitytype_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static UnderlyingSymbolsForExchangeRequest* default_instance_;
};
// -------------------------------------------------------------------

class SymbolsForUnderlyingRequest : public ::google::protobuf::Message {
 public:
  SymbolsForUnderlyingRequest();
  virtual ~SymbolsForUnderlyingRequest();

  SymbolsForUnderlyingRequest(const SymbolsForUnderlyingRequest& from);

  inline SymbolsForUnderlyingRequest& operator=(const SymbolsForUnderlyingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolsForUnderlyingRequest& default_instance();

  void Swap(SymbolsForUnderlyingRequest* other);

  // implements Message ----------------------------------------------

  SymbolsForUnderlyingRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SymbolsForUnderlyingRequest& from);
  void MergeFrom(const SymbolsForUnderlyingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string UnderlyingSymbol = 2;
  inline bool has_underlyingsymbol() const;
  inline void clear_underlyingsymbol();
  static const int kUnderlyingSymbolFieldNumber = 2;
  inline const ::std::string& underlyingsymbol() const;
  inline void set_underlyingsymbol(const ::std::string& value);
  inline void set_underlyingsymbol(const char* value);
  inline void set_underlyingsymbol(const char* value, size_t size);
  inline ::std::string* mutable_underlyingsymbol();
  inline ::std::string* release_underlyingsymbol();
  inline void set_allocated_underlyingsymbol(::std::string* underlyingsymbol);

  // optional string Exchange = 3;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 3;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // optional .DTC_PB.SecurityTypeEnum SecurityType = 4;
  inline bool has_securitytype() const;
  inline void clear_securitytype();
  static const int kSecurityTypeFieldNumber = 4;
  inline ::DTC_PB::SecurityTypeEnum securitytype() const;
  inline void set_securitytype(::DTC_PB::SecurityTypeEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.SymbolsForUnderlyingRequest)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_underlyingsymbol();
  inline void clear_has_underlyingsymbol();
  inline void set_has_exchange();
  inline void clear_has_exchange();
  inline void set_has_securitytype();
  inline void clear_has_securitytype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* underlyingsymbol_;
  ::google::protobuf::int32 requestid_;
  int securitytype_;
  ::std::string* exchange_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static SymbolsForUnderlyingRequest* default_instance_;
};
// -------------------------------------------------------------------

class SymbolSearchRequest : public ::google::protobuf::Message {
 public:
  SymbolSearchRequest();
  virtual ~SymbolSearchRequest();

  SymbolSearchRequest(const SymbolSearchRequest& from);

  inline SymbolSearchRequest& operator=(const SymbolSearchRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolSearchRequest& default_instance();

  void Swap(SymbolSearchRequest* other);

  // implements Message ----------------------------------------------

  SymbolSearchRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SymbolSearchRequest& from);
  void MergeFrom(const SymbolSearchRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string SearchText = 2;
  inline bool has_searchtext() const;
  inline void clear_searchtext();
  static const int kSearchTextFieldNumber = 2;
  inline const ::std::string& searchtext() const;
  inline void set_searchtext(const ::std::string& value);
  inline void set_searchtext(const char* value);
  inline void set_searchtext(const char* value, size_t size);
  inline ::std::string* mutable_searchtext();
  inline ::std::string* release_searchtext();
  inline void set_allocated_searchtext(::std::string* searchtext);

  // optional string Exchange = 3;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 3;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // optional .DTC_PB.SecurityTypeEnum SecurityType = 4;
  inline bool has_securitytype() const;
  inline void clear_securitytype();
  static const int kSecurityTypeFieldNumber = 4;
  inline ::DTC_PB::SecurityTypeEnum securitytype() const;
  inline void set_securitytype(::DTC_PB::SecurityTypeEnum value);

  // optional .DTC_PB.SearchTypeEnum SearchType = 5;
  inline bool has_searchtype() const;
  inline void clear_searchtype();
  static const int kSearchTypeFieldNumber = 5;
  inline ::DTC_PB::SearchTypeEnum searchtype() const;
  inline void set_searchtype(::DTC_PB::SearchTypeEnum value);

  // @@protoc_insertion_point(class_scope:DTC_PB.SymbolSearchRequest)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_searchtext();
  inline void clear_has_searchtext();
  inline void set_has_exchange();
  inline void clear_has_exchange();
  inline void set_has_securitytype();
  inline void clear_has_securitytype();
  inline void set_has_searchtype();
  inline void clear_has_searchtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* searchtext_;
  ::google::protobuf::int32 requestid_;
  int securitytype_;
  ::std::string* exchange_;
  int searchtype_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static SymbolSearchRequest* default_instance_;
};
// -------------------------------------------------------------------

class SecurityDefinitionForSymbolRequest : public ::google::protobuf::Message {
 public:
  SecurityDefinitionForSymbolRequest();
  virtual ~SecurityDefinitionForSymbolRequest();

  SecurityDefinitionForSymbolRequest(const SecurityDefinitionForSymbolRequest& from);

  inline SecurityDefinitionForSymbolRequest& operator=(const SecurityDefinitionForSymbolRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityDefinitionForSymbolRequest& default_instance();

  void Swap(SecurityDefinitionForSymbolRequest* other);

  // implements Message ----------------------------------------------

  SecurityDefinitionForSymbolRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecurityDefinitionForSymbolRequest& from);
  void MergeFrom(const SecurityDefinitionForSymbolRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string Symbol = 2;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 2;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 3;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 3;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // @@protoc_insertion_point(class_scope:DTC_PB.SecurityDefinitionForSymbolRequest)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_exchange();
  inline void clear_has_exchange();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* symbol_;
  ::std::string* exchange_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static SecurityDefinitionForSymbolRequest* default_instance_;
};
// -------------------------------------------------------------------

class SecurityDefinitionResponse : public ::google::protobuf::Message {
 public:
  SecurityDefinitionResponse();
  virtual ~SecurityDefinitionResponse();

  SecurityDefinitionResponse(const SecurityDefinitionResponse& from);

  inline SecurityDefinitionResponse& operator=(const SecurityDefinitionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityDefinitionResponse& default_instance();

  void Swap(SecurityDefinitionResponse* other);

  // implements Message ----------------------------------------------

  SecurityDefinitionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecurityDefinitionResponse& from);
  void MergeFrom(const SecurityDefinitionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string Symbol = 2;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 2;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 3;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 3;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // optional .DTC_PB.SecurityTypeEnum SecurityType = 4;
  inline bool has_securitytype() const;
  inline void clear_securitytype();
  static const int kSecurityTypeFieldNumber = 4;
  inline ::DTC_PB::SecurityTypeEnum securitytype() const;
  inline void set_securitytype(::DTC_PB::SecurityTypeEnum value);

  // optional string Description = 5;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 5;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional float MinPriceIncrement = 6;
  inline bool has_minpriceincrement() const;
  inline void clear_minpriceincrement();
  static const int kMinPriceIncrementFieldNumber = 6;
  inline float minpriceincrement() const;
  inline void set_minpriceincrement(float value);

  // optional .DTC_PB.PriceDisplayFormatEnum PriceDisplayFormat = 7;
  inline bool has_pricedisplayformat() const;
  inline void clear_pricedisplayformat();
  static const int kPriceDisplayFormatFieldNumber = 7;
  inline ::DTC_PB::PriceDisplayFormatEnum pricedisplayformat() const;
  inline void set_pricedisplayformat(::DTC_PB::PriceDisplayFormatEnum value);

  // optional float CurrencyValuePerIncrement = 8;
  inline bool has_currencyvalueperincrement() const;
  inline void clear_currencyvalueperincrement();
  static const int kCurrencyValuePerIncrementFieldNumber = 8;
  inline float currencyvalueperincrement() const;
  inline void set_currencyvalueperincrement(float value);

  // optional uint32 IsFinalMessage = 9;
  inline bool has_isfinalmessage() const;
  inline void clear_isfinalmessage();
  static const int kIsFinalMessageFieldNumber = 9;
  inline ::google::protobuf::uint32 isfinalmessage() const;
  inline void set_isfinalmessage(::google::protobuf::uint32 value);

  // optional float FloatToIntPriceMultiplier = 10;
  inline bool has_floattointpricemultiplier() const;
  inline void clear_floattointpricemultiplier();
  static const int kFloatToIntPriceMultiplierFieldNumber = 10;
  inline float floattointpricemultiplier() const;
  inline void set_floattointpricemultiplier(float value);

  // optional float IntToFloatPriceDivisor = 11;
  inline bool has_inttofloatpricedivisor() const;
  inline void clear_inttofloatpricedivisor();
  static const int kIntToFloatPriceDivisorFieldNumber = 11;
  inline float inttofloatpricedivisor() const;
  inline void set_inttofloatpricedivisor(float value);

  // optional string UnderlyingSymbol = 12;
  inline bool has_underlyingsymbol() const;
  inline void clear_underlyingsymbol();
  static const int kUnderlyingSymbolFieldNumber = 12;
  inline const ::std::string& underlyingsymbol() const;
  inline void set_underlyingsymbol(const ::std::string& value);
  inline void set_underlyingsymbol(const char* value);
  inline void set_underlyingsymbol(const char* value, size_t size);
  inline ::std::string* mutable_underlyingsymbol();
  inline ::std::string* release_underlyingsymbol();
  inline void set_allocated_underlyingsymbol(::std::string* underlyingsymbol);

  // optional uint32 UpdatesBidAskOnly = 13;
  inline bool has_updatesbidaskonly() const;
  inline void clear_updatesbidaskonly();
  static const int kUpdatesBidAskOnlyFieldNumber = 13;
  inline ::google::protobuf::uint32 updatesbidaskonly() const;
  inline void set_updatesbidaskonly(::google::protobuf::uint32 value);

  // optional float StrikePrice = 14;
  inline bool has_strikeprice() const;
  inline void clear_strikeprice();
  static const int kStrikePriceFieldNumber = 14;
  inline float strikeprice() const;
  inline void set_strikeprice(float value);

  // optional .DTC_PB.PutCallEnum PutOrCall = 15;
  inline bool has_putorcall() const;
  inline void clear_putorcall();
  static const int kPutOrCallFieldNumber = 15;
  inline ::DTC_PB::PutCallEnum putorcall() const;
  inline void set_putorcall(::DTC_PB::PutCallEnum value);

  // optional uint32 ShortInterest = 16;
  inline bool has_shortinterest() const;
  inline void clear_shortinterest();
  static const int kShortInterestFieldNumber = 16;
  inline ::google::protobuf::uint32 shortinterest() const;
  inline void set_shortinterest(::google::protobuf::uint32 value);

  // optional sfixed32 SecurityExpirationDate = 17;
  inline bool has_securityexpirationdate() const;
  inline void clear_securityexpirationdate();
  static const int kSecurityExpirationDateFieldNumber = 17;
  inline ::google::protobuf::int32 securityexpirationdate() const;
  inline void set_securityexpirationdate(::google::protobuf::int32 value);

  // optional float BuyRolloverInterest = 18;
  inline bool has_buyrolloverinterest() const;
  inline void clear_buyrolloverinterest();
  static const int kBuyRolloverInterestFieldNumber = 18;
  inline float buyrolloverinterest() const;
  inline void set_buyrolloverinterest(float value);

  // optional float SellRolloverInterest = 19;
  inline bool has_sellrolloverinterest() const;
  inline void clear_sellrolloverinterest();
  static const int kSellRolloverInterestFieldNumber = 19;
  inline float sellrolloverinterest() const;
  inline void set_sellrolloverinterest(float value);

  // optional float EarningsPerShare = 20;
  inline bool has_earningspershare() const;
  inline void clear_earningspershare();
  static const int kEarningsPerShareFieldNumber = 20;
  inline float earningspershare() const;
  inline void set_earningspershare(float value);

  // optional uint32 SharesOutstanding = 21;
  inline bool has_sharesoutstanding() const;
  inline void clear_sharesoutstanding();
  static const int kSharesOutstandingFieldNumber = 21;
  inline ::google::protobuf::uint32 sharesoutstanding() const;
  inline void set_sharesoutstanding(::google::protobuf::uint32 value);

  // optional float IntToFloatQuantityDivisor = 22;
  inline bool has_inttofloatquantitydivisor() const;
  inline void clear_inttofloatquantitydivisor();
  static const int kIntToFloatQuantityDivisorFieldNumber = 22;
  inline float inttofloatquantitydivisor() const;
  inline void set_inttofloatquantitydivisor(float value);

  // @@protoc_insertion_point(class_scope:DTC_PB.SecurityDefinitionResponse)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_exchange();
  inline void clear_has_exchange();
  inline void set_has_securitytype();
  inline void clear_has_securitytype();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_minpriceincrement();
  inline void clear_has_minpriceincrement();
  inline void set_has_pricedisplayformat();
  inline void clear_has_pricedisplayformat();
  inline void set_has_currencyvalueperincrement();
  inline void clear_has_currencyvalueperincrement();
  inline void set_has_isfinalmessage();
  inline void clear_has_isfinalmessage();
  inline void set_has_floattointpricemultiplier();
  inline void clear_has_floattointpricemultiplier();
  inline void set_has_inttofloatpricedivisor();
  inline void clear_has_inttofloatpricedivisor();
  inline void set_has_underlyingsymbol();
  inline void clear_has_underlyingsymbol();
  inline void set_has_updatesbidaskonly();
  inline void clear_has_updatesbidaskonly();
  inline void set_has_strikeprice();
  inline void clear_has_strikeprice();
  inline void set_has_putorcall();
  inline void clear_has_putorcall();
  inline void set_has_shortinterest();
  inline void clear_has_shortinterest();
  inline void set_has_securityexpirationdate();
  inline void clear_has_securityexpirationdate();
  inline void set_has_buyrolloverinterest();
  inline void clear_has_buyrolloverinterest();
  inline void set_has_sellrolloverinterest();
  inline void clear_has_sellrolloverinterest();
  inline void set_has_earningspershare();
  inline void clear_has_earningspershare();
  inline void set_has_sharesoutstanding();
  inline void clear_has_sharesoutstanding();
  inline void set_has_inttofloatquantitydivisor();
  inline void clear_has_inttofloatquantitydivisor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* symbol_;
  ::google::protobuf::int32 requestid_;
  int securitytype_;
  ::std::string* exchange_;
  ::std::string* description_;
  float minpriceincrement_;
  int pricedisplayformat_;
  float currencyvalueperincrement_;
  ::google::protobuf::uint32 isfinalmessage_;
  float floattointpricemultiplier_;
  float inttofloatpricedivisor_;
  ::std::string* underlyingsymbol_;
  ::google::protobuf::uint32 updatesbidaskonly_;
  float strikeprice_;
  int putorcall_;
  ::google::protobuf::uint32 shortinterest_;
  ::google::protobuf::int32 securityexpirationdate_;
  float buyrolloverinterest_;
  float sellrolloverinterest_;
  float earningspershare_;
  ::google::protobuf::uint32 sharesoutstanding_;
  float inttofloatquantitydivisor_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static SecurityDefinitionResponse* default_instance_;
};
// -------------------------------------------------------------------

class SecurityDefinitionReject : public ::google::protobuf::Message {
 public:
  SecurityDefinitionReject();
  virtual ~SecurityDefinitionReject();

  SecurityDefinitionReject(const SecurityDefinitionReject& from);

  inline SecurityDefinitionReject& operator=(const SecurityDefinitionReject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityDefinitionReject& default_instance();

  void Swap(SecurityDefinitionReject* other);

  // implements Message ----------------------------------------------

  SecurityDefinitionReject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecurityDefinitionReject& from);
  void MergeFrom(const SecurityDefinitionReject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string RejectText = 2;
  inline bool has_rejecttext() const;
  inline void clear_rejecttext();
  static const int kRejectTextFieldNumber = 2;
  inline const ::std::string& rejecttext() const;
  inline void set_rejecttext(const ::std::string& value);
  inline void set_rejecttext(const char* value);
  inline void set_rejecttext(const char* value, size_t size);
  inline ::std::string* mutable_rejecttext();
  inline ::std::string* release_rejecttext();
  inline void set_allocated_rejecttext(::std::string* rejecttext);

  // @@protoc_insertion_point(class_scope:DTC_PB.SecurityDefinitionReject)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_rejecttext();
  inline void clear_has_rejecttext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* rejecttext_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static SecurityDefinitionReject* default_instance_;
};
// -------------------------------------------------------------------

class AccountBalanceRequest : public ::google::protobuf::Message {
 public:
  AccountBalanceRequest();
  virtual ~AccountBalanceRequest();

  AccountBalanceRequest(const AccountBalanceRequest& from);

  inline AccountBalanceRequest& operator=(const AccountBalanceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountBalanceRequest& default_instance();

  void Swap(AccountBalanceRequest* other);

  // implements Message ----------------------------------------------

  AccountBalanceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountBalanceRequest& from);
  void MergeFrom(const AccountBalanceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string TradeAccount = 2;
  inline bool has_tradeaccount() const;
  inline void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 2;
  inline const ::std::string& tradeaccount() const;
  inline void set_tradeaccount(const ::std::string& value);
  inline void set_tradeaccount(const char* value);
  inline void set_tradeaccount(const char* value, size_t size);
  inline ::std::string* mutable_tradeaccount();
  inline ::std::string* release_tradeaccount();
  inline void set_allocated_tradeaccount(::std::string* tradeaccount);

  // @@protoc_insertion_point(class_scope:DTC_PB.AccountBalanceRequest)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_tradeaccount();
  inline void clear_has_tradeaccount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* tradeaccount_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static AccountBalanceRequest* default_instance_;
};
// -------------------------------------------------------------------

class AccountBalanceReject : public ::google::protobuf::Message {
 public:
  AccountBalanceReject();
  virtual ~AccountBalanceReject();

  AccountBalanceReject(const AccountBalanceReject& from);

  inline AccountBalanceReject& operator=(const AccountBalanceReject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountBalanceReject& default_instance();

  void Swap(AccountBalanceReject* other);

  // implements Message ----------------------------------------------

  AccountBalanceReject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountBalanceReject& from);
  void MergeFrom(const AccountBalanceReject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string RejectText = 2;
  inline bool has_rejecttext() const;
  inline void clear_rejecttext();
  static const int kRejectTextFieldNumber = 2;
  inline const ::std::string& rejecttext() const;
  inline void set_rejecttext(const ::std::string& value);
  inline void set_rejecttext(const char* value);
  inline void set_rejecttext(const char* value, size_t size);
  inline ::std::string* mutable_rejecttext();
  inline ::std::string* release_rejecttext();
  inline void set_allocated_rejecttext(::std::string* rejecttext);

  // @@protoc_insertion_point(class_scope:DTC_PB.AccountBalanceReject)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_rejecttext();
  inline void clear_has_rejecttext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* rejecttext_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static AccountBalanceReject* default_instance_;
};
// -------------------------------------------------------------------

class AccountBalanceUpdate : public ::google::protobuf::Message {
 public:
  AccountBalanceUpdate();
  virtual ~AccountBalanceUpdate();

  AccountBalanceUpdate(const AccountBalanceUpdate& from);

  inline AccountBalanceUpdate& operator=(const AccountBalanceUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountBalanceUpdate& default_instance();

  void Swap(AccountBalanceUpdate* other);

  // implements Message ----------------------------------------------

  AccountBalanceUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountBalanceUpdate& from);
  void MergeFrom(const AccountBalanceUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional double CashBalance = 2;
  inline bool has_cashbalance() const;
  inline void clear_cashbalance();
  static const int kCashBalanceFieldNumber = 2;
  inline double cashbalance() const;
  inline void set_cashbalance(double value);

  // optional double BalanceAvailableForNewPositions = 3;
  inline bool has_balanceavailablefornewpositions() const;
  inline void clear_balanceavailablefornewpositions();
  static const int kBalanceAvailableForNewPositionsFieldNumber = 3;
  inline double balanceavailablefornewpositions() const;
  inline void set_balanceavailablefornewpositions(double value);

  // optional string AccountCurrency = 4;
  inline bool has_accountcurrency() const;
  inline void clear_accountcurrency();
  static const int kAccountCurrencyFieldNumber = 4;
  inline const ::std::string& accountcurrency() const;
  inline void set_accountcurrency(const ::std::string& value);
  inline void set_accountcurrency(const char* value);
  inline void set_accountcurrency(const char* value, size_t size);
  inline ::std::string* mutable_accountcurrency();
  inline ::std::string* release_accountcurrency();
  inline void set_allocated_accountcurrency(::std::string* accountcurrency);

  // optional string TradeAccount = 5;
  inline bool has_tradeaccount() const;
  inline void clear_tradeaccount();
  static const int kTradeAccountFieldNumber = 5;
  inline const ::std::string& tradeaccount() const;
  inline void set_tradeaccount(const ::std::string& value);
  inline void set_tradeaccount(const char* value);
  inline void set_tradeaccount(const char* value, size_t size);
  inline ::std::string* mutable_tradeaccount();
  inline ::std::string* release_tradeaccount();
  inline void set_allocated_tradeaccount(::std::string* tradeaccount);

  // optional double SecuritiesValue = 6;
  inline bool has_securitiesvalue() const;
  inline void clear_securitiesvalue();
  static const int kSecuritiesValueFieldNumber = 6;
  inline double securitiesvalue() const;
  inline void set_securitiesvalue(double value);

  // optional double MarginRequirement = 7;
  inline bool has_marginrequirement() const;
  inline void clear_marginrequirement();
  static const int kMarginRequirementFieldNumber = 7;
  inline double marginrequirement() const;
  inline void set_marginrequirement(double value);

  // optional int32 TotalNumberMessages = 8;
  inline bool has_totalnumbermessages() const;
  inline void clear_totalnumbermessages();
  static const int kTotalNumberMessagesFieldNumber = 8;
  inline ::google::protobuf::int32 totalnumbermessages() const;
  inline void set_totalnumbermessages(::google::protobuf::int32 value);

  // optional int32 MessageNumber = 9;
  inline bool has_messagenumber() const;
  inline void clear_messagenumber();
  static const int kMessageNumberFieldNumber = 9;
  inline ::google::protobuf::int32 messagenumber() const;
  inline void set_messagenumber(::google::protobuf::int32 value);

  // optional uint32 NoAccountBalances = 10;
  inline bool has_noaccountbalances() const;
  inline void clear_noaccountbalances();
  static const int kNoAccountBalancesFieldNumber = 10;
  inline ::google::protobuf::uint32 noaccountbalances() const;
  inline void set_noaccountbalances(::google::protobuf::uint32 value);

  // optional uint32 Unsolicited = 11;
  inline bool has_unsolicited() const;
  inline void clear_unsolicited();
  static const int kUnsolicitedFieldNumber = 11;
  inline ::google::protobuf::uint32 unsolicited() const;
  inline void set_unsolicited(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.AccountBalanceUpdate)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_cashbalance();
  inline void clear_has_cashbalance();
  inline void set_has_balanceavailablefornewpositions();
  inline void clear_has_balanceavailablefornewpositions();
  inline void set_has_accountcurrency();
  inline void clear_has_accountcurrency();
  inline void set_has_tradeaccount();
  inline void clear_has_tradeaccount();
  inline void set_has_securitiesvalue();
  inline void clear_has_securitiesvalue();
  inline void set_has_marginrequirement();
  inline void clear_has_marginrequirement();
  inline void set_has_totalnumbermessages();
  inline void clear_has_totalnumbermessages();
  inline void set_has_messagenumber();
  inline void clear_has_messagenumber();
  inline void set_has_noaccountbalances();
  inline void clear_has_noaccountbalances();
  inline void set_has_unsolicited();
  inline void clear_has_unsolicited();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double cashbalance_;
  double balanceavailablefornewpositions_;
  ::std::string* accountcurrency_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 totalnumbermessages_;
  ::std::string* tradeaccount_;
  double securitiesvalue_;
  double marginrequirement_;
  ::google::protobuf::int32 messagenumber_;
  ::google::protobuf::uint32 noaccountbalances_;
  ::google::protobuf::uint32 unsolicited_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static AccountBalanceUpdate* default_instance_;
};
// -------------------------------------------------------------------

class UserMessage : public ::google::protobuf::Message {
 public:
  UserMessage();
  virtual ~UserMessage();

  UserMessage(const UserMessage& from);

  inline UserMessage& operator=(const UserMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMessage& default_instance();

  void Swap(UserMessage* other);

  // implements Message ----------------------------------------------

  UserMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserMessage& from);
  void MergeFrom(const UserMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UserMessage = 1;
  inline bool has_usermessage() const;
  inline void clear_usermessage();
  static const int kUserMessageFieldNumber = 1;
  inline const ::std::string& usermessage() const;
  inline void set_usermessage(const ::std::string& value);
  inline void set_usermessage(const char* value);
  inline void set_usermessage(const char* value, size_t size);
  inline ::std::string* mutable_usermessage();
  inline ::std::string* release_usermessage();
  inline void set_allocated_usermessage(::std::string* usermessage);

  // optional uint32 IsPopupMessage = 2;
  inline bool has_ispopupmessage() const;
  inline void clear_ispopupmessage();
  static const int kIsPopupMessageFieldNumber = 2;
  inline ::google::protobuf::uint32 ispopupmessage() const;
  inline void set_ispopupmessage(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.UserMessage)
 private:
  inline void set_has_usermessage();
  inline void clear_has_usermessage();
  inline void set_has_ispopupmessage();
  inline void clear_has_ispopupmessage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* usermessage_;
  ::google::protobuf::uint32 ispopupmessage_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static UserMessage* default_instance_;
};
// -------------------------------------------------------------------

class GeneralLogMessage : public ::google::protobuf::Message {
 public:
  GeneralLogMessage();
  virtual ~GeneralLogMessage();

  GeneralLogMessage(const GeneralLogMessage& from);

  inline GeneralLogMessage& operator=(const GeneralLogMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GeneralLogMessage& default_instance();

  void Swap(GeneralLogMessage* other);

  // implements Message ----------------------------------------------

  GeneralLogMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeneralLogMessage& from);
  void MergeFrom(const GeneralLogMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string MessageText = 3;
  inline bool has_messagetext() const;
  inline void clear_messagetext();
  static const int kMessageTextFieldNumber = 3;
  inline const ::std::string& messagetext() const;
  inline void set_messagetext(const ::std::string& value);
  inline void set_messagetext(const char* value);
  inline void set_messagetext(const char* value, size_t size);
  inline ::std::string* mutable_messagetext();
  inline ::std::string* release_messagetext();
  inline void set_allocated_messagetext(::std::string* messagetext);

  // @@protoc_insertion_point(class_scope:DTC_PB.GeneralLogMessage)
 private:
  inline void set_has_messagetext();
  inline void clear_has_messagetext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* messagetext_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static GeneralLogMessage* default_instance_;
};
// -------------------------------------------------------------------

class HistoricalPriceDataRequest : public ::google::protobuf::Message {
 public:
  HistoricalPriceDataRequest();
  virtual ~HistoricalPriceDataRequest();

  HistoricalPriceDataRequest(const HistoricalPriceDataRequest& from);

  inline HistoricalPriceDataRequest& operator=(const HistoricalPriceDataRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalPriceDataRequest& default_instance();

  void Swap(HistoricalPriceDataRequest* other);

  // implements Message ----------------------------------------------

  HistoricalPriceDataRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoricalPriceDataRequest& from);
  void MergeFrom(const HistoricalPriceDataRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string Symbol = 2;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 2;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // optional string Exchange = 3;
  inline bool has_exchange() const;
  inline void clear_exchange();
  static const int kExchangeFieldNumber = 3;
  inline const ::std::string& exchange() const;
  inline void set_exchange(const ::std::string& value);
  inline void set_exchange(const char* value);
  inline void set_exchange(const char* value, size_t size);
  inline ::std::string* mutable_exchange();
  inline ::std::string* release_exchange();
  inline void set_allocated_exchange(::std::string* exchange);

  // optional .DTC_PB.HistoricalDataIntervalEnum RecordInterval = 4;
  inline bool has_recordinterval() const;
  inline void clear_recordinterval();
  static const int kRecordIntervalFieldNumber = 4;
  inline ::DTC_PB::HistoricalDataIntervalEnum recordinterval() const;
  inline void set_recordinterval(::DTC_PB::HistoricalDataIntervalEnum value);

  // optional sfixed64 StartDateTime = 5;
  inline bool has_startdatetime() const;
  inline void clear_startdatetime();
  static const int kStartDateTimeFieldNumber = 5;
  inline ::google::protobuf::int64 startdatetime() const;
  inline void set_startdatetime(::google::protobuf::int64 value);

  // optional sfixed64 EndDateTime = 6;
  inline bool has_enddatetime() const;
  inline void clear_enddatetime();
  static const int kEndDateTimeFieldNumber = 6;
  inline ::google::protobuf::int64 enddatetime() const;
  inline void set_enddatetime(::google::protobuf::int64 value);

  // optional uint32 MaxDaysToReturn = 7;
  inline bool has_maxdaystoreturn() const;
  inline void clear_maxdaystoreturn();
  static const int kMaxDaysToReturnFieldNumber = 7;
  inline ::google::protobuf::uint32 maxdaystoreturn() const;
  inline void set_maxdaystoreturn(::google::protobuf::uint32 value);

  // optional uint32 UseZLibCompression = 8;
  inline bool has_usezlibcompression() const;
  inline void clear_usezlibcompression();
  static const int kUseZLibCompressionFieldNumber = 8;
  inline ::google::protobuf::uint32 usezlibcompression() const;
  inline void set_usezlibcompression(::google::protobuf::uint32 value);

  // optional uint32 RequestDividendAdjustedStockData = 9;
  inline bool has_requestdividendadjustedstockdata() const;
  inline void clear_requestdividendadjustedstockdata();
  static const int kRequestDividendAdjustedStockDataFieldNumber = 9;
  inline ::google::protobuf::uint32 requestdividendadjustedstockdata() const;
  inline void set_requestdividendadjustedstockdata(::google::protobuf::uint32 value);

  // optional uint32 Flag_1 = 10;
  inline bool has_flag_1() const;
  inline void clear_flag_1();
  static const int kFlag1FieldNumber = 10;
  inline ::google::protobuf::uint32 flag_1() const;
  inline void set_flag_1(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalPriceDataRequest)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_exchange();
  inline void clear_has_exchange();
  inline void set_has_recordinterval();
  inline void clear_has_recordinterval();
  inline void set_has_startdatetime();
  inline void clear_has_startdatetime();
  inline void set_has_enddatetime();
  inline void clear_has_enddatetime();
  inline void set_has_maxdaystoreturn();
  inline void clear_has_maxdaystoreturn();
  inline void set_has_usezlibcompression();
  inline void clear_has_usezlibcompression();
  inline void set_has_requestdividendadjustedstockdata();
  inline void clear_has_requestdividendadjustedstockdata();
  inline void set_has_flag_1();
  inline void clear_has_flag_1();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* symbol_;
  ::google::protobuf::int32 requestid_;
  int recordinterval_;
  ::std::string* exchange_;
  ::google::protobuf::int64 startdatetime_;
  ::google::protobuf::int64 enddatetime_;
  ::google::protobuf::uint32 maxdaystoreturn_;
  ::google::protobuf::uint32 usezlibcompression_;
  ::google::protobuf::uint32 requestdividendadjustedstockdata_;
  ::google::protobuf::uint32 flag_1_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static HistoricalPriceDataRequest* default_instance_;
};
// -------------------------------------------------------------------

class HistoricalPriceDataResponseHeader : public ::google::protobuf::Message {
 public:
  HistoricalPriceDataResponseHeader();
  virtual ~HistoricalPriceDataResponseHeader();

  HistoricalPriceDataResponseHeader(const HistoricalPriceDataResponseHeader& from);

  inline HistoricalPriceDataResponseHeader& operator=(const HistoricalPriceDataResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalPriceDataResponseHeader& default_instance();

  void Swap(HistoricalPriceDataResponseHeader* other);

  // implements Message ----------------------------------------------

  HistoricalPriceDataResponseHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoricalPriceDataResponseHeader& from);
  void MergeFrom(const HistoricalPriceDataResponseHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional .DTC_PB.HistoricalDataIntervalEnum RecordInterval = 2;
  inline bool has_recordinterval() const;
  inline void clear_recordinterval();
  static const int kRecordIntervalFieldNumber = 2;
  inline ::DTC_PB::HistoricalDataIntervalEnum recordinterval() const;
  inline void set_recordinterval(::DTC_PB::HistoricalDataIntervalEnum value);

  // optional uint32 UseZLibCompression = 3;
  inline bool has_usezlibcompression() const;
  inline void clear_usezlibcompression();
  static const int kUseZLibCompressionFieldNumber = 3;
  inline ::google::protobuf::uint32 usezlibcompression() const;
  inline void set_usezlibcompression(::google::protobuf::uint32 value);

  // optional uint32 NoRecordsToReturn = 4;
  inline bool has_norecordstoreturn() const;
  inline void clear_norecordstoreturn();
  static const int kNoRecordsToReturnFieldNumber = 4;
  inline ::google::protobuf::uint32 norecordstoreturn() const;
  inline void set_norecordstoreturn(::google::protobuf::uint32 value);

  // optional float IntPriceDivisor = 5;
  inline bool has_intpricedivisor() const;
  inline void clear_intpricedivisor();
  static const int kIntPriceDivisorFieldNumber = 5;
  inline float intpricedivisor() const;
  inline void set_intpricedivisor(float value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalPriceDataResponseHeader)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_recordinterval();
  inline void clear_has_recordinterval();
  inline void set_has_usezlibcompression();
  inline void clear_has_usezlibcompression();
  inline void set_has_norecordstoreturn();
  inline void clear_has_norecordstoreturn();
  inline void set_has_intpricedivisor();
  inline void clear_has_intpricedivisor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 requestid_;
  int recordinterval_;
  ::google::protobuf::uint32 usezlibcompression_;
  ::google::protobuf::uint32 norecordstoreturn_;
  float intpricedivisor_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static HistoricalPriceDataResponseHeader* default_instance_;
};
// -------------------------------------------------------------------

class HistoricalPriceDataReject : public ::google::protobuf::Message {
 public:
  HistoricalPriceDataReject();
  virtual ~HistoricalPriceDataReject();

  HistoricalPriceDataReject(const HistoricalPriceDataReject& from);

  inline HistoricalPriceDataReject& operator=(const HistoricalPriceDataReject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalPriceDataReject& default_instance();

  void Swap(HistoricalPriceDataReject* other);

  // implements Message ----------------------------------------------

  HistoricalPriceDataReject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoricalPriceDataReject& from);
  void MergeFrom(const HistoricalPriceDataReject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional string RejectText = 2;
  inline bool has_rejecttext() const;
  inline void clear_rejecttext();
  static const int kRejectTextFieldNumber = 2;
  inline const ::std::string& rejecttext() const;
  inline void set_rejecttext(const ::std::string& value);
  inline void set_rejecttext(const char* value);
  inline void set_rejecttext(const char* value, size_t size);
  inline ::std::string* mutable_rejecttext();
  inline ::std::string* release_rejecttext();
  inline void set_allocated_rejecttext(::std::string* rejecttext);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalPriceDataReject)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_rejecttext();
  inline void clear_has_rejecttext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* rejecttext_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static HistoricalPriceDataReject* default_instance_;
};
// -------------------------------------------------------------------

class HistoricalPriceDataRecordResponse : public ::google::protobuf::Message {
 public:
  HistoricalPriceDataRecordResponse();
  virtual ~HistoricalPriceDataRecordResponse();

  HistoricalPriceDataRecordResponse(const HistoricalPriceDataRecordResponse& from);

  inline HistoricalPriceDataRecordResponse& operator=(const HistoricalPriceDataRecordResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalPriceDataRecordResponse& default_instance();

  void Swap(HistoricalPriceDataRecordResponse* other);

  // implements Message ----------------------------------------------

  HistoricalPriceDataRecordResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoricalPriceDataRecordResponse& from);
  void MergeFrom(const HistoricalPriceDataRecordResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional sfixed64 StartDateTime = 2;
  inline bool has_startdatetime() const;
  inline void clear_startdatetime();
  static const int kStartDateTimeFieldNumber = 2;
  inline ::google::protobuf::int64 startdatetime() const;
  inline void set_startdatetime(::google::protobuf::int64 value);

  // optional double OpenPrice = 3;
  inline bool has_openprice() const;
  inline void clear_openprice();
  static const int kOpenPriceFieldNumber = 3;
  inline double openprice() const;
  inline void set_openprice(double value);

  // optional double HighPrice = 4;
  inline bool has_highprice() const;
  inline void clear_highprice();
  static const int kHighPriceFieldNumber = 4;
  inline double highprice() const;
  inline void set_highprice(double value);

  // optional double LowPrice = 5;
  inline bool has_lowprice() const;
  inline void clear_lowprice();
  static const int kLowPriceFieldNumber = 5;
  inline double lowprice() const;
  inline void set_lowprice(double value);

  // optional double LastPrice = 6;
  inline bool has_lastprice() const;
  inline void clear_lastprice();
  static const int kLastPriceFieldNumber = 6;
  inline double lastprice() const;
  inline void set_lastprice(double value);

  // optional double Volume = 7;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 7;
  inline double volume() const;
  inline void set_volume(double value);

  // optional uint32 NumTrades = 8;
  inline bool has_numtrades() const;
  inline void clear_numtrades();
  static const int kNumTradesFieldNumber = 8;
  inline ::google::protobuf::uint32 numtrades() const;
  inline void set_numtrades(::google::protobuf::uint32 value);

  // optional double BidVolume = 9;
  inline bool has_bidvolume() const;
  inline void clear_bidvolume();
  static const int kBidVolumeFieldNumber = 9;
  inline double bidvolume() const;
  inline void set_bidvolume(double value);

  // optional double AskVolume = 10;
  inline bool has_askvolume() const;
  inline void clear_askvolume();
  static const int kAskVolumeFieldNumber = 10;
  inline double askvolume() const;
  inline void set_askvolume(double value);

  // optional uint32 IsFinalRecord = 11;
  inline bool has_isfinalrecord() const;
  inline void clear_isfinalrecord();
  static const int kIsFinalRecordFieldNumber = 11;
  inline ::google::protobuf::uint32 isfinalrecord() const;
  inline void set_isfinalrecord(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalPriceDataRecordResponse)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_startdatetime();
  inline void clear_has_startdatetime();
  inline void set_has_openprice();
  inline void clear_has_openprice();
  inline void set_has_highprice();
  inline void clear_has_highprice();
  inline void set_has_lowprice();
  inline void clear_has_lowprice();
  inline void set_has_lastprice();
  inline void clear_has_lastprice();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_numtrades();
  inline void clear_has_numtrades();
  inline void set_has_bidvolume();
  inline void clear_has_bidvolume();
  inline void set_has_askvolume();
  inline void clear_has_askvolume();
  inline void set_has_isfinalrecord();
  inline void clear_has_isfinalrecord();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 startdatetime_;
  double openprice_;
  double highprice_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::uint32 numtrades_;
  double lowprice_;
  double lastprice_;
  double volume_;
  double bidvolume_;
  double askvolume_;
  ::google::protobuf::uint32 isfinalrecord_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static HistoricalPriceDataRecordResponse* default_instance_;
};
// -------------------------------------------------------------------

class HistoricalPriceDataTickRecordResponse : public ::google::protobuf::Message {
 public:
  HistoricalPriceDataTickRecordResponse();
  virtual ~HistoricalPriceDataTickRecordResponse();

  HistoricalPriceDataTickRecordResponse(const HistoricalPriceDataTickRecordResponse& from);

  inline HistoricalPriceDataTickRecordResponse& operator=(const HistoricalPriceDataTickRecordResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalPriceDataTickRecordResponse& default_instance();

  void Swap(HistoricalPriceDataTickRecordResponse* other);

  // implements Message ----------------------------------------------

  HistoricalPriceDataTickRecordResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoricalPriceDataTickRecordResponse& from);
  void MergeFrom(const HistoricalPriceDataTickRecordResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional double DateTime = 2;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDateTimeFieldNumber = 2;
  inline double datetime() const;
  inline void set_datetime(double value);

  // optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 3;
  inline bool has_atbidorask() const;
  inline void clear_atbidorask();
  static const int kAtBidOrAskFieldNumber = 3;
  inline ::DTC_PB::AtBidOrAskEnum atbidorask() const;
  inline void set_atbidorask(::DTC_PB::AtBidOrAskEnum value);

  // optional double Price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline double price() const;
  inline void set_price(double value);

  // optional double Volume = 5;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 5;
  inline double volume() const;
  inline void set_volume(double value);

  // optional uint32 IsFinalRecord = 6;
  inline bool has_isfinalrecord() const;
  inline void clear_isfinalrecord();
  static const int kIsFinalRecordFieldNumber = 6;
  inline ::google::protobuf::uint32 isfinalrecord() const;
  inline void set_isfinalrecord(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalPriceDataTickRecordResponse)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_datetime();
  inline void clear_has_datetime();
  inline void set_has_atbidorask();
  inline void clear_has_atbidorask();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_isfinalrecord();
  inline void clear_has_isfinalrecord();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double datetime_;
  ::google::protobuf::int32 requestid_;
  int atbidorask_;
  double price_;
  double volume_;
  ::google::protobuf::uint32 isfinalrecord_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static HistoricalPriceDataTickRecordResponse* default_instance_;
};
// -------------------------------------------------------------------

class HistoricalPriceDataRecordResponse_Int : public ::google::protobuf::Message {
 public:
  HistoricalPriceDataRecordResponse_Int();
  virtual ~HistoricalPriceDataRecordResponse_Int();

  HistoricalPriceDataRecordResponse_Int(const HistoricalPriceDataRecordResponse_Int& from);

  inline HistoricalPriceDataRecordResponse_Int& operator=(const HistoricalPriceDataRecordResponse_Int& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalPriceDataRecordResponse_Int& default_instance();

  void Swap(HistoricalPriceDataRecordResponse_Int* other);

  // implements Message ----------------------------------------------

  HistoricalPriceDataRecordResponse_Int* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoricalPriceDataRecordResponse_Int& from);
  void MergeFrom(const HistoricalPriceDataRecordResponse_Int& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional sfixed64 StartDateTime = 2;
  inline bool has_startdatetime() const;
  inline void clear_startdatetime();
  static const int kStartDateTimeFieldNumber = 2;
  inline ::google::protobuf::int64 startdatetime() const;
  inline void set_startdatetime(::google::protobuf::int64 value);

  // optional int32 OpenPrice = 3;
  inline bool has_openprice() const;
  inline void clear_openprice();
  static const int kOpenPriceFieldNumber = 3;
  inline ::google::protobuf::int32 openprice() const;
  inline void set_openprice(::google::protobuf::int32 value);

  // optional int32 HighPrice = 4;
  inline bool has_highprice() const;
  inline void clear_highprice();
  static const int kHighPriceFieldNumber = 4;
  inline ::google::protobuf::int32 highprice() const;
  inline void set_highprice(::google::protobuf::int32 value);

  // optional int32 LowPrice = 5;
  inline bool has_lowprice() const;
  inline void clear_lowprice();
  static const int kLowPriceFieldNumber = 5;
  inline ::google::protobuf::int32 lowprice() const;
  inline void set_lowprice(::google::protobuf::int32 value);

  // optional int32 LastPrice = 6;
  inline bool has_lastprice() const;
  inline void clear_lastprice();
  static const int kLastPriceFieldNumber = 6;
  inline ::google::protobuf::int32 lastprice() const;
  inline void set_lastprice(::google::protobuf::int32 value);

  // optional int32 Volume = 7;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 7;
  inline ::google::protobuf::int32 volume() const;
  inline void set_volume(::google::protobuf::int32 value);

  // optional uint32 NumTrades = 8;
  inline bool has_numtrades() const;
  inline void clear_numtrades();
  static const int kNumTradesFieldNumber = 8;
  inline ::google::protobuf::uint32 numtrades() const;
  inline void set_numtrades(::google::protobuf::uint32 value);

  // optional int32 BidVolume = 9;
  inline bool has_bidvolume() const;
  inline void clear_bidvolume();
  static const int kBidVolumeFieldNumber = 9;
  inline ::google::protobuf::int32 bidvolume() const;
  inline void set_bidvolume(::google::protobuf::int32 value);

  // optional int32 AskVolume = 10;
  inline bool has_askvolume() const;
  inline void clear_askvolume();
  static const int kAskVolumeFieldNumber = 10;
  inline ::google::protobuf::int32 askvolume() const;
  inline void set_askvolume(::google::protobuf::int32 value);

  // optional uint32 IsFinalRecord = 11;
  inline bool has_isfinalrecord() const;
  inline void clear_isfinalrecord();
  static const int kIsFinalRecordFieldNumber = 11;
  inline ::google::protobuf::uint32 isfinalrecord() const;
  inline void set_isfinalrecord(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalPriceDataRecordResponse_Int)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_startdatetime();
  inline void clear_has_startdatetime();
  inline void set_has_openprice();
  inline void clear_has_openprice();
  inline void set_has_highprice();
  inline void clear_has_highprice();
  inline void set_has_lowprice();
  inline void clear_has_lowprice();
  inline void set_has_lastprice();
  inline void clear_has_lastprice();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_numtrades();
  inline void clear_has_numtrades();
  inline void set_has_bidvolume();
  inline void clear_has_bidvolume();
  inline void set_has_askvolume();
  inline void clear_has_askvolume();
  inline void set_has_isfinalrecord();
  inline void clear_has_isfinalrecord();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 startdatetime_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 openprice_;
  ::google::protobuf::int32 highprice_;
  ::google::protobuf::int32 lowprice_;
  ::google::protobuf::int32 lastprice_;
  ::google::protobuf::int32 volume_;
  ::google::protobuf::uint32 numtrades_;
  ::google::protobuf::int32 bidvolume_;
  ::google::protobuf::int32 askvolume_;
  ::google::protobuf::uint32 isfinalrecord_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static HistoricalPriceDataRecordResponse_Int* default_instance_;
};
// -------------------------------------------------------------------

class HistoricalPriceDataTickRecordResponse_Int : public ::google::protobuf::Message {
 public:
  HistoricalPriceDataTickRecordResponse_Int();
  virtual ~HistoricalPriceDataTickRecordResponse_Int();

  HistoricalPriceDataTickRecordResponse_Int(const HistoricalPriceDataTickRecordResponse_Int& from);

  inline HistoricalPriceDataTickRecordResponse_Int& operator=(const HistoricalPriceDataTickRecordResponse_Int& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalPriceDataTickRecordResponse_Int& default_instance();

  void Swap(HistoricalPriceDataTickRecordResponse_Int* other);

  // implements Message ----------------------------------------------

  HistoricalPriceDataTickRecordResponse_Int* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoricalPriceDataTickRecordResponse_Int& from);
  void MergeFrom(const HistoricalPriceDataTickRecordResponse_Int& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional double DateTime = 2;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDateTimeFieldNumber = 2;
  inline double datetime() const;
  inline void set_datetime(double value);

  // optional int32 Price = 3;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 3;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional int32 Volume = 4;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 4;
  inline ::google::protobuf::int32 volume() const;
  inline void set_volume(::google::protobuf::int32 value);

  // optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 5;
  inline bool has_atbidorask() const;
  inline void clear_atbidorask();
  static const int kAtBidOrAskFieldNumber = 5;
  inline ::DTC_PB::AtBidOrAskEnum atbidorask() const;
  inline void set_atbidorask(::DTC_PB::AtBidOrAskEnum value);

  // optional uint32 IsFinalRecord = 6;
  inline bool has_isfinalrecord() const;
  inline void clear_isfinalrecord();
  static const int kIsFinalRecordFieldNumber = 6;
  inline ::google::protobuf::uint32 isfinalrecord() const;
  inline void set_isfinalrecord(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalPriceDataTickRecordResponse_Int)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_datetime();
  inline void clear_has_datetime();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_atbidorask();
  inline void clear_has_atbidorask();
  inline void set_has_isfinalrecord();
  inline void clear_has_isfinalrecord();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double datetime_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 volume_;
  int atbidorask_;
  ::google::protobuf::uint32 isfinalrecord_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static HistoricalPriceDataTickRecordResponse_Int* default_instance_;
};
// -------------------------------------------------------------------

class HistoricalPriceDataResponseTrailer : public ::google::protobuf::Message {
 public:
  HistoricalPriceDataResponseTrailer();
  virtual ~HistoricalPriceDataResponseTrailer();

  HistoricalPriceDataResponseTrailer(const HistoricalPriceDataResponseTrailer& from);

  inline HistoricalPriceDataResponseTrailer& operator=(const HistoricalPriceDataResponseTrailer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoricalPriceDataResponseTrailer& default_instance();

  void Swap(HistoricalPriceDataResponseTrailer* other);

  // implements Message ----------------------------------------------

  HistoricalPriceDataResponseTrailer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoricalPriceDataResponseTrailer& from);
  void MergeFrom(const HistoricalPriceDataResponseTrailer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 RequestID = 1;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 1;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);

  // optional double FinalRecordLastDateTime = 2;
  inline bool has_finalrecordlastdatetime() const;
  inline void clear_finalrecordlastdatetime();
  static const int kFinalRecordLastDateTimeFieldNumber = 2;
  inline double finalrecordlastdatetime() const;
  inline void set_finalrecordlastdatetime(double value);

  // @@protoc_insertion_point(class_scope:DTC_PB.HistoricalPriceDataResponseTrailer)
 private:
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_finalrecordlastdatetime();
  inline void clear_has_finalrecordlastdatetime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double finalrecordlastdatetime_;
  ::google::protobuf::int32 requestid_;
  friend void  protobuf_AddDesc_DTCProtocol_2eproto();
  friend void protobuf_AssignDesc_DTCProtocol_2eproto();
  friend void protobuf_ShutdownFile_DTCProtocol_2eproto();

  void InitAsDefaultInstance();
  static HistoricalPriceDataResponseTrailer* default_instance_;
};
// ===================================================================


// ===================================================================

// EncodingRequest

// optional int32 ProtocolVersion = 1;
inline bool EncodingRequest::has_protocolversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncodingRequest::set_has_protocolversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncodingRequest::clear_has_protocolversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncodingRequest::clear_protocolversion() {
  protocolversion_ = 0;
  clear_has_protocolversion();
}
inline ::google::protobuf::int32 EncodingRequest::protocolversion() const {
  // @@protoc_insertion_point(field_get:DTC_PB.EncodingRequest.ProtocolVersion)
  return protocolversion_;
}
inline void EncodingRequest::set_protocolversion(::google::protobuf::int32 value) {
  set_has_protocolversion();
  protocolversion_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.EncodingRequest.ProtocolVersion)
}

// optional .DTC_PB.EncodingEnum Encoding = 2;
inline bool EncodingRequest::has_encoding() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EncodingRequest::set_has_encoding() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EncodingRequest::clear_has_encoding() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EncodingRequest::clear_encoding() {
  encoding_ = 0;
  clear_has_encoding();
}
inline ::DTC_PB::EncodingEnum EncodingRequest::encoding() const {
  // @@protoc_insertion_point(field_get:DTC_PB.EncodingRequest.Encoding)
  return static_cast< ::DTC_PB::EncodingEnum >(encoding_);
}
inline void EncodingRequest::set_encoding(::DTC_PB::EncodingEnum value) {
  assert(::DTC_PB::EncodingEnum_IsValid(value));
  set_has_encoding();
  encoding_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.EncodingRequest.Encoding)
}

// -------------------------------------------------------------------

// EncodingResponse

// optional int32 ProtocolVersion = 1;
inline bool EncodingResponse::has_protocolversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncodingResponse::set_has_protocolversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncodingResponse::clear_has_protocolversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncodingResponse::clear_protocolversion() {
  protocolversion_ = 0;
  clear_has_protocolversion();
}
inline ::google::protobuf::int32 EncodingResponse::protocolversion() const {
  // @@protoc_insertion_point(field_get:DTC_PB.EncodingResponse.ProtocolVersion)
  return protocolversion_;
}
inline void EncodingResponse::set_protocolversion(::google::protobuf::int32 value) {
  set_has_protocolversion();
  protocolversion_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.EncodingResponse.ProtocolVersion)
}

// optional .DTC_PB.EncodingEnum Encoding = 2;
inline bool EncodingResponse::has_encoding() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EncodingResponse::set_has_encoding() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EncodingResponse::clear_has_encoding() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EncodingResponse::clear_encoding() {
  encoding_ = 0;
  clear_has_encoding();
}
inline ::DTC_PB::EncodingEnum EncodingResponse::encoding() const {
  // @@protoc_insertion_point(field_get:DTC_PB.EncodingResponse.Encoding)
  return static_cast< ::DTC_PB::EncodingEnum >(encoding_);
}
inline void EncodingResponse::set_encoding(::DTC_PB::EncodingEnum value) {
  assert(::DTC_PB::EncodingEnum_IsValid(value));
  set_has_encoding();
  encoding_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.EncodingResponse.Encoding)
}

// -------------------------------------------------------------------

// LogonRequest

// optional int32 ProtocolVersion = 1;
inline bool LogonRequest::has_protocolversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogonRequest::set_has_protocolversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogonRequest::clear_has_protocolversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogonRequest::clear_protocolversion() {
  protocolversion_ = 0;
  clear_has_protocolversion();
}
inline ::google::protobuf::int32 LogonRequest::protocolversion() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.ProtocolVersion)
  return protocolversion_;
}
inline void LogonRequest::set_protocolversion(::google::protobuf::int32 value) {
  set_has_protocolversion();
  protocolversion_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.ProtocolVersion)
}

// optional string Username = 2;
inline bool LogonRequest::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogonRequest::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogonRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogonRequest::clear_username() {
  if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& LogonRequest::username() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.Username)
  return *username_;
}
inline void LogonRequest::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.Username)
}
inline void LogonRequest::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonRequest.Username)
}
inline void LogonRequest::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonRequest.Username)
}
inline ::std::string* LogonRequest::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonRequest.Username)
  return username_;
}
inline ::std::string* LogonRequest::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogonRequest::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonRequest.Username)
}

// optional string Password = 3;
inline bool LogonRequest::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogonRequest::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogonRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogonRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LogonRequest::password() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.Password)
  return *password_;
}
inline void LogonRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.Password)
}
inline void LogonRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonRequest.Password)
}
inline void LogonRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonRequest.Password)
}
inline ::std::string* LogonRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonRequest.Password)
  return password_;
}
inline ::std::string* LogonRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogonRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonRequest.Password)
}

// optional string GeneralTextData = 4;
inline bool LogonRequest::has_generaltextdata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogonRequest::set_has_generaltextdata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogonRequest::clear_has_generaltextdata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogonRequest::clear_generaltextdata() {
  if (generaltextdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    generaltextdata_->clear();
  }
  clear_has_generaltextdata();
}
inline const ::std::string& LogonRequest::generaltextdata() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.GeneralTextData)
  return *generaltextdata_;
}
inline void LogonRequest::set_generaltextdata(const ::std::string& value) {
  set_has_generaltextdata();
  if (generaltextdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    generaltextdata_ = new ::std::string;
  }
  generaltextdata_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.GeneralTextData)
}
inline void LogonRequest::set_generaltextdata(const char* value) {
  set_has_generaltextdata();
  if (generaltextdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    generaltextdata_ = new ::std::string;
  }
  generaltextdata_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonRequest.GeneralTextData)
}
inline void LogonRequest::set_generaltextdata(const char* value, size_t size) {
  set_has_generaltextdata();
  if (generaltextdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    generaltextdata_ = new ::std::string;
  }
  generaltextdata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonRequest.GeneralTextData)
}
inline ::std::string* LogonRequest::mutable_generaltextdata() {
  set_has_generaltextdata();
  if (generaltextdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    generaltextdata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonRequest.GeneralTextData)
  return generaltextdata_;
}
inline ::std::string* LogonRequest::release_generaltextdata() {
  clear_has_generaltextdata();
  if (generaltextdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = generaltextdata_;
    generaltextdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogonRequest::set_allocated_generaltextdata(::std::string* generaltextdata) {
  if (generaltextdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete generaltextdata_;
  }
  if (generaltextdata) {
    set_has_generaltextdata();
    generaltextdata_ = generaltextdata;
  } else {
    clear_has_generaltextdata();
    generaltextdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonRequest.GeneralTextData)
}

// optional int32 Integer_1 = 5;
inline bool LogonRequest::has_integer_1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogonRequest::set_has_integer_1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogonRequest::clear_has_integer_1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogonRequest::clear_integer_1() {
  integer_1_ = 0;
  clear_has_integer_1();
}
inline ::google::protobuf::int32 LogonRequest::integer_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.Integer_1)
  return integer_1_;
}
inline void LogonRequest::set_integer_1(::google::protobuf::int32 value) {
  set_has_integer_1();
  integer_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.Integer_1)
}

// optional int32 Integer_2 = 6;
inline bool LogonRequest::has_integer_2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LogonRequest::set_has_integer_2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LogonRequest::clear_has_integer_2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LogonRequest::clear_integer_2() {
  integer_2_ = 0;
  clear_has_integer_2();
}
inline ::google::protobuf::int32 LogonRequest::integer_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.Integer_2)
  return integer_2_;
}
inline void LogonRequest::set_integer_2(::google::protobuf::int32 value) {
  set_has_integer_2();
  integer_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.Integer_2)
}

// optional int32 HeartbeatIntervalInSeconds = 7;
inline bool LogonRequest::has_heartbeatintervalinseconds() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LogonRequest::set_has_heartbeatintervalinseconds() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LogonRequest::clear_has_heartbeatintervalinseconds() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LogonRequest::clear_heartbeatintervalinseconds() {
  heartbeatintervalinseconds_ = 0;
  clear_has_heartbeatintervalinseconds();
}
inline ::google::protobuf::int32 LogonRequest::heartbeatintervalinseconds() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.HeartbeatIntervalInSeconds)
  return heartbeatintervalinseconds_;
}
inline void LogonRequest::set_heartbeatintervalinseconds(::google::protobuf::int32 value) {
  set_has_heartbeatintervalinseconds();
  heartbeatintervalinseconds_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.HeartbeatIntervalInSeconds)
}

// optional .DTC_PB.TradeModeEnum TradeMode = 8;
inline bool LogonRequest::has_trademode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LogonRequest::set_has_trademode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LogonRequest::clear_has_trademode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LogonRequest::clear_trademode() {
  trademode_ = 1;
  clear_has_trademode();
}
inline ::DTC_PB::TradeModeEnum LogonRequest::trademode() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.TradeMode)
  return static_cast< ::DTC_PB::TradeModeEnum >(trademode_);
}
inline void LogonRequest::set_trademode(::DTC_PB::TradeModeEnum value) {
  assert(::DTC_PB::TradeModeEnum_IsValid(value));
  set_has_trademode();
  trademode_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.TradeMode)
}

// optional string TradeAccount = 9;
inline bool LogonRequest::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LogonRequest::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LogonRequest::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LogonRequest::clear_tradeaccount() {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_->clear();
  }
  clear_has_tradeaccount();
}
inline const ::std::string& LogonRequest::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.TradeAccount)
  return *tradeaccount_;
}
inline void LogonRequest::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.TradeAccount)
}
inline void LogonRequest::set_tradeaccount(const char* value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonRequest.TradeAccount)
}
inline void LogonRequest::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonRequest.TradeAccount)
}
inline ::std::string* LogonRequest::mutable_tradeaccount() {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonRequest.TradeAccount)
  return tradeaccount_;
}
inline ::std::string* LogonRequest::release_tradeaccount() {
  clear_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tradeaccount_;
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogonRequest::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tradeaccount_;
  }
  if (tradeaccount) {
    set_has_tradeaccount();
    tradeaccount_ = tradeaccount;
  } else {
    clear_has_tradeaccount();
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonRequest.TradeAccount)
}

// optional string HardwareIdentifier = 10;
inline bool LogonRequest::has_hardwareidentifier() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LogonRequest::set_has_hardwareidentifier() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LogonRequest::clear_has_hardwareidentifier() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LogonRequest::clear_hardwareidentifier() {
  if (hardwareidentifier_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardwareidentifier_->clear();
  }
  clear_has_hardwareidentifier();
}
inline const ::std::string& LogonRequest::hardwareidentifier() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.HardwareIdentifier)
  return *hardwareidentifier_;
}
inline void LogonRequest::set_hardwareidentifier(const ::std::string& value) {
  set_has_hardwareidentifier();
  if (hardwareidentifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardwareidentifier_ = new ::std::string;
  }
  hardwareidentifier_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.HardwareIdentifier)
}
inline void LogonRequest::set_hardwareidentifier(const char* value) {
  set_has_hardwareidentifier();
  if (hardwareidentifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardwareidentifier_ = new ::std::string;
  }
  hardwareidentifier_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonRequest.HardwareIdentifier)
}
inline void LogonRequest::set_hardwareidentifier(const char* value, size_t size) {
  set_has_hardwareidentifier();
  if (hardwareidentifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardwareidentifier_ = new ::std::string;
  }
  hardwareidentifier_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonRequest.HardwareIdentifier)
}
inline ::std::string* LogonRequest::mutable_hardwareidentifier() {
  set_has_hardwareidentifier();
  if (hardwareidentifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardwareidentifier_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonRequest.HardwareIdentifier)
  return hardwareidentifier_;
}
inline ::std::string* LogonRequest::release_hardwareidentifier() {
  clear_has_hardwareidentifier();
  if (hardwareidentifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hardwareidentifier_;
    hardwareidentifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogonRequest::set_allocated_hardwareidentifier(::std::string* hardwareidentifier) {
  if (hardwareidentifier_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hardwareidentifier_;
  }
  if (hardwareidentifier) {
    set_has_hardwareidentifier();
    hardwareidentifier_ = hardwareidentifier;
  } else {
    clear_has_hardwareidentifier();
    hardwareidentifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonRequest.HardwareIdentifier)
}

// optional string ClientName = 11;
inline bool LogonRequest::has_clientname() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LogonRequest::set_has_clientname() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LogonRequest::clear_has_clientname() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LogonRequest::clear_clientname() {
  if (clientname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientname_->clear();
  }
  clear_has_clientname();
}
inline const ::std::string& LogonRequest::clientname() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonRequest.ClientName)
  return *clientname_;
}
inline void LogonRequest::set_clientname(const ::std::string& value) {
  set_has_clientname();
  if (clientname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientname_ = new ::std::string;
  }
  clientname_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonRequest.ClientName)
}
inline void LogonRequest::set_clientname(const char* value) {
  set_has_clientname();
  if (clientname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientname_ = new ::std::string;
  }
  clientname_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonRequest.ClientName)
}
inline void LogonRequest::set_clientname(const char* value, size_t size) {
  set_has_clientname();
  if (clientname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientname_ = new ::std::string;
  }
  clientname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonRequest.ClientName)
}
inline ::std::string* LogonRequest::mutable_clientname() {
  set_has_clientname();
  if (clientname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonRequest.ClientName)
  return clientname_;
}
inline ::std::string* LogonRequest::release_clientname() {
  clear_has_clientname();
  if (clientname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientname_;
    clientname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogonRequest::set_allocated_clientname(::std::string* clientname) {
  if (clientname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientname_;
  }
  if (clientname) {
    set_has_clientname();
    clientname_ = clientname;
  } else {
    clear_has_clientname();
    clientname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonRequest.ClientName)
}

// -------------------------------------------------------------------

// LogonResponse

// optional int32 ProtocolVersion = 1;
inline bool LogonResponse::has_protocolversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogonResponse::set_has_protocolversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogonResponse::clear_has_protocolversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogonResponse::clear_protocolversion() {
  protocolversion_ = 0;
  clear_has_protocolversion();
}
inline ::google::protobuf::int32 LogonResponse::protocolversion() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.ProtocolVersion)
  return protocolversion_;
}
inline void LogonResponse::set_protocolversion(::google::protobuf::int32 value) {
  set_has_protocolversion();
  protocolversion_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.ProtocolVersion)
}

// optional .DTC_PB.LogonStatusEnum Result = 2;
inline bool LogonResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogonResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogonResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogonResponse::clear_result() {
  result_ = 1;
  clear_has_result();
}
inline ::DTC_PB::LogonStatusEnum LogonResponse::result() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.Result)
  return static_cast< ::DTC_PB::LogonStatusEnum >(result_);
}
inline void LogonResponse::set_result(::DTC_PB::LogonStatusEnum value) {
  assert(::DTC_PB::LogonStatusEnum_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.Result)
}

// optional string ResultText = 3;
inline bool LogonResponse::has_resulttext() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogonResponse::set_has_resulttext() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogonResponse::clear_has_resulttext() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogonResponse::clear_resulttext() {
  if (resulttext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resulttext_->clear();
  }
  clear_has_resulttext();
}
inline const ::std::string& LogonResponse::resulttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.ResultText)
  return *resulttext_;
}
inline void LogonResponse::set_resulttext(const ::std::string& value) {
  set_has_resulttext();
  if (resulttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resulttext_ = new ::std::string;
  }
  resulttext_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.ResultText)
}
inline void LogonResponse::set_resulttext(const char* value) {
  set_has_resulttext();
  if (resulttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resulttext_ = new ::std::string;
  }
  resulttext_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonResponse.ResultText)
}
inline void LogonResponse::set_resulttext(const char* value, size_t size) {
  set_has_resulttext();
  if (resulttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resulttext_ = new ::std::string;
  }
  resulttext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonResponse.ResultText)
}
inline ::std::string* LogonResponse::mutable_resulttext() {
  set_has_resulttext();
  if (resulttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    resulttext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonResponse.ResultText)
  return resulttext_;
}
inline ::std::string* LogonResponse::release_resulttext() {
  clear_has_resulttext();
  if (resulttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = resulttext_;
    resulttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogonResponse::set_allocated_resulttext(::std::string* resulttext) {
  if (resulttext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete resulttext_;
  }
  if (resulttext) {
    set_has_resulttext();
    resulttext_ = resulttext;
  } else {
    clear_has_resulttext();
    resulttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonResponse.ResultText)
}

// optional string ReconnectAddress = 4;
inline bool LogonResponse::has_reconnectaddress() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogonResponse::set_has_reconnectaddress() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogonResponse::clear_has_reconnectaddress() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogonResponse::clear_reconnectaddress() {
  if (reconnectaddress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reconnectaddress_->clear();
  }
  clear_has_reconnectaddress();
}
inline const ::std::string& LogonResponse::reconnectaddress() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.ReconnectAddress)
  return *reconnectaddress_;
}
inline void LogonResponse::set_reconnectaddress(const ::std::string& value) {
  set_has_reconnectaddress();
  if (reconnectaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reconnectaddress_ = new ::std::string;
  }
  reconnectaddress_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.ReconnectAddress)
}
inline void LogonResponse::set_reconnectaddress(const char* value) {
  set_has_reconnectaddress();
  if (reconnectaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reconnectaddress_ = new ::std::string;
  }
  reconnectaddress_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonResponse.ReconnectAddress)
}
inline void LogonResponse::set_reconnectaddress(const char* value, size_t size) {
  set_has_reconnectaddress();
  if (reconnectaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reconnectaddress_ = new ::std::string;
  }
  reconnectaddress_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonResponse.ReconnectAddress)
}
inline ::std::string* LogonResponse::mutable_reconnectaddress() {
  set_has_reconnectaddress();
  if (reconnectaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reconnectaddress_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonResponse.ReconnectAddress)
  return reconnectaddress_;
}
inline ::std::string* LogonResponse::release_reconnectaddress() {
  clear_has_reconnectaddress();
  if (reconnectaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = reconnectaddress_;
    reconnectaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogonResponse::set_allocated_reconnectaddress(::std::string* reconnectaddress) {
  if (reconnectaddress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete reconnectaddress_;
  }
  if (reconnectaddress) {
    set_has_reconnectaddress();
    reconnectaddress_ = reconnectaddress;
  } else {
    clear_has_reconnectaddress();
    reconnectaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonResponse.ReconnectAddress)
}

// optional int32 Integer_1 = 5;
inline bool LogonResponse::has_integer_1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogonResponse::set_has_integer_1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogonResponse::clear_has_integer_1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogonResponse::clear_integer_1() {
  integer_1_ = 0;
  clear_has_integer_1();
}
inline ::google::protobuf::int32 LogonResponse::integer_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.Integer_1)
  return integer_1_;
}
inline void LogonResponse::set_integer_1(::google::protobuf::int32 value) {
  set_has_integer_1();
  integer_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.Integer_1)
}

// optional string ServerName = 6;
inline bool LogonResponse::has_servername() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LogonResponse::set_has_servername() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LogonResponse::clear_has_servername() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LogonResponse::clear_servername() {
  if (servername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& LogonResponse::servername() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.ServerName)
  return *servername_;
}
inline void LogonResponse::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.ServerName)
}
inline void LogonResponse::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonResponse.ServerName)
}
inline void LogonResponse::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonResponse.ServerName)
}
inline ::std::string* LogonResponse::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    servername_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonResponse.ServerName)
  return servername_;
}
inline ::std::string* LogonResponse::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogonResponse::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonResponse.ServerName)
}

// optional uint32 MarketDepthUpdatesBestBidAndAsk = 7;
inline bool LogonResponse::has_marketdepthupdatesbestbidandask() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LogonResponse::set_has_marketdepthupdatesbestbidandask() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LogonResponse::clear_has_marketdepthupdatesbestbidandask() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LogonResponse::clear_marketdepthupdatesbestbidandask() {
  marketdepthupdatesbestbidandask_ = 0u;
  clear_has_marketdepthupdatesbestbidandask();
}
inline ::google::protobuf::uint32 LogonResponse::marketdepthupdatesbestbidandask() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.MarketDepthUpdatesBestBidAndAsk)
  return marketdepthupdatesbestbidandask_;
}
inline void LogonResponse::set_marketdepthupdatesbestbidandask(::google::protobuf::uint32 value) {
  set_has_marketdepthupdatesbestbidandask();
  marketdepthupdatesbestbidandask_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.MarketDepthUpdatesBestBidAndAsk)
}

// optional uint32 TradingIsSupported = 8;
inline bool LogonResponse::has_tradingissupported() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LogonResponse::set_has_tradingissupported() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LogonResponse::clear_has_tradingissupported() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LogonResponse::clear_tradingissupported() {
  tradingissupported_ = 0u;
  clear_has_tradingissupported();
}
inline ::google::protobuf::uint32 LogonResponse::tradingissupported() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.TradingIsSupported)
  return tradingissupported_;
}
inline void LogonResponse::set_tradingissupported(::google::protobuf::uint32 value) {
  set_has_tradingissupported();
  tradingissupported_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.TradingIsSupported)
}

// optional uint32 OCOOrdersSupported = 9;
inline bool LogonResponse::has_ocoorderssupported() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LogonResponse::set_has_ocoorderssupported() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LogonResponse::clear_has_ocoorderssupported() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LogonResponse::clear_ocoorderssupported() {
  ocoorderssupported_ = 0u;
  clear_has_ocoorderssupported();
}
inline ::google::protobuf::uint32 LogonResponse::ocoorderssupported() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.OCOOrdersSupported)
  return ocoorderssupported_;
}
inline void LogonResponse::set_ocoorderssupported(::google::protobuf::uint32 value) {
  set_has_ocoorderssupported();
  ocoorderssupported_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.OCOOrdersSupported)
}

// optional uint32 OrderCancelReplaceSupported = 10;
inline bool LogonResponse::has_ordercancelreplacesupported() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LogonResponse::set_has_ordercancelreplacesupported() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LogonResponse::clear_has_ordercancelreplacesupported() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LogonResponse::clear_ordercancelreplacesupported() {
  ordercancelreplacesupported_ = 0u;
  clear_has_ordercancelreplacesupported();
}
inline ::google::protobuf::uint32 LogonResponse::ordercancelreplacesupported() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.OrderCancelReplaceSupported)
  return ordercancelreplacesupported_;
}
inline void LogonResponse::set_ordercancelreplacesupported(::google::protobuf::uint32 value) {
  set_has_ordercancelreplacesupported();
  ordercancelreplacesupported_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.OrderCancelReplaceSupported)
}

// optional string SymbolExchangeDelimiter = 11;
inline bool LogonResponse::has_symbolexchangedelimiter() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LogonResponse::set_has_symbolexchangedelimiter() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LogonResponse::clear_has_symbolexchangedelimiter() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LogonResponse::clear_symbolexchangedelimiter() {
  if (symbolexchangedelimiter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbolexchangedelimiter_->clear();
  }
  clear_has_symbolexchangedelimiter();
}
inline const ::std::string& LogonResponse::symbolexchangedelimiter() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.SymbolExchangeDelimiter)
  return *symbolexchangedelimiter_;
}
inline void LogonResponse::set_symbolexchangedelimiter(const ::std::string& value) {
  set_has_symbolexchangedelimiter();
  if (symbolexchangedelimiter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbolexchangedelimiter_ = new ::std::string;
  }
  symbolexchangedelimiter_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.SymbolExchangeDelimiter)
}
inline void LogonResponse::set_symbolexchangedelimiter(const char* value) {
  set_has_symbolexchangedelimiter();
  if (symbolexchangedelimiter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbolexchangedelimiter_ = new ::std::string;
  }
  symbolexchangedelimiter_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.LogonResponse.SymbolExchangeDelimiter)
}
inline void LogonResponse::set_symbolexchangedelimiter(const char* value, size_t size) {
  set_has_symbolexchangedelimiter();
  if (symbolexchangedelimiter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbolexchangedelimiter_ = new ::std::string;
  }
  symbolexchangedelimiter_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.LogonResponse.SymbolExchangeDelimiter)
}
inline ::std::string* LogonResponse::mutable_symbolexchangedelimiter() {
  set_has_symbolexchangedelimiter();
  if (symbolexchangedelimiter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbolexchangedelimiter_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.LogonResponse.SymbolExchangeDelimiter)
  return symbolexchangedelimiter_;
}
inline ::std::string* LogonResponse::release_symbolexchangedelimiter() {
  clear_has_symbolexchangedelimiter();
  if (symbolexchangedelimiter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = symbolexchangedelimiter_;
    symbolexchangedelimiter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LogonResponse::set_allocated_symbolexchangedelimiter(::std::string* symbolexchangedelimiter) {
  if (symbolexchangedelimiter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete symbolexchangedelimiter_;
  }
  if (symbolexchangedelimiter) {
    set_has_symbolexchangedelimiter();
    symbolexchangedelimiter_ = symbolexchangedelimiter;
  } else {
    clear_has_symbolexchangedelimiter();
    symbolexchangedelimiter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.LogonResponse.SymbolExchangeDelimiter)
}

// optional uint32 SecurityDefinitionsSupported = 12;
inline bool LogonResponse::has_securitydefinitionssupported() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LogonResponse::set_has_securitydefinitionssupported() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LogonResponse::clear_has_securitydefinitionssupported() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LogonResponse::clear_securitydefinitionssupported() {
  securitydefinitionssupported_ = 0u;
  clear_has_securitydefinitionssupported();
}
inline ::google::protobuf::uint32 LogonResponse::securitydefinitionssupported() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.SecurityDefinitionsSupported)
  return securitydefinitionssupported_;
}
inline void LogonResponse::set_securitydefinitionssupported(::google::protobuf::uint32 value) {
  set_has_securitydefinitionssupported();
  securitydefinitionssupported_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.SecurityDefinitionsSupported)
}

// optional uint32 HistoricalPriceDataSupported = 13;
inline bool LogonResponse::has_historicalpricedatasupported() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LogonResponse::set_has_historicalpricedatasupported() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LogonResponse::clear_has_historicalpricedatasupported() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LogonResponse::clear_historicalpricedatasupported() {
  historicalpricedatasupported_ = 0u;
  clear_has_historicalpricedatasupported();
}
inline ::google::protobuf::uint32 LogonResponse::historicalpricedatasupported() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.HistoricalPriceDataSupported)
  return historicalpricedatasupported_;
}
inline void LogonResponse::set_historicalpricedatasupported(::google::protobuf::uint32 value) {
  set_has_historicalpricedatasupported();
  historicalpricedatasupported_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.HistoricalPriceDataSupported)
}

// optional uint32 ResubscribeWhenMarketDataFeedAvailable = 14;
inline bool LogonResponse::has_resubscribewhenmarketdatafeedavailable() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LogonResponse::set_has_resubscribewhenmarketdatafeedavailable() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LogonResponse::clear_has_resubscribewhenmarketdatafeedavailable() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LogonResponse::clear_resubscribewhenmarketdatafeedavailable() {
  resubscribewhenmarketdatafeedavailable_ = 0u;
  clear_has_resubscribewhenmarketdatafeedavailable();
}
inline ::google::protobuf::uint32 LogonResponse::resubscribewhenmarketdatafeedavailable() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.ResubscribeWhenMarketDataFeedAvailable)
  return resubscribewhenmarketdatafeedavailable_;
}
inline void LogonResponse::set_resubscribewhenmarketdatafeedavailable(::google::protobuf::uint32 value) {
  set_has_resubscribewhenmarketdatafeedavailable();
  resubscribewhenmarketdatafeedavailable_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.ResubscribeWhenMarketDataFeedAvailable)
}

// optional uint32 MarketDepthIsSupported = 15;
inline bool LogonResponse::has_marketdepthissupported() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LogonResponse::set_has_marketdepthissupported() {
  _has_bits_[0] |= 0x00004000u;
}
inline void LogonResponse::clear_has_marketdepthissupported() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void LogonResponse::clear_marketdepthissupported() {
  marketdepthissupported_ = 0u;
  clear_has_marketdepthissupported();
}
inline ::google::protobuf::uint32 LogonResponse::marketdepthissupported() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.MarketDepthIsSupported)
  return marketdepthissupported_;
}
inline void LogonResponse::set_marketdepthissupported(::google::protobuf::uint32 value) {
  set_has_marketdepthissupported();
  marketdepthissupported_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.MarketDepthIsSupported)
}

// optional uint32 OneHistoricalPriceDataRequestPerConnection = 16;
inline bool LogonResponse::has_onehistoricalpricedatarequestperconnection() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void LogonResponse::set_has_onehistoricalpricedatarequestperconnection() {
  _has_bits_[0] |= 0x00008000u;
}
inline void LogonResponse::clear_has_onehistoricalpricedatarequestperconnection() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void LogonResponse::clear_onehistoricalpricedatarequestperconnection() {
  onehistoricalpricedatarequestperconnection_ = 0u;
  clear_has_onehistoricalpricedatarequestperconnection();
}
inline ::google::protobuf::uint32 LogonResponse::onehistoricalpricedatarequestperconnection() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.OneHistoricalPriceDataRequestPerConnection)
  return onehistoricalpricedatarequestperconnection_;
}
inline void LogonResponse::set_onehistoricalpricedatarequestperconnection(::google::protobuf::uint32 value) {
  set_has_onehistoricalpricedatarequestperconnection();
  onehistoricalpricedatarequestperconnection_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.OneHistoricalPriceDataRequestPerConnection)
}

// optional uint32 BracketOrdersSupported = 17;
inline bool LogonResponse::has_bracketorderssupported() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void LogonResponse::set_has_bracketorderssupported() {
  _has_bits_[0] |= 0x00010000u;
}
inline void LogonResponse::clear_has_bracketorderssupported() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void LogonResponse::clear_bracketorderssupported() {
  bracketorderssupported_ = 0u;
  clear_has_bracketorderssupported();
}
inline ::google::protobuf::uint32 LogonResponse::bracketorderssupported() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.BracketOrdersSupported)
  return bracketorderssupported_;
}
inline void LogonResponse::set_bracketorderssupported(::google::protobuf::uint32 value) {
  set_has_bracketorderssupported();
  bracketorderssupported_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.BracketOrdersSupported)
}

// optional uint32 UseIntegerPriceOrderMessages = 18;
inline bool LogonResponse::has_useintegerpriceordermessages() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void LogonResponse::set_has_useintegerpriceordermessages() {
  _has_bits_[0] |= 0x00020000u;
}
inline void LogonResponse::clear_has_useintegerpriceordermessages() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void LogonResponse::clear_useintegerpriceordermessages() {
  useintegerpriceordermessages_ = 0u;
  clear_has_useintegerpriceordermessages();
}
inline ::google::protobuf::uint32 LogonResponse::useintegerpriceordermessages() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.UseIntegerPriceOrderMessages)
  return useintegerpriceordermessages_;
}
inline void LogonResponse::set_useintegerpriceordermessages(::google::protobuf::uint32 value) {
  set_has_useintegerpriceordermessages();
  useintegerpriceordermessages_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.UseIntegerPriceOrderMessages)
}

// optional uint32 UsesMultiplePositionsPerSymbolAndTradeAccount = 19;
inline bool LogonResponse::has_usesmultiplepositionspersymbolandtradeaccount() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void LogonResponse::set_has_usesmultiplepositionspersymbolandtradeaccount() {
  _has_bits_[0] |= 0x00040000u;
}
inline void LogonResponse::clear_has_usesmultiplepositionspersymbolandtradeaccount() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void LogonResponse::clear_usesmultiplepositionspersymbolandtradeaccount() {
  usesmultiplepositionspersymbolandtradeaccount_ = 0u;
  clear_has_usesmultiplepositionspersymbolandtradeaccount();
}
inline ::google::protobuf::uint32 LogonResponse::usesmultiplepositionspersymbolandtradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.UsesMultiplePositionsPerSymbolAndTradeAccount)
  return usesmultiplepositionspersymbolandtradeaccount_;
}
inline void LogonResponse::set_usesmultiplepositionspersymbolandtradeaccount(::google::protobuf::uint32 value) {
  set_has_usesmultiplepositionspersymbolandtradeaccount();
  usesmultiplepositionspersymbolandtradeaccount_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.UsesMultiplePositionsPerSymbolAndTradeAccount)
}

// optional uint32 MarketDataSupported = 20;
inline bool LogonResponse::has_marketdatasupported() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void LogonResponse::set_has_marketdatasupported() {
  _has_bits_[0] |= 0x00080000u;
}
inline void LogonResponse::clear_has_marketdatasupported() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void LogonResponse::clear_marketdatasupported() {
  marketdatasupported_ = 0u;
  clear_has_marketdatasupported();
}
inline ::google::protobuf::uint32 LogonResponse::marketdatasupported() const {
  // @@protoc_insertion_point(field_get:DTC_PB.LogonResponse.MarketDataSupported)
  return marketdatasupported_;
}
inline void LogonResponse::set_marketdatasupported(::google::protobuf::uint32 value) {
  set_has_marketdatasupported();
  marketdatasupported_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.LogonResponse.MarketDataSupported)
}

// -------------------------------------------------------------------

// Logoff

// optional string Reason = 1;
inline bool Logoff::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Logoff::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Logoff::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Logoff::clear_reason() {
  if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& Logoff::reason() const {
  // @@protoc_insertion_point(field_get:DTC_PB.Logoff.Reason)
  return *reason_;
}
inline void Logoff::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.Logoff.Reason)
}
inline void Logoff::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.Logoff.Reason)
}
inline void Logoff::set_reason(const char* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.Logoff.Reason)
}
inline ::std::string* Logoff::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.Logoff.Reason)
  return reason_;
}
inline ::std::string* Logoff::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Logoff::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.Logoff.Reason)
}

// optional uint32 DoNotReconnect = 2;
inline bool Logoff::has_donotreconnect() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Logoff::set_has_donotreconnect() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Logoff::clear_has_donotreconnect() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Logoff::clear_donotreconnect() {
  donotreconnect_ = 0u;
  clear_has_donotreconnect();
}
inline ::google::protobuf::uint32 Logoff::donotreconnect() const {
  // @@protoc_insertion_point(field_get:DTC_PB.Logoff.DoNotReconnect)
  return donotreconnect_;
}
inline void Logoff::set_donotreconnect(::google::protobuf::uint32 value) {
  set_has_donotreconnect();
  donotreconnect_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.Logoff.DoNotReconnect)
}

// -------------------------------------------------------------------

// Heartbeat

// optional uint32 NumDroppedMessages = 1;
inline bool Heartbeat::has_numdroppedmessages() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Heartbeat::set_has_numdroppedmessages() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Heartbeat::clear_has_numdroppedmessages() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Heartbeat::clear_numdroppedmessages() {
  numdroppedmessages_ = 0u;
  clear_has_numdroppedmessages();
}
inline ::google::protobuf::uint32 Heartbeat::numdroppedmessages() const {
  // @@protoc_insertion_point(field_get:DTC_PB.Heartbeat.NumDroppedMessages)
  return numdroppedmessages_;
}
inline void Heartbeat::set_numdroppedmessages(::google::protobuf::uint32 value) {
  set_has_numdroppedmessages();
  numdroppedmessages_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.Heartbeat.NumDroppedMessages)
}

// optional sfixed64 CurrentDateTime = 2;
inline bool Heartbeat::has_currentdatetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Heartbeat::set_has_currentdatetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Heartbeat::clear_has_currentdatetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Heartbeat::clear_currentdatetime() {
  currentdatetime_ = GOOGLE_LONGLONG(0);
  clear_has_currentdatetime();
}
inline ::google::protobuf::int64 Heartbeat::currentdatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.Heartbeat.CurrentDateTime)
  return currentdatetime_;
}
inline void Heartbeat::set_currentdatetime(::google::protobuf::int64 value) {
  set_has_currentdatetime();
  currentdatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.Heartbeat.CurrentDateTime)
}

// -------------------------------------------------------------------

// MarketDataFeedStatus

// optional .DTC_PB.MarketDataFeedStatusEnum Status = 1;
inline bool MarketDataFeedStatus::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataFeedStatus::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataFeedStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataFeedStatus::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::DTC_PB::MarketDataFeedStatusEnum MarketDataFeedStatus::status() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataFeedStatus.Status)
  return static_cast< ::DTC_PB::MarketDataFeedStatusEnum >(status_);
}
inline void MarketDataFeedStatus::set_status(::DTC_PB::MarketDataFeedStatusEnum value) {
  assert(::DTC_PB::MarketDataFeedStatusEnum_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataFeedStatus.Status)
}

// -------------------------------------------------------------------

// MarketDataFeedSymbolStatus

// optional uint32 SymbolID = 1;
inline bool MarketDataFeedSymbolStatus::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataFeedSymbolStatus::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataFeedSymbolStatus::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataFeedSymbolStatus::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataFeedSymbolStatus::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataFeedSymbolStatus.SymbolID)
  return symbolid_;
}
inline void MarketDataFeedSymbolStatus::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataFeedSymbolStatus.SymbolID)
}

// optional .DTC_PB.MarketDataFeedStatusEnum Status = 2;
inline bool MarketDataFeedSymbolStatus::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataFeedSymbolStatus::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataFeedSymbolStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataFeedSymbolStatus::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::DTC_PB::MarketDataFeedStatusEnum MarketDataFeedSymbolStatus::status() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataFeedSymbolStatus.Status)
  return static_cast< ::DTC_PB::MarketDataFeedStatusEnum >(status_);
}
inline void MarketDataFeedSymbolStatus::set_status(::DTC_PB::MarketDataFeedStatusEnum value) {
  assert(::DTC_PB::MarketDataFeedStatusEnum_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataFeedSymbolStatus.Status)
}

// -------------------------------------------------------------------

// MarketDataRequest

// optional .DTC_PB.RequestActionEnum RequestAction = 1;
inline bool MarketDataRequest::has_requestaction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataRequest::set_has_requestaction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataRequest::clear_has_requestaction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataRequest::clear_requestaction() {
  requestaction_ = 1;
  clear_has_requestaction();
}
inline ::DTC_PB::RequestActionEnum MarketDataRequest::requestaction() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataRequest.RequestAction)
  return static_cast< ::DTC_PB::RequestActionEnum >(requestaction_);
}
inline void MarketDataRequest::set_requestaction(::DTC_PB::RequestActionEnum value) {
  assert(::DTC_PB::RequestActionEnum_IsValid(value));
  set_has_requestaction();
  requestaction_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataRequest.RequestAction)
}

// optional uint32 SymbolID = 2;
inline bool MarketDataRequest::has_symbolid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataRequest::set_has_symbolid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataRequest::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataRequest::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataRequest::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataRequest.SymbolID)
  return symbolid_;
}
inline void MarketDataRequest::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataRequest.SymbolID)
}

// optional string Symbol = 3;
inline bool MarketDataRequest::has_symbol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataRequest::set_has_symbol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataRequest::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataRequest::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& MarketDataRequest::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataRequest.Symbol)
  return *symbol_;
}
inline void MarketDataRequest::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataRequest.Symbol)
}
inline void MarketDataRequest::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.MarketDataRequest.Symbol)
}
inline void MarketDataRequest::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.MarketDataRequest.Symbol)
}
inline ::std::string* MarketDataRequest::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDataRequest.Symbol)
  return symbol_;
}
inline ::std::string* MarketDataRequest::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MarketDataRequest::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.MarketDataRequest.Symbol)
}

// optional string Exchange = 4;
inline bool MarketDataRequest::has_exchange() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataRequest::set_has_exchange() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataRequest::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataRequest::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& MarketDataRequest::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataRequest.Exchange)
  return *exchange_;
}
inline void MarketDataRequest::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataRequest.Exchange)
}
inline void MarketDataRequest::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.MarketDataRequest.Exchange)
}
inline void MarketDataRequest::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.MarketDataRequest.Exchange)
}
inline ::std::string* MarketDataRequest::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDataRequest.Exchange)
  return exchange_;
}
inline ::std::string* MarketDataRequest::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MarketDataRequest::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.MarketDataRequest.Exchange)
}

// -------------------------------------------------------------------

// MarketDepthRequest

// optional .DTC_PB.RequestActionEnum RequestAction = 1;
inline bool MarketDepthRequest::has_requestaction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDepthRequest::set_has_requestaction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDepthRequest::clear_has_requestaction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDepthRequest::clear_requestaction() {
  requestaction_ = 1;
  clear_has_requestaction();
}
inline ::DTC_PB::RequestActionEnum MarketDepthRequest::requestaction() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthRequest.RequestAction)
  return static_cast< ::DTC_PB::RequestActionEnum >(requestaction_);
}
inline void MarketDepthRequest::set_requestaction(::DTC_PB::RequestActionEnum value) {
  assert(::DTC_PB::RequestActionEnum_IsValid(value));
  set_has_requestaction();
  requestaction_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthRequest.RequestAction)
}

// optional uint32 SymbolID = 2;
inline bool MarketDepthRequest::has_symbolid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDepthRequest::set_has_symbolid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDepthRequest::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDepthRequest::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDepthRequest::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthRequest.SymbolID)
  return symbolid_;
}
inline void MarketDepthRequest::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthRequest.SymbolID)
}

// optional string Symbol = 3;
inline bool MarketDepthRequest::has_symbol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDepthRequest::set_has_symbol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDepthRequest::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDepthRequest::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& MarketDepthRequest::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthRequest.Symbol)
  return *symbol_;
}
inline void MarketDepthRequest::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthRequest.Symbol)
}
inline void MarketDepthRequest::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.MarketDepthRequest.Symbol)
}
inline void MarketDepthRequest::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.MarketDepthRequest.Symbol)
}
inline ::std::string* MarketDepthRequest::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDepthRequest.Symbol)
  return symbol_;
}
inline ::std::string* MarketDepthRequest::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MarketDepthRequest::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.MarketDepthRequest.Symbol)
}

// optional string Exchange = 4;
inline bool MarketDepthRequest::has_exchange() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDepthRequest::set_has_exchange() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDepthRequest::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDepthRequest::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& MarketDepthRequest::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthRequest.Exchange)
  return *exchange_;
}
inline void MarketDepthRequest::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthRequest.Exchange)
}
inline void MarketDepthRequest::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.MarketDepthRequest.Exchange)
}
inline void MarketDepthRequest::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.MarketDepthRequest.Exchange)
}
inline ::std::string* MarketDepthRequest::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDepthRequest.Exchange)
  return exchange_;
}
inline ::std::string* MarketDepthRequest::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MarketDepthRequest::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.MarketDepthRequest.Exchange)
}

// optional int32 NumLevels = 5;
inline bool MarketDepthRequest::has_numlevels() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDepthRequest::set_has_numlevels() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDepthRequest::clear_has_numlevels() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDepthRequest::clear_numlevels() {
  numlevels_ = 0;
  clear_has_numlevels();
}
inline ::google::protobuf::int32 MarketDepthRequest::numlevels() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthRequest.NumLevels)
  return numlevels_;
}
inline void MarketDepthRequest::set_numlevels(::google::protobuf::int32 value) {
  set_has_numlevels();
  numlevels_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthRequest.NumLevels)
}

// -------------------------------------------------------------------

// MarketDataReject

// optional uint32 SymbolID = 1;
inline bool MarketDataReject::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataReject::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataReject::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataReject::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataReject::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataReject.SymbolID)
  return symbolid_;
}
inline void MarketDataReject::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataReject.SymbolID)
}

// optional string RejectText = 2;
inline bool MarketDataReject::has_rejecttext() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataReject::set_has_rejecttext() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataReject::clear_has_rejecttext() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataReject::clear_rejecttext() {
  if (rejecttext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_->clear();
  }
  clear_has_rejecttext();
}
inline const ::std::string& MarketDataReject::rejecttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataReject.RejectText)
  return *rejecttext_;
}
inline void MarketDataReject::set_rejecttext(const ::std::string& value) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataReject.RejectText)
}
inline void MarketDataReject::set_rejecttext(const char* value) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.MarketDataReject.RejectText)
}
inline void MarketDataReject::set_rejecttext(const char* value, size_t size) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.MarketDataReject.RejectText)
}
inline ::std::string* MarketDataReject::mutable_rejecttext() {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDataReject.RejectText)
  return rejecttext_;
}
inline ::std::string* MarketDataReject::release_rejecttext() {
  clear_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rejecttext_;
    rejecttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MarketDataReject::set_allocated_rejecttext(::std::string* rejecttext) {
  if (rejecttext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rejecttext_;
  }
  if (rejecttext) {
    set_has_rejecttext();
    rejecttext_ = rejecttext;
  } else {
    clear_has_rejecttext();
    rejecttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.MarketDataReject.RejectText)
}

// -------------------------------------------------------------------

// MarketDataSnapshot

// optional uint32 SymbolID = 1;
inline bool MarketDataSnapshot::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataSnapshot::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataSnapshot::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataSnapshot::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataSnapshot::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.SymbolID)
  return symbolid_;
}
inline void MarketDataSnapshot::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.SymbolID)
}

// optional double SessionSettlementPrice = 2;
inline bool MarketDataSnapshot::has_sessionsettlementprice() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataSnapshot::set_has_sessionsettlementprice() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataSnapshot::clear_has_sessionsettlementprice() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataSnapshot::clear_sessionsettlementprice() {
  sessionsettlementprice_ = 0;
  clear_has_sessionsettlementprice();
}
inline double MarketDataSnapshot::sessionsettlementprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.SessionSettlementPrice)
  return sessionsettlementprice_;
}
inline void MarketDataSnapshot::set_sessionsettlementprice(double value) {
  set_has_sessionsettlementprice();
  sessionsettlementprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.SessionSettlementPrice)
}

// optional double SessionOpenPrice = 3;
inline bool MarketDataSnapshot::has_sessionopenprice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataSnapshot::set_has_sessionopenprice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataSnapshot::clear_has_sessionopenprice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataSnapshot::clear_sessionopenprice() {
  sessionopenprice_ = 0;
  clear_has_sessionopenprice();
}
inline double MarketDataSnapshot::sessionopenprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.SessionOpenPrice)
  return sessionopenprice_;
}
inline void MarketDataSnapshot::set_sessionopenprice(double value) {
  set_has_sessionopenprice();
  sessionopenprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.SessionOpenPrice)
}

// optional double SessionHighPrice = 4;
inline bool MarketDataSnapshot::has_sessionhighprice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataSnapshot::set_has_sessionhighprice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataSnapshot::clear_has_sessionhighprice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataSnapshot::clear_sessionhighprice() {
  sessionhighprice_ = 0;
  clear_has_sessionhighprice();
}
inline double MarketDataSnapshot::sessionhighprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.SessionHighPrice)
  return sessionhighprice_;
}
inline void MarketDataSnapshot::set_sessionhighprice(double value) {
  set_has_sessionhighprice();
  sessionhighprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.SessionHighPrice)
}

// optional double SessionLowPrice = 5;
inline bool MarketDataSnapshot::has_sessionlowprice() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDataSnapshot::set_has_sessionlowprice() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDataSnapshot::clear_has_sessionlowprice() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDataSnapshot::clear_sessionlowprice() {
  sessionlowprice_ = 0;
  clear_has_sessionlowprice();
}
inline double MarketDataSnapshot::sessionlowprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.SessionLowPrice)
  return sessionlowprice_;
}
inline void MarketDataSnapshot::set_sessionlowprice(double value) {
  set_has_sessionlowprice();
  sessionlowprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.SessionLowPrice)
}

// optional double SessionVolume = 6;
inline bool MarketDataSnapshot::has_sessionvolume() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketDataSnapshot::set_has_sessionvolume() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketDataSnapshot::clear_has_sessionvolume() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketDataSnapshot::clear_sessionvolume() {
  sessionvolume_ = 0;
  clear_has_sessionvolume();
}
inline double MarketDataSnapshot::sessionvolume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.SessionVolume)
  return sessionvolume_;
}
inline void MarketDataSnapshot::set_sessionvolume(double value) {
  set_has_sessionvolume();
  sessionvolume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.SessionVolume)
}

// optional uint32 SessionNumTrades = 7;
inline bool MarketDataSnapshot::has_sessionnumtrades() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MarketDataSnapshot::set_has_sessionnumtrades() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MarketDataSnapshot::clear_has_sessionnumtrades() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MarketDataSnapshot::clear_sessionnumtrades() {
  sessionnumtrades_ = 0u;
  clear_has_sessionnumtrades();
}
inline ::google::protobuf::uint32 MarketDataSnapshot::sessionnumtrades() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.SessionNumTrades)
  return sessionnumtrades_;
}
inline void MarketDataSnapshot::set_sessionnumtrades(::google::protobuf::uint32 value) {
  set_has_sessionnumtrades();
  sessionnumtrades_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.SessionNumTrades)
}

// optional uint32 OpenInterest = 8;
inline bool MarketDataSnapshot::has_openinterest() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MarketDataSnapshot::set_has_openinterest() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MarketDataSnapshot::clear_has_openinterest() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MarketDataSnapshot::clear_openinterest() {
  openinterest_ = 0u;
  clear_has_openinterest();
}
inline ::google::protobuf::uint32 MarketDataSnapshot::openinterest() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.OpenInterest)
  return openinterest_;
}
inline void MarketDataSnapshot::set_openinterest(::google::protobuf::uint32 value) {
  set_has_openinterest();
  openinterest_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.OpenInterest)
}

// optional double BidPrice = 9;
inline bool MarketDataSnapshot::has_bidprice() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MarketDataSnapshot::set_has_bidprice() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MarketDataSnapshot::clear_has_bidprice() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MarketDataSnapshot::clear_bidprice() {
  bidprice_ = 0;
  clear_has_bidprice();
}
inline double MarketDataSnapshot::bidprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.BidPrice)
  return bidprice_;
}
inline void MarketDataSnapshot::set_bidprice(double value) {
  set_has_bidprice();
  bidprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.BidPrice)
}

// optional double AskPrice = 10;
inline bool MarketDataSnapshot::has_askprice() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MarketDataSnapshot::set_has_askprice() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MarketDataSnapshot::clear_has_askprice() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MarketDataSnapshot::clear_askprice() {
  askprice_ = 0;
  clear_has_askprice();
}
inline double MarketDataSnapshot::askprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.AskPrice)
  return askprice_;
}
inline void MarketDataSnapshot::set_askprice(double value) {
  set_has_askprice();
  askprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.AskPrice)
}

// optional double AskQuantity = 11;
inline bool MarketDataSnapshot::has_askquantity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MarketDataSnapshot::set_has_askquantity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MarketDataSnapshot::clear_has_askquantity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MarketDataSnapshot::clear_askquantity() {
  askquantity_ = 0;
  clear_has_askquantity();
}
inline double MarketDataSnapshot::askquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.AskQuantity)
  return askquantity_;
}
inline void MarketDataSnapshot::set_askquantity(double value) {
  set_has_askquantity();
  askquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.AskQuantity)
}

// optional double BidQuantity = 12;
inline bool MarketDataSnapshot::has_bidquantity() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MarketDataSnapshot::set_has_bidquantity() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MarketDataSnapshot::clear_has_bidquantity() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MarketDataSnapshot::clear_bidquantity() {
  bidquantity_ = 0;
  clear_has_bidquantity();
}
inline double MarketDataSnapshot::bidquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.BidQuantity)
  return bidquantity_;
}
inline void MarketDataSnapshot::set_bidquantity(double value) {
  set_has_bidquantity();
  bidquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.BidQuantity)
}

// optional double LastTradePrice = 13;
inline bool MarketDataSnapshot::has_lasttradeprice() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MarketDataSnapshot::set_has_lasttradeprice() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MarketDataSnapshot::clear_has_lasttradeprice() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MarketDataSnapshot::clear_lasttradeprice() {
  lasttradeprice_ = 0;
  clear_has_lasttradeprice();
}
inline double MarketDataSnapshot::lasttradeprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.LastTradePrice)
  return lasttradeprice_;
}
inline void MarketDataSnapshot::set_lasttradeprice(double value) {
  set_has_lasttradeprice();
  lasttradeprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.LastTradePrice)
}

// optional double LastTradeVolume = 14;
inline bool MarketDataSnapshot::has_lasttradevolume() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MarketDataSnapshot::set_has_lasttradevolume() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MarketDataSnapshot::clear_has_lasttradevolume() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MarketDataSnapshot::clear_lasttradevolume() {
  lasttradevolume_ = 0;
  clear_has_lasttradevolume();
}
inline double MarketDataSnapshot::lasttradevolume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.LastTradeVolume)
  return lasttradevolume_;
}
inline void MarketDataSnapshot::set_lasttradevolume(double value) {
  set_has_lasttradevolume();
  lasttradevolume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.LastTradeVolume)
}

// optional double LastTradeDateTime = 15;
inline bool MarketDataSnapshot::has_lasttradedatetime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MarketDataSnapshot::set_has_lasttradedatetime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MarketDataSnapshot::clear_has_lasttradedatetime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MarketDataSnapshot::clear_lasttradedatetime() {
  lasttradedatetime_ = 0;
  clear_has_lasttradedatetime();
}
inline double MarketDataSnapshot::lasttradedatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.LastTradeDateTime)
  return lasttradedatetime_;
}
inline void MarketDataSnapshot::set_lasttradedatetime(double value) {
  set_has_lasttradedatetime();
  lasttradedatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.LastTradeDateTime)
}

// optional double BidAskDateTime = 16;
inline bool MarketDataSnapshot::has_bidaskdatetime() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MarketDataSnapshot::set_has_bidaskdatetime() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MarketDataSnapshot::clear_has_bidaskdatetime() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MarketDataSnapshot::clear_bidaskdatetime() {
  bidaskdatetime_ = 0;
  clear_has_bidaskdatetime();
}
inline double MarketDataSnapshot::bidaskdatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot.BidAskDateTime)
  return bidaskdatetime_;
}
inline void MarketDataSnapshot::set_bidaskdatetime(double value) {
  set_has_bidaskdatetime();
  bidaskdatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot.BidAskDateTime)
}

// -------------------------------------------------------------------

// MarketDataSnapshot_Int

// optional uint32 SymbolID = 1;
inline bool MarketDataSnapshot_Int::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataSnapshot_Int::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataSnapshot_Int::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataSnapshot_Int::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.SymbolID)
  return symbolid_;
}
inline void MarketDataSnapshot_Int::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.SymbolID)
}

// optional int32 SessionSettlementPrice = 2;
inline bool MarketDataSnapshot_Int::has_sessionsettlementprice() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_sessionsettlementprice() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataSnapshot_Int::clear_has_sessionsettlementprice() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataSnapshot_Int::clear_sessionsettlementprice() {
  sessionsettlementprice_ = 0;
  clear_has_sessionsettlementprice();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::sessionsettlementprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.SessionSettlementPrice)
  return sessionsettlementprice_;
}
inline void MarketDataSnapshot_Int::set_sessionsettlementprice(::google::protobuf::int32 value) {
  set_has_sessionsettlementprice();
  sessionsettlementprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.SessionSettlementPrice)
}

// optional int32 SessionOpenPrice = 3;
inline bool MarketDataSnapshot_Int::has_sessionopenprice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_sessionopenprice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataSnapshot_Int::clear_has_sessionopenprice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataSnapshot_Int::clear_sessionopenprice() {
  sessionopenprice_ = 0;
  clear_has_sessionopenprice();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::sessionopenprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.SessionOpenPrice)
  return sessionopenprice_;
}
inline void MarketDataSnapshot_Int::set_sessionopenprice(::google::protobuf::int32 value) {
  set_has_sessionopenprice();
  sessionopenprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.SessionOpenPrice)
}

// optional int32 SessionHighPrice = 4;
inline bool MarketDataSnapshot_Int::has_sessionhighprice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_sessionhighprice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataSnapshot_Int::clear_has_sessionhighprice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataSnapshot_Int::clear_sessionhighprice() {
  sessionhighprice_ = 0;
  clear_has_sessionhighprice();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::sessionhighprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.SessionHighPrice)
  return sessionhighprice_;
}
inline void MarketDataSnapshot_Int::set_sessionhighprice(::google::protobuf::int32 value) {
  set_has_sessionhighprice();
  sessionhighprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.SessionHighPrice)
}

// optional int32 SessionLowPrice = 5;
inline bool MarketDataSnapshot_Int::has_sessionlowprice() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_sessionlowprice() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDataSnapshot_Int::clear_has_sessionlowprice() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDataSnapshot_Int::clear_sessionlowprice() {
  sessionlowprice_ = 0;
  clear_has_sessionlowprice();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::sessionlowprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.SessionLowPrice)
  return sessionlowprice_;
}
inline void MarketDataSnapshot_Int::set_sessionlowprice(::google::protobuf::int32 value) {
  set_has_sessionlowprice();
  sessionlowprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.SessionLowPrice)
}

// optional int32 SessionVolume = 6;
inline bool MarketDataSnapshot_Int::has_sessionvolume() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_sessionvolume() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketDataSnapshot_Int::clear_has_sessionvolume() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketDataSnapshot_Int::clear_sessionvolume() {
  sessionvolume_ = 0;
  clear_has_sessionvolume();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::sessionvolume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.SessionVolume)
  return sessionvolume_;
}
inline void MarketDataSnapshot_Int::set_sessionvolume(::google::protobuf::int32 value) {
  set_has_sessionvolume();
  sessionvolume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.SessionVolume)
}

// optional uint32 SessionNumTrades = 7;
inline bool MarketDataSnapshot_Int::has_sessionnumtrades() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_sessionnumtrades() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MarketDataSnapshot_Int::clear_has_sessionnumtrades() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MarketDataSnapshot_Int::clear_sessionnumtrades() {
  sessionnumtrades_ = 0u;
  clear_has_sessionnumtrades();
}
inline ::google::protobuf::uint32 MarketDataSnapshot_Int::sessionnumtrades() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.SessionNumTrades)
  return sessionnumtrades_;
}
inline void MarketDataSnapshot_Int::set_sessionnumtrades(::google::protobuf::uint32 value) {
  set_has_sessionnumtrades();
  sessionnumtrades_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.SessionNumTrades)
}

// optional uint32 OpenInterest = 8;
inline bool MarketDataSnapshot_Int::has_openinterest() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_openinterest() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MarketDataSnapshot_Int::clear_has_openinterest() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MarketDataSnapshot_Int::clear_openinterest() {
  openinterest_ = 0u;
  clear_has_openinterest();
}
inline ::google::protobuf::uint32 MarketDataSnapshot_Int::openinterest() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.OpenInterest)
  return openinterest_;
}
inline void MarketDataSnapshot_Int::set_openinterest(::google::protobuf::uint32 value) {
  set_has_openinterest();
  openinterest_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.OpenInterest)
}

// optional int32 BidPrice = 9;
inline bool MarketDataSnapshot_Int::has_bidprice() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_bidprice() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MarketDataSnapshot_Int::clear_has_bidprice() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MarketDataSnapshot_Int::clear_bidprice() {
  bidprice_ = 0;
  clear_has_bidprice();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::bidprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.BidPrice)
  return bidprice_;
}
inline void MarketDataSnapshot_Int::set_bidprice(::google::protobuf::int32 value) {
  set_has_bidprice();
  bidprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.BidPrice)
}

// optional int32 AskPrice = 10;
inline bool MarketDataSnapshot_Int::has_askprice() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_askprice() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MarketDataSnapshot_Int::clear_has_askprice() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MarketDataSnapshot_Int::clear_askprice() {
  askprice_ = 0;
  clear_has_askprice();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::askprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.AskPrice)
  return askprice_;
}
inline void MarketDataSnapshot_Int::set_askprice(::google::protobuf::int32 value) {
  set_has_askprice();
  askprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.AskPrice)
}

// optional int32 AskQuantity = 11;
inline bool MarketDataSnapshot_Int::has_askquantity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_askquantity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MarketDataSnapshot_Int::clear_has_askquantity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MarketDataSnapshot_Int::clear_askquantity() {
  askquantity_ = 0;
  clear_has_askquantity();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::askquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.AskQuantity)
  return askquantity_;
}
inline void MarketDataSnapshot_Int::set_askquantity(::google::protobuf::int32 value) {
  set_has_askquantity();
  askquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.AskQuantity)
}

// optional int32 BidQuantity = 12;
inline bool MarketDataSnapshot_Int::has_bidquantity() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_bidquantity() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MarketDataSnapshot_Int::clear_has_bidquantity() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MarketDataSnapshot_Int::clear_bidquantity() {
  bidquantity_ = 0;
  clear_has_bidquantity();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::bidquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.BidQuantity)
  return bidquantity_;
}
inline void MarketDataSnapshot_Int::set_bidquantity(::google::protobuf::int32 value) {
  set_has_bidquantity();
  bidquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.BidQuantity)
}

// optional int32 LastTradePrice = 13;
inline bool MarketDataSnapshot_Int::has_lasttradeprice() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_lasttradeprice() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MarketDataSnapshot_Int::clear_has_lasttradeprice() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MarketDataSnapshot_Int::clear_lasttradeprice() {
  lasttradeprice_ = 0;
  clear_has_lasttradeprice();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::lasttradeprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.LastTradePrice)
  return lasttradeprice_;
}
inline void MarketDataSnapshot_Int::set_lasttradeprice(::google::protobuf::int32 value) {
  set_has_lasttradeprice();
  lasttradeprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.LastTradePrice)
}

// optional int32 LastTradeVolume = 14;
inline bool MarketDataSnapshot_Int::has_lasttradevolume() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_lasttradevolume() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MarketDataSnapshot_Int::clear_has_lasttradevolume() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MarketDataSnapshot_Int::clear_lasttradevolume() {
  lasttradevolume_ = 0;
  clear_has_lasttradevolume();
}
inline ::google::protobuf::int32 MarketDataSnapshot_Int::lasttradevolume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.LastTradeVolume)
  return lasttradevolume_;
}
inline void MarketDataSnapshot_Int::set_lasttradevolume(::google::protobuf::int32 value) {
  set_has_lasttradevolume();
  lasttradevolume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.LastTradeVolume)
}

// optional double LastTradeDateTime = 15;
inline bool MarketDataSnapshot_Int::has_lasttradedatetime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_lasttradedatetime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MarketDataSnapshot_Int::clear_has_lasttradedatetime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MarketDataSnapshot_Int::clear_lasttradedatetime() {
  lasttradedatetime_ = 0;
  clear_has_lasttradedatetime();
}
inline double MarketDataSnapshot_Int::lasttradedatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.LastTradeDateTime)
  return lasttradedatetime_;
}
inline void MarketDataSnapshot_Int::set_lasttradedatetime(double value) {
  set_has_lasttradedatetime();
  lasttradedatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.LastTradeDateTime)
}

// optional double BidAskDateTime = 16;
inline bool MarketDataSnapshot_Int::has_bidaskdatetime() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MarketDataSnapshot_Int::set_has_bidaskdatetime() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MarketDataSnapshot_Int::clear_has_bidaskdatetime() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MarketDataSnapshot_Int::clear_bidaskdatetime() {
  bidaskdatetime_ = 0;
  clear_has_bidaskdatetime();
}
inline double MarketDataSnapshot_Int::bidaskdatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataSnapshot_Int.BidAskDateTime)
  return bidaskdatetime_;
}
inline void MarketDataSnapshot_Int::set_bidaskdatetime(double value) {
  set_has_bidaskdatetime();
  bidaskdatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataSnapshot_Int.BidAskDateTime)
}

// -------------------------------------------------------------------

// DepthEntry

// optional double Price = 1;
inline bool DepthEntry::has_price() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DepthEntry::set_has_price() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DepthEntry::clear_has_price() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DepthEntry::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double DepthEntry::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.DepthEntry.Price)
  return price_;
}
inline void DepthEntry::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.DepthEntry.Price)
}

// optional float Quantity = 12;
inline bool DepthEntry::has_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DepthEntry::set_has_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DepthEntry::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DepthEntry::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline float DepthEntry::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.DepthEntry.Quantity)
  return quantity_;
}
inline void DepthEntry::set_quantity(float value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.DepthEntry.Quantity)
}

// -------------------------------------------------------------------

// MarketDepthFullUpdate20

// optional uint32 SymbolID = 1;
inline bool MarketDepthFullUpdate20::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDepthFullUpdate20::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDepthFullUpdate20::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDepthFullUpdate20::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDepthFullUpdate20::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthFullUpdate20.SymbolID)
  return symbolid_;
}
inline void MarketDepthFullUpdate20::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthFullUpdate20.SymbolID)
}

// repeated .DTC_PB.DepthEntry BidDepth = 2;
inline int MarketDepthFullUpdate20::biddepth_size() const {
  return biddepth_.size();
}
inline void MarketDepthFullUpdate20::clear_biddepth() {
  biddepth_.Clear();
}
inline const ::DTC_PB::DepthEntry& MarketDepthFullUpdate20::biddepth(int index) const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthFullUpdate20.BidDepth)
  return biddepth_.Get(index);
}
inline ::DTC_PB::DepthEntry* MarketDepthFullUpdate20::mutable_biddepth(int index) {
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDepthFullUpdate20.BidDepth)
  return biddepth_.Mutable(index);
}
inline ::DTC_PB::DepthEntry* MarketDepthFullUpdate20::add_biddepth() {
  // @@protoc_insertion_point(field_add:DTC_PB.MarketDepthFullUpdate20.BidDepth)
  return biddepth_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >&
MarketDepthFullUpdate20::biddepth() const {
  // @@protoc_insertion_point(field_list:DTC_PB.MarketDepthFullUpdate20.BidDepth)
  return biddepth_;
}
inline ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >*
MarketDepthFullUpdate20::mutable_biddepth() {
  // @@protoc_insertion_point(field_mutable_list:DTC_PB.MarketDepthFullUpdate20.BidDepth)
  return &biddepth_;
}

// repeated .DTC_PB.DepthEntry AskDepth = 3;
inline int MarketDepthFullUpdate20::askdepth_size() const {
  return askdepth_.size();
}
inline void MarketDepthFullUpdate20::clear_askdepth() {
  askdepth_.Clear();
}
inline const ::DTC_PB::DepthEntry& MarketDepthFullUpdate20::askdepth(int index) const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthFullUpdate20.AskDepth)
  return askdepth_.Get(index);
}
inline ::DTC_PB::DepthEntry* MarketDepthFullUpdate20::mutable_askdepth(int index) {
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDepthFullUpdate20.AskDepth)
  return askdepth_.Mutable(index);
}
inline ::DTC_PB::DepthEntry* MarketDepthFullUpdate20::add_askdepth() {
  // @@protoc_insertion_point(field_add:DTC_PB.MarketDepthFullUpdate20.AskDepth)
  return askdepth_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >&
MarketDepthFullUpdate20::askdepth() const {
  // @@protoc_insertion_point(field_list:DTC_PB.MarketDepthFullUpdate20.AskDepth)
  return askdepth_;
}
inline ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >*
MarketDepthFullUpdate20::mutable_askdepth() {
  // @@protoc_insertion_point(field_mutable_list:DTC_PB.MarketDepthFullUpdate20.AskDepth)
  return &askdepth_;
}

// -------------------------------------------------------------------

// MarketDepthFullUpdate10

// optional uint32 SymbolID = 1;
inline bool MarketDepthFullUpdate10::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDepthFullUpdate10::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDepthFullUpdate10::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDepthFullUpdate10::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDepthFullUpdate10::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthFullUpdate10.SymbolID)
  return symbolid_;
}
inline void MarketDepthFullUpdate10::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthFullUpdate10.SymbolID)
}

// repeated .DTC_PB.DepthEntry BidDepth = 2;
inline int MarketDepthFullUpdate10::biddepth_size() const {
  return biddepth_.size();
}
inline void MarketDepthFullUpdate10::clear_biddepth() {
  biddepth_.Clear();
}
inline const ::DTC_PB::DepthEntry& MarketDepthFullUpdate10::biddepth(int index) const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthFullUpdate10.BidDepth)
  return biddepth_.Get(index);
}
inline ::DTC_PB::DepthEntry* MarketDepthFullUpdate10::mutable_biddepth(int index) {
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDepthFullUpdate10.BidDepth)
  return biddepth_.Mutable(index);
}
inline ::DTC_PB::DepthEntry* MarketDepthFullUpdate10::add_biddepth() {
  // @@protoc_insertion_point(field_add:DTC_PB.MarketDepthFullUpdate10.BidDepth)
  return biddepth_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >&
MarketDepthFullUpdate10::biddepth() const {
  // @@protoc_insertion_point(field_list:DTC_PB.MarketDepthFullUpdate10.BidDepth)
  return biddepth_;
}
inline ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >*
MarketDepthFullUpdate10::mutable_biddepth() {
  // @@protoc_insertion_point(field_mutable_list:DTC_PB.MarketDepthFullUpdate10.BidDepth)
  return &biddepth_;
}

// repeated .DTC_PB.DepthEntry AskDepth = 3;
inline int MarketDepthFullUpdate10::askdepth_size() const {
  return askdepth_.size();
}
inline void MarketDepthFullUpdate10::clear_askdepth() {
  askdepth_.Clear();
}
inline const ::DTC_PB::DepthEntry& MarketDepthFullUpdate10::askdepth(int index) const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthFullUpdate10.AskDepth)
  return askdepth_.Get(index);
}
inline ::DTC_PB::DepthEntry* MarketDepthFullUpdate10::mutable_askdepth(int index) {
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDepthFullUpdate10.AskDepth)
  return askdepth_.Mutable(index);
}
inline ::DTC_PB::DepthEntry* MarketDepthFullUpdate10::add_askdepth() {
  // @@protoc_insertion_point(field_add:DTC_PB.MarketDepthFullUpdate10.AskDepth)
  return askdepth_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >&
MarketDepthFullUpdate10::askdepth() const {
  // @@protoc_insertion_point(field_list:DTC_PB.MarketDepthFullUpdate10.AskDepth)
  return askdepth_;
}
inline ::google::protobuf::RepeatedPtrField< ::DTC_PB::DepthEntry >*
MarketDepthFullUpdate10::mutable_askdepth() {
  // @@protoc_insertion_point(field_mutable_list:DTC_PB.MarketDepthFullUpdate10.AskDepth)
  return &askdepth_;
}

// -------------------------------------------------------------------

// MarketDepthSnapshotLevel

// optional uint32 SymbolID = 1;
inline bool MarketDepthSnapshotLevel::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDepthSnapshotLevel::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDepthSnapshotLevel::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDepthSnapshotLevel::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDepthSnapshotLevel::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel.SymbolID)
  return symbolid_;
}
inline void MarketDepthSnapshotLevel::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel.SymbolID)
}

// optional .DTC_PB.AtBidOrAskEnum Side = 2;
inline bool MarketDepthSnapshotLevel::has_side() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDepthSnapshotLevel::set_has_side() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDepthSnapshotLevel::clear_has_side() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDepthSnapshotLevel::clear_side() {
  side_ = 0;
  clear_has_side();
}
inline ::DTC_PB::AtBidOrAskEnum MarketDepthSnapshotLevel::side() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel.Side)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(side_);
}
inline void MarketDepthSnapshotLevel::set_side(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_side();
  side_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel.Side)
}

// optional double Price = 3;
inline bool MarketDepthSnapshotLevel::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDepthSnapshotLevel::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDepthSnapshotLevel::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDepthSnapshotLevel::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double MarketDepthSnapshotLevel::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel.Price)
  return price_;
}
inline void MarketDepthSnapshotLevel::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel.Price)
}

// optional double Quantity = 4;
inline bool MarketDepthSnapshotLevel::has_quantity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDepthSnapshotLevel::set_has_quantity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDepthSnapshotLevel::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDepthSnapshotLevel::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline double MarketDepthSnapshotLevel::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel.Quantity)
  return quantity_;
}
inline void MarketDepthSnapshotLevel::set_quantity(double value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel.Quantity)
}

// optional uint32 Level = 5;
inline bool MarketDepthSnapshotLevel::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDepthSnapshotLevel::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDepthSnapshotLevel::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDepthSnapshotLevel::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 MarketDepthSnapshotLevel::level() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel.Level)
  return level_;
}
inline void MarketDepthSnapshotLevel::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel.Level)
}

// optional uint32 IsFirstMessageInBatch = 6;
inline bool MarketDepthSnapshotLevel::has_isfirstmessageinbatch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketDepthSnapshotLevel::set_has_isfirstmessageinbatch() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketDepthSnapshotLevel::clear_has_isfirstmessageinbatch() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketDepthSnapshotLevel::clear_isfirstmessageinbatch() {
  isfirstmessageinbatch_ = 0u;
  clear_has_isfirstmessageinbatch();
}
inline ::google::protobuf::uint32 MarketDepthSnapshotLevel::isfirstmessageinbatch() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel.IsFirstMessageInBatch)
  return isfirstmessageinbatch_;
}
inline void MarketDepthSnapshotLevel::set_isfirstmessageinbatch(::google::protobuf::uint32 value) {
  set_has_isfirstmessageinbatch();
  isfirstmessageinbatch_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel.IsFirstMessageInBatch)
}

// optional uint32 IsLastMessageInBatch = 7;
inline bool MarketDepthSnapshotLevel::has_islastmessageinbatch() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MarketDepthSnapshotLevel::set_has_islastmessageinbatch() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MarketDepthSnapshotLevel::clear_has_islastmessageinbatch() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MarketDepthSnapshotLevel::clear_islastmessageinbatch() {
  islastmessageinbatch_ = 0u;
  clear_has_islastmessageinbatch();
}
inline ::google::protobuf::uint32 MarketDepthSnapshotLevel::islastmessageinbatch() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel.IsLastMessageInBatch)
  return islastmessageinbatch_;
}
inline void MarketDepthSnapshotLevel::set_islastmessageinbatch(::google::protobuf::uint32 value) {
  set_has_islastmessageinbatch();
  islastmessageinbatch_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel.IsLastMessageInBatch)
}

// -------------------------------------------------------------------

// MarketDepthSnapshotLevel_Int

// optional uint32 SymbolID = 1;
inline bool MarketDepthSnapshotLevel_Int::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDepthSnapshotLevel_Int::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDepthSnapshotLevel_Int::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDepthSnapshotLevel_Int::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDepthSnapshotLevel_Int::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel_Int.SymbolID)
  return symbolid_;
}
inline void MarketDepthSnapshotLevel_Int::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel_Int.SymbolID)
}

// optional .DTC_PB.AtBidOrAskEnum Side = 2;
inline bool MarketDepthSnapshotLevel_Int::has_side() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDepthSnapshotLevel_Int::set_has_side() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDepthSnapshotLevel_Int::clear_has_side() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDepthSnapshotLevel_Int::clear_side() {
  side_ = 0;
  clear_has_side();
}
inline ::DTC_PB::AtBidOrAskEnum MarketDepthSnapshotLevel_Int::side() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel_Int.Side)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(side_);
}
inline void MarketDepthSnapshotLevel_Int::set_side(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_side();
  side_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel_Int.Side)
}

// optional int32 Price = 3;
inline bool MarketDepthSnapshotLevel_Int::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDepthSnapshotLevel_Int::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDepthSnapshotLevel_Int::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDepthSnapshotLevel_Int::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 MarketDepthSnapshotLevel_Int::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel_Int.Price)
  return price_;
}
inline void MarketDepthSnapshotLevel_Int::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel_Int.Price)
}

// optional int32 Quantity = 4;
inline bool MarketDepthSnapshotLevel_Int::has_quantity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDepthSnapshotLevel_Int::set_has_quantity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDepthSnapshotLevel_Int::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDepthSnapshotLevel_Int::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline ::google::protobuf::int32 MarketDepthSnapshotLevel_Int::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel_Int.Quantity)
  return quantity_;
}
inline void MarketDepthSnapshotLevel_Int::set_quantity(::google::protobuf::int32 value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel_Int.Quantity)
}

// optional uint32 Level = 5;
inline bool MarketDepthSnapshotLevel_Int::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDepthSnapshotLevel_Int::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDepthSnapshotLevel_Int::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDepthSnapshotLevel_Int::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 MarketDepthSnapshotLevel_Int::level() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel_Int.Level)
  return level_;
}
inline void MarketDepthSnapshotLevel_Int::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel_Int.Level)
}

// optional uint32 IsFirstMessageInBatch = 6;
inline bool MarketDepthSnapshotLevel_Int::has_isfirstmessageinbatch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketDepthSnapshotLevel_Int::set_has_isfirstmessageinbatch() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketDepthSnapshotLevel_Int::clear_has_isfirstmessageinbatch() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketDepthSnapshotLevel_Int::clear_isfirstmessageinbatch() {
  isfirstmessageinbatch_ = 0u;
  clear_has_isfirstmessageinbatch();
}
inline ::google::protobuf::uint32 MarketDepthSnapshotLevel_Int::isfirstmessageinbatch() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel_Int.IsFirstMessageInBatch)
  return isfirstmessageinbatch_;
}
inline void MarketDepthSnapshotLevel_Int::set_isfirstmessageinbatch(::google::protobuf::uint32 value) {
  set_has_isfirstmessageinbatch();
  isfirstmessageinbatch_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel_Int.IsFirstMessageInBatch)
}

// optional uint32 IsLastMessageInBatch = 7;
inline bool MarketDepthSnapshotLevel_Int::has_islastmessageinbatch() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MarketDepthSnapshotLevel_Int::set_has_islastmessageinbatch() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MarketDepthSnapshotLevel_Int::clear_has_islastmessageinbatch() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MarketDepthSnapshotLevel_Int::clear_islastmessageinbatch() {
  islastmessageinbatch_ = 0u;
  clear_has_islastmessageinbatch();
}
inline ::google::protobuf::uint32 MarketDepthSnapshotLevel_Int::islastmessageinbatch() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthSnapshotLevel_Int.IsLastMessageInBatch)
  return islastmessageinbatch_;
}
inline void MarketDepthSnapshotLevel_Int::set_islastmessageinbatch(::google::protobuf::uint32 value) {
  set_has_islastmessageinbatch();
  islastmessageinbatch_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthSnapshotLevel_Int.IsLastMessageInBatch)
}

// -------------------------------------------------------------------

// MarketDepthUpdateLevel

// optional uint32 SymbolID = 1;
inline bool MarketDepthUpdateLevel::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDepthUpdateLevel::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDepthUpdateLevel::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDepthUpdateLevel::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDepthUpdateLevel::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel.SymbolID)
  return symbolid_;
}
inline void MarketDepthUpdateLevel::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel.SymbolID)
}

// optional .DTC_PB.AtBidOrAskEnum Side = 2;
inline bool MarketDepthUpdateLevel::has_side() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDepthUpdateLevel::set_has_side() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDepthUpdateLevel::clear_has_side() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDepthUpdateLevel::clear_side() {
  side_ = 0;
  clear_has_side();
}
inline ::DTC_PB::AtBidOrAskEnum MarketDepthUpdateLevel::side() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel.Side)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(side_);
}
inline void MarketDepthUpdateLevel::set_side(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_side();
  side_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel.Side)
}

// optional double Price = 3;
inline bool MarketDepthUpdateLevel::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDepthUpdateLevel::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDepthUpdateLevel::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDepthUpdateLevel::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double MarketDepthUpdateLevel::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel.Price)
  return price_;
}
inline void MarketDepthUpdateLevel::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel.Price)
}

// optional double Quantity = 4;
inline bool MarketDepthUpdateLevel::has_quantity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDepthUpdateLevel::set_has_quantity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDepthUpdateLevel::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDepthUpdateLevel::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline double MarketDepthUpdateLevel::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel.Quantity)
  return quantity_;
}
inline void MarketDepthUpdateLevel::set_quantity(double value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel.Quantity)
}

// optional .DTC_PB.MarketDepthUpdateTypeEnum UpdateType = 5;
inline bool MarketDepthUpdateLevel::has_updatetype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDepthUpdateLevel::set_has_updatetype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDepthUpdateLevel::clear_has_updatetype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDepthUpdateLevel::clear_updatetype() {
  updatetype_ = 0;
  clear_has_updatetype();
}
inline ::DTC_PB::MarketDepthUpdateTypeEnum MarketDepthUpdateLevel::updatetype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel.UpdateType)
  return static_cast< ::DTC_PB::MarketDepthUpdateTypeEnum >(updatetype_);
}
inline void MarketDepthUpdateLevel::set_updatetype(::DTC_PB::MarketDepthUpdateTypeEnum value) {
  assert(::DTC_PB::MarketDepthUpdateTypeEnum_IsValid(value));
  set_has_updatetype();
  updatetype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel.UpdateType)
}

// -------------------------------------------------------------------

// MarketDepthUpdateLevel_Int

// optional uint32 SymbolID = 1;
inline bool MarketDepthUpdateLevel_Int::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDepthUpdateLevel_Int::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDepthUpdateLevel_Int::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDepthUpdateLevel_Int::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDepthUpdateLevel_Int::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel_Int.SymbolID)
  return symbolid_;
}
inline void MarketDepthUpdateLevel_Int::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel_Int.SymbolID)
}

// optional .DTC_PB.AtBidOrAskEnum Side = 2;
inline bool MarketDepthUpdateLevel_Int::has_side() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDepthUpdateLevel_Int::set_has_side() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDepthUpdateLevel_Int::clear_has_side() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDepthUpdateLevel_Int::clear_side() {
  side_ = 0;
  clear_has_side();
}
inline ::DTC_PB::AtBidOrAskEnum MarketDepthUpdateLevel_Int::side() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel_Int.Side)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(side_);
}
inline void MarketDepthUpdateLevel_Int::set_side(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_side();
  side_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel_Int.Side)
}

// optional int32 Price = 3;
inline bool MarketDepthUpdateLevel_Int::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDepthUpdateLevel_Int::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDepthUpdateLevel_Int::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDepthUpdateLevel_Int::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 MarketDepthUpdateLevel_Int::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel_Int.Price)
  return price_;
}
inline void MarketDepthUpdateLevel_Int::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel_Int.Price)
}

// optional int32 Quantity = 4;
inline bool MarketDepthUpdateLevel_Int::has_quantity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDepthUpdateLevel_Int::set_has_quantity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDepthUpdateLevel_Int::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDepthUpdateLevel_Int::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline ::google::protobuf::int32 MarketDepthUpdateLevel_Int::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel_Int.Quantity)
  return quantity_;
}
inline void MarketDepthUpdateLevel_Int::set_quantity(::google::protobuf::int32 value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel_Int.Quantity)
}

// optional .DTC_PB.MarketDepthUpdateTypeEnum UpdateType = 5;
inline bool MarketDepthUpdateLevel_Int::has_updatetype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDepthUpdateLevel_Int::set_has_updatetype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDepthUpdateLevel_Int::clear_has_updatetype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDepthUpdateLevel_Int::clear_updatetype() {
  updatetype_ = 0;
  clear_has_updatetype();
}
inline ::DTC_PB::MarketDepthUpdateTypeEnum MarketDepthUpdateLevel_Int::updatetype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevel_Int.UpdateType)
  return static_cast< ::DTC_PB::MarketDepthUpdateTypeEnum >(updatetype_);
}
inline void MarketDepthUpdateLevel_Int::set_updatetype(::DTC_PB::MarketDepthUpdateTypeEnum value) {
  assert(::DTC_PB::MarketDepthUpdateTypeEnum_IsValid(value));
  set_has_updatetype();
  updatetype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevel_Int.UpdateType)
}

// -------------------------------------------------------------------

// MarketDepthUpdateLevelCompact

// optional uint32 SymbolID = 1;
inline bool MarketDepthUpdateLevelCompact::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDepthUpdateLevelCompact::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDepthUpdateLevelCompact::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDepthUpdateLevelCompact::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDepthUpdateLevelCompact::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevelCompact.SymbolID)
  return symbolid_;
}
inline void MarketDepthUpdateLevelCompact::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevelCompact.SymbolID)
}

// optional .DTC_PB.AtBidOrAskEnum Side = 2;
inline bool MarketDepthUpdateLevelCompact::has_side() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDepthUpdateLevelCompact::set_has_side() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDepthUpdateLevelCompact::clear_has_side() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDepthUpdateLevelCompact::clear_side() {
  side_ = 0;
  clear_has_side();
}
inline ::DTC_PB::AtBidOrAskEnum MarketDepthUpdateLevelCompact::side() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevelCompact.Side)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(side_);
}
inline void MarketDepthUpdateLevelCompact::set_side(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_side();
  side_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevelCompact.Side)
}

// optional float Price = 3;
inline bool MarketDepthUpdateLevelCompact::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDepthUpdateLevelCompact::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDepthUpdateLevelCompact::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDepthUpdateLevelCompact::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline float MarketDepthUpdateLevelCompact::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevelCompact.Price)
  return price_;
}
inline void MarketDepthUpdateLevelCompact::set_price(float value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevelCompact.Price)
}

// optional float Quantity = 4;
inline bool MarketDepthUpdateLevelCompact::has_quantity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDepthUpdateLevelCompact::set_has_quantity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDepthUpdateLevelCompact::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDepthUpdateLevelCompact::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline float MarketDepthUpdateLevelCompact::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevelCompact.Quantity)
  return quantity_;
}
inline void MarketDepthUpdateLevelCompact::set_quantity(float value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevelCompact.Quantity)
}

// optional .DTC_PB.MarketDepthUpdateTypeEnum UpdateType = 5;
inline bool MarketDepthUpdateLevelCompact::has_updatetype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDepthUpdateLevelCompact::set_has_updatetype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDepthUpdateLevelCompact::clear_has_updatetype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDepthUpdateLevelCompact::clear_updatetype() {
  updatetype_ = 0;
  clear_has_updatetype();
}
inline ::DTC_PB::MarketDepthUpdateTypeEnum MarketDepthUpdateLevelCompact::updatetype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthUpdateLevelCompact.UpdateType)
  return static_cast< ::DTC_PB::MarketDepthUpdateTypeEnum >(updatetype_);
}
inline void MarketDepthUpdateLevelCompact::set_updatetype(::DTC_PB::MarketDepthUpdateTypeEnum value) {
  assert(::DTC_PB::MarketDepthUpdateTypeEnum_IsValid(value));
  set_has_updatetype();
  updatetype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthUpdateLevelCompact.UpdateType)
}

// -------------------------------------------------------------------

// MarketDataUpdateSessionSettlement

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateSessionSettlement::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateSessionSettlement::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateSessionSettlement::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateSessionSettlement::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionSettlement::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionSettlement.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateSessionSettlement::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionSettlement.SymbolID)
}

// optional double Price = 2;
inline bool MarketDataUpdateSessionSettlement::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateSessionSettlement::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateSessionSettlement::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateSessionSettlement::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double MarketDataUpdateSessionSettlement::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionSettlement.Price)
  return price_;
}
inline void MarketDataUpdateSessionSettlement::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionSettlement.Price)
}

// -------------------------------------------------------------------

// MarketDataUpdateSessionSettlement_Int

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateSessionSettlement_Int::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateSessionSettlement_Int::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateSessionSettlement_Int::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateSessionSettlement_Int::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionSettlement_Int::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionSettlement_Int.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateSessionSettlement_Int::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionSettlement_Int.SymbolID)
}

// optional int32 Price = 2;
inline bool MarketDataUpdateSessionSettlement_Int::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateSessionSettlement_Int::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateSessionSettlement_Int::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateSessionSettlement_Int::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 MarketDataUpdateSessionSettlement_Int::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionSettlement_Int.Price)
  return price_;
}
inline void MarketDataUpdateSessionSettlement_Int::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionSettlement_Int.Price)
}

// -------------------------------------------------------------------

// MarketDataUpdateSessionOpen

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateSessionOpen::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateSessionOpen::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateSessionOpen::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateSessionOpen::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionOpen::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionOpen.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateSessionOpen::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionOpen.SymbolID)
}

// optional double Price = 2;
inline bool MarketDataUpdateSessionOpen::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateSessionOpen::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateSessionOpen::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateSessionOpen::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double MarketDataUpdateSessionOpen::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionOpen.Price)
  return price_;
}
inline void MarketDataUpdateSessionOpen::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionOpen.Price)
}

// -------------------------------------------------------------------

// MarketDataUpdateSessionOpen_Int

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateSessionOpen_Int::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateSessionOpen_Int::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateSessionOpen_Int::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateSessionOpen_Int::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionOpen_Int::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionOpen_Int.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateSessionOpen_Int::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionOpen_Int.SymbolID)
}

// optional int32 Price = 2;
inline bool MarketDataUpdateSessionOpen_Int::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateSessionOpen_Int::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateSessionOpen_Int::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateSessionOpen_Int::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 MarketDataUpdateSessionOpen_Int::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionOpen_Int.Price)
  return price_;
}
inline void MarketDataUpdateSessionOpen_Int::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionOpen_Int.Price)
}

// -------------------------------------------------------------------

// MarketDepthReject

// optional uint32 SymbolID = 1;
inline bool MarketDepthReject::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDepthReject::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDepthReject::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDepthReject::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDepthReject::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthReject.SymbolID)
  return symbolid_;
}
inline void MarketDepthReject::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthReject.SymbolID)
}

// optional string RejectText = 2;
inline bool MarketDepthReject::has_rejecttext() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDepthReject::set_has_rejecttext() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDepthReject::clear_has_rejecttext() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDepthReject::clear_rejecttext() {
  if (rejecttext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_->clear();
  }
  clear_has_rejecttext();
}
inline const ::std::string& MarketDepthReject::rejecttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDepthReject.RejectText)
  return *rejecttext_;
}
inline void MarketDepthReject::set_rejecttext(const ::std::string& value) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDepthReject.RejectText)
}
inline void MarketDepthReject::set_rejecttext(const char* value) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.MarketDepthReject.RejectText)
}
inline void MarketDepthReject::set_rejecttext(const char* value, size_t size) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.MarketDepthReject.RejectText)
}
inline ::std::string* MarketDepthReject::mutable_rejecttext() {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.MarketDepthReject.RejectText)
  return rejecttext_;
}
inline ::std::string* MarketDepthReject::release_rejecttext() {
  clear_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rejecttext_;
    rejecttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MarketDepthReject::set_allocated_rejecttext(::std::string* rejecttext) {
  if (rejecttext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rejecttext_;
  }
  if (rejecttext) {
    set_has_rejecttext();
    rejecttext_ = rejecttext;
  } else {
    clear_has_rejecttext();
    rejecttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.MarketDepthReject.RejectText)
}

// -------------------------------------------------------------------

// MarketDataUpdateTrade

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateTrade::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateTrade::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateTrade::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateTrade::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateTrade::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateTrade::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade.SymbolID)
}

// optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 2;
inline bool MarketDataUpdateTrade::has_atbidorask() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateTrade::set_has_atbidorask() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateTrade::clear_has_atbidorask() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateTrade::clear_atbidorask() {
  atbidorask_ = 0;
  clear_has_atbidorask();
}
inline ::DTC_PB::AtBidOrAskEnum MarketDataUpdateTrade::atbidorask() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade.AtBidOrAsk)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(atbidorask_);
}
inline void MarketDataUpdateTrade::set_atbidorask(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_atbidorask();
  atbidorask_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade.AtBidOrAsk)
}

// optional double Price = 3;
inline bool MarketDataUpdateTrade::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateTrade::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateTrade::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateTrade::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double MarketDataUpdateTrade::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade.Price)
  return price_;
}
inline void MarketDataUpdateTrade::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade.Price)
}

// optional double Volume = 4;
inline bool MarketDataUpdateTrade::has_volume() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataUpdateTrade::set_has_volume() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataUpdateTrade::clear_has_volume() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataUpdateTrade::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double MarketDataUpdateTrade::volume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade.Volume)
  return volume_;
}
inline void MarketDataUpdateTrade::set_volume(double value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade.Volume)
}

// optional double DateTime = 5;
inline bool MarketDataUpdateTrade::has_datetime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDataUpdateTrade::set_has_datetime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDataUpdateTrade::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDataUpdateTrade::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline double MarketDataUpdateTrade::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade.DateTime)
  return datetime_;
}
inline void MarketDataUpdateTrade::set_datetime(double value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade.DateTime)
}

// -------------------------------------------------------------------

// MarketDataUpdateTrade_Int

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateTrade_Int::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateTrade_Int::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateTrade_Int::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateTrade_Int::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateTrade_Int::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade_Int.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateTrade_Int::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade_Int.SymbolID)
}

// optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 2;
inline bool MarketDataUpdateTrade_Int::has_atbidorask() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateTrade_Int::set_has_atbidorask() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateTrade_Int::clear_has_atbidorask() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateTrade_Int::clear_atbidorask() {
  atbidorask_ = 0;
  clear_has_atbidorask();
}
inline ::DTC_PB::AtBidOrAskEnum MarketDataUpdateTrade_Int::atbidorask() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade_Int.AtBidOrAsk)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(atbidorask_);
}
inline void MarketDataUpdateTrade_Int::set_atbidorask(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_atbidorask();
  atbidorask_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade_Int.AtBidOrAsk)
}

// optional int32 Price = 3;
inline bool MarketDataUpdateTrade_Int::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateTrade_Int::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateTrade_Int::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateTrade_Int::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 MarketDataUpdateTrade_Int::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade_Int.Price)
  return price_;
}
inline void MarketDataUpdateTrade_Int::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade_Int.Price)
}

// optional int32 Volume = 4;
inline bool MarketDataUpdateTrade_Int::has_volume() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataUpdateTrade_Int::set_has_volume() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataUpdateTrade_Int::clear_has_volume() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataUpdateTrade_Int::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline ::google::protobuf::int32 MarketDataUpdateTrade_Int::volume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade_Int.Volume)
  return volume_;
}
inline void MarketDataUpdateTrade_Int::set_volume(::google::protobuf::int32 value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade_Int.Volume)
}

// optional double DateTime = 5;
inline bool MarketDataUpdateTrade_Int::has_datetime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDataUpdateTrade_Int::set_has_datetime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDataUpdateTrade_Int::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDataUpdateTrade_Int::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline double MarketDataUpdateTrade_Int::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTrade_Int.DateTime)
  return datetime_;
}
inline void MarketDataUpdateTrade_Int::set_datetime(double value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTrade_Int.DateTime)
}

// -------------------------------------------------------------------

// MarketDataUpdateBidAsk

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateBidAsk::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateBidAsk::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateBidAsk::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateBidAsk::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateBidAsk::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateBidAsk::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk.SymbolID)
}

// optional double BidPrice = 2;
inline bool MarketDataUpdateBidAsk::has_bidprice() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateBidAsk::set_has_bidprice() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateBidAsk::clear_has_bidprice() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateBidAsk::clear_bidprice() {
  bidprice_ = 0;
  clear_has_bidprice();
}
inline double MarketDataUpdateBidAsk::bidprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk.BidPrice)
  return bidprice_;
}
inline void MarketDataUpdateBidAsk::set_bidprice(double value) {
  set_has_bidprice();
  bidprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk.BidPrice)
}

// optional float BidQuantity = 3;
inline bool MarketDataUpdateBidAsk::has_bidquantity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateBidAsk::set_has_bidquantity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateBidAsk::clear_has_bidquantity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateBidAsk::clear_bidquantity() {
  bidquantity_ = 0;
  clear_has_bidquantity();
}
inline float MarketDataUpdateBidAsk::bidquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk.BidQuantity)
  return bidquantity_;
}
inline void MarketDataUpdateBidAsk::set_bidquantity(float value) {
  set_has_bidquantity();
  bidquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk.BidQuantity)
}

// optional double AskPrice = 4;
inline bool MarketDataUpdateBidAsk::has_askprice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataUpdateBidAsk::set_has_askprice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataUpdateBidAsk::clear_has_askprice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataUpdateBidAsk::clear_askprice() {
  askprice_ = 0;
  clear_has_askprice();
}
inline double MarketDataUpdateBidAsk::askprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk.AskPrice)
  return askprice_;
}
inline void MarketDataUpdateBidAsk::set_askprice(double value) {
  set_has_askprice();
  askprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk.AskPrice)
}

// optional float AskQuantity = 5;
inline bool MarketDataUpdateBidAsk::has_askquantity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDataUpdateBidAsk::set_has_askquantity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDataUpdateBidAsk::clear_has_askquantity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDataUpdateBidAsk::clear_askquantity() {
  askquantity_ = 0;
  clear_has_askquantity();
}
inline float MarketDataUpdateBidAsk::askquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk.AskQuantity)
  return askquantity_;
}
inline void MarketDataUpdateBidAsk::set_askquantity(float value) {
  set_has_askquantity();
  askquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk.AskQuantity)
}

// optional sfixed32 DateTime = 6;
inline bool MarketDataUpdateBidAsk::has_datetime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketDataUpdateBidAsk::set_has_datetime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketDataUpdateBidAsk::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketDataUpdateBidAsk::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline ::google::protobuf::int32 MarketDataUpdateBidAsk::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk.DateTime)
  return datetime_;
}
inline void MarketDataUpdateBidAsk::set_datetime(::google::protobuf::int32 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk.DateTime)
}

// -------------------------------------------------------------------

// MarketDataUpdateBidAsk_Int

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateBidAsk_Int::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateBidAsk_Int::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateBidAsk_Int::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateBidAsk_Int::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateBidAsk_Int::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk_Int.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateBidAsk_Int::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk_Int.SymbolID)
}

// optional int32 BidPrice = 2;
inline bool MarketDataUpdateBidAsk_Int::has_bidprice() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateBidAsk_Int::set_has_bidprice() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateBidAsk_Int::clear_has_bidprice() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateBidAsk_Int::clear_bidprice() {
  bidprice_ = 0;
  clear_has_bidprice();
}
inline ::google::protobuf::int32 MarketDataUpdateBidAsk_Int::bidprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk_Int.BidPrice)
  return bidprice_;
}
inline void MarketDataUpdateBidAsk_Int::set_bidprice(::google::protobuf::int32 value) {
  set_has_bidprice();
  bidprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk_Int.BidPrice)
}

// optional int32 BidQuantity = 3;
inline bool MarketDataUpdateBidAsk_Int::has_bidquantity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateBidAsk_Int::set_has_bidquantity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateBidAsk_Int::clear_has_bidquantity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateBidAsk_Int::clear_bidquantity() {
  bidquantity_ = 0;
  clear_has_bidquantity();
}
inline ::google::protobuf::int32 MarketDataUpdateBidAsk_Int::bidquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk_Int.BidQuantity)
  return bidquantity_;
}
inline void MarketDataUpdateBidAsk_Int::set_bidquantity(::google::protobuf::int32 value) {
  set_has_bidquantity();
  bidquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk_Int.BidQuantity)
}

// optional int32 AskPrice = 4;
inline bool MarketDataUpdateBidAsk_Int::has_askprice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataUpdateBidAsk_Int::set_has_askprice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataUpdateBidAsk_Int::clear_has_askprice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataUpdateBidAsk_Int::clear_askprice() {
  askprice_ = 0;
  clear_has_askprice();
}
inline ::google::protobuf::int32 MarketDataUpdateBidAsk_Int::askprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk_Int.AskPrice)
  return askprice_;
}
inline void MarketDataUpdateBidAsk_Int::set_askprice(::google::protobuf::int32 value) {
  set_has_askprice();
  askprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk_Int.AskPrice)
}

// optional int32 AskQuantity = 5;
inline bool MarketDataUpdateBidAsk_Int::has_askquantity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDataUpdateBidAsk_Int::set_has_askquantity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDataUpdateBidAsk_Int::clear_has_askquantity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDataUpdateBidAsk_Int::clear_askquantity() {
  askquantity_ = 0;
  clear_has_askquantity();
}
inline ::google::protobuf::int32 MarketDataUpdateBidAsk_Int::askquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk_Int.AskQuantity)
  return askquantity_;
}
inline void MarketDataUpdateBidAsk_Int::set_askquantity(::google::protobuf::int32 value) {
  set_has_askquantity();
  askquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk_Int.AskQuantity)
}

// optional sfixed32 DateTime = 6;
inline bool MarketDataUpdateBidAsk_Int::has_datetime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketDataUpdateBidAsk_Int::set_has_datetime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketDataUpdateBidAsk_Int::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketDataUpdateBidAsk_Int::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline ::google::protobuf::int32 MarketDataUpdateBidAsk_Int::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAsk_Int.DateTime)
  return datetime_;
}
inline void MarketDataUpdateBidAsk_Int::set_datetime(::google::protobuf::int32 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAsk_Int.DateTime)
}

// -------------------------------------------------------------------

// MarketDataUpdateBidAskCompact

// optional float BidPrice = 1;
inline bool MarketDataUpdateBidAskCompact::has_bidprice() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateBidAskCompact::set_has_bidprice() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateBidAskCompact::clear_has_bidprice() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateBidAskCompact::clear_bidprice() {
  bidprice_ = 0;
  clear_has_bidprice();
}
inline float MarketDataUpdateBidAskCompact::bidprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAskCompact.BidPrice)
  return bidprice_;
}
inline void MarketDataUpdateBidAskCompact::set_bidprice(float value) {
  set_has_bidprice();
  bidprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAskCompact.BidPrice)
}

// optional float BidQuantity = 2;
inline bool MarketDataUpdateBidAskCompact::has_bidquantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateBidAskCompact::set_has_bidquantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateBidAskCompact::clear_has_bidquantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateBidAskCompact::clear_bidquantity() {
  bidquantity_ = 0;
  clear_has_bidquantity();
}
inline float MarketDataUpdateBidAskCompact::bidquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAskCompact.BidQuantity)
  return bidquantity_;
}
inline void MarketDataUpdateBidAskCompact::set_bidquantity(float value) {
  set_has_bidquantity();
  bidquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAskCompact.BidQuantity)
}

// optional float AskPrice = 3;
inline bool MarketDataUpdateBidAskCompact::has_askprice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateBidAskCompact::set_has_askprice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateBidAskCompact::clear_has_askprice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateBidAskCompact::clear_askprice() {
  askprice_ = 0;
  clear_has_askprice();
}
inline float MarketDataUpdateBidAskCompact::askprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAskCompact.AskPrice)
  return askprice_;
}
inline void MarketDataUpdateBidAskCompact::set_askprice(float value) {
  set_has_askprice();
  askprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAskCompact.AskPrice)
}

// optional float AskQuantity = 4;
inline bool MarketDataUpdateBidAskCompact::has_askquantity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataUpdateBidAskCompact::set_has_askquantity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataUpdateBidAskCompact::clear_has_askquantity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataUpdateBidAskCompact::clear_askquantity() {
  askquantity_ = 0;
  clear_has_askquantity();
}
inline float MarketDataUpdateBidAskCompact::askquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAskCompact.AskQuantity)
  return askquantity_;
}
inline void MarketDataUpdateBidAskCompact::set_askquantity(float value) {
  set_has_askquantity();
  askquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAskCompact.AskQuantity)
}

// optional sfixed32 DateTime = 5;
inline bool MarketDataUpdateBidAskCompact::has_datetime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDataUpdateBidAskCompact::set_has_datetime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDataUpdateBidAskCompact::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDataUpdateBidAskCompact::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline ::google::protobuf::int32 MarketDataUpdateBidAskCompact::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAskCompact.DateTime)
  return datetime_;
}
inline void MarketDataUpdateBidAskCompact::set_datetime(::google::protobuf::int32 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAskCompact.DateTime)
}

// optional uint32 SymbolID = 6;
inline bool MarketDataUpdateBidAskCompact::has_symbolid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketDataUpdateBidAskCompact::set_has_symbolid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketDataUpdateBidAskCompact::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketDataUpdateBidAskCompact::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateBidAskCompact::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateBidAskCompact.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateBidAskCompact::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateBidAskCompact.SymbolID)
}

// -------------------------------------------------------------------

// MarketDataUpdateTradeCompact

// optional float Price = 1;
inline bool MarketDataUpdateTradeCompact::has_price() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateTradeCompact::set_has_price() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateTradeCompact::clear_has_price() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateTradeCompact::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline float MarketDataUpdateTradeCompact::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTradeCompact.Price)
  return price_;
}
inline void MarketDataUpdateTradeCompact::set_price(float value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTradeCompact.Price)
}

// optional float Volume = 2;
inline bool MarketDataUpdateTradeCompact::has_volume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateTradeCompact::set_has_volume() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateTradeCompact::clear_has_volume() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateTradeCompact::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline float MarketDataUpdateTradeCompact::volume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTradeCompact.Volume)
  return volume_;
}
inline void MarketDataUpdateTradeCompact::set_volume(float value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTradeCompact.Volume)
}

// optional sfixed32 DateTime = 3;
inline bool MarketDataUpdateTradeCompact::has_datetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateTradeCompact::set_has_datetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateTradeCompact::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateTradeCompact::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline ::google::protobuf::int32 MarketDataUpdateTradeCompact::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTradeCompact.DateTime)
  return datetime_;
}
inline void MarketDataUpdateTradeCompact::set_datetime(::google::protobuf::int32 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTradeCompact.DateTime)
}

// optional uint32 SymbolID = 4;
inline bool MarketDataUpdateTradeCompact::has_symbolid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataUpdateTradeCompact::set_has_symbolid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataUpdateTradeCompact::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataUpdateTradeCompact::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateTradeCompact::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTradeCompact.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateTradeCompact::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTradeCompact.SymbolID)
}

// optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 5;
inline bool MarketDataUpdateTradeCompact::has_atbidorask() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDataUpdateTradeCompact::set_has_atbidorask() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDataUpdateTradeCompact::clear_has_atbidorask() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDataUpdateTradeCompact::clear_atbidorask() {
  atbidorask_ = 0;
  clear_has_atbidorask();
}
inline ::DTC_PB::AtBidOrAskEnum MarketDataUpdateTradeCompact::atbidorask() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateTradeCompact.AtBidOrAsk)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(atbidorask_);
}
inline void MarketDataUpdateTradeCompact::set_atbidorask(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_atbidorask();
  atbidorask_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateTradeCompact.AtBidOrAsk)
}

// -------------------------------------------------------------------

// MarketDataUpdateSessionVolume

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateSessionVolume::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateSessionVolume::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateSessionVolume::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateSessionVolume::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionVolume::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionVolume.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateSessionVolume::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionVolume.SymbolID)
}

// optional double Volume = 2;
inline bool MarketDataUpdateSessionVolume::has_volume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateSessionVolume::set_has_volume() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateSessionVolume::clear_has_volume() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateSessionVolume::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double MarketDataUpdateSessionVolume::volume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionVolume.Volume)
  return volume_;
}
inline void MarketDataUpdateSessionVolume::set_volume(double value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionVolume.Volume)
}

// -------------------------------------------------------------------

// MarketDataUpdateOpenInterest

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateOpenInterest::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateOpenInterest::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateOpenInterest::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateOpenInterest::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateOpenInterest::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateOpenInterest.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateOpenInterest::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateOpenInterest.SymbolID)
}

// optional uint32 OpenInterest = 2;
inline bool MarketDataUpdateOpenInterest::has_openinterest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateOpenInterest::set_has_openinterest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateOpenInterest::clear_has_openinterest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateOpenInterest::clear_openinterest() {
  openinterest_ = 0u;
  clear_has_openinterest();
}
inline ::google::protobuf::uint32 MarketDataUpdateOpenInterest::openinterest() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateOpenInterest.OpenInterest)
  return openinterest_;
}
inline void MarketDataUpdateOpenInterest::set_openinterest(::google::protobuf::uint32 value) {
  set_has_openinterest();
  openinterest_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateOpenInterest.OpenInterest)
}

// -------------------------------------------------------------------

// MarketDataUpdateSessionHigh

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateSessionHigh::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateSessionHigh::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateSessionHigh::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateSessionHigh::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionHigh::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionHigh.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateSessionHigh::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionHigh.SymbolID)
}

// optional double Price = 2;
inline bool MarketDataUpdateSessionHigh::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateSessionHigh::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateSessionHigh::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateSessionHigh::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double MarketDataUpdateSessionHigh::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionHigh.Price)
  return price_;
}
inline void MarketDataUpdateSessionHigh::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionHigh.Price)
}

// -------------------------------------------------------------------

// MarketDataUpdateSessionHigh_Int

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateSessionHigh_Int::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateSessionHigh_Int::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateSessionHigh_Int::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateSessionHigh_Int::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionHigh_Int::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionHigh_Int.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateSessionHigh_Int::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionHigh_Int.SymbolID)
}

// optional int32 Price = 2;
inline bool MarketDataUpdateSessionHigh_Int::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateSessionHigh_Int::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateSessionHigh_Int::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateSessionHigh_Int::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 MarketDataUpdateSessionHigh_Int::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionHigh_Int.Price)
  return price_;
}
inline void MarketDataUpdateSessionHigh_Int::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionHigh_Int.Price)
}

// -------------------------------------------------------------------

// MarketDataUpdateSessionLow

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateSessionLow::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateSessionLow::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateSessionLow::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateSessionLow::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionLow::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionLow.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateSessionLow::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionLow.SymbolID)
}

// optional double Price = 2;
inline bool MarketDataUpdateSessionLow::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateSessionLow::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateSessionLow::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateSessionLow::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double MarketDataUpdateSessionLow::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionLow.Price)
  return price_;
}
inline void MarketDataUpdateSessionLow::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionLow.Price)
}

// -------------------------------------------------------------------

// MarketDataUpdateSessionLow_Int

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateSessionLow_Int::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateSessionLow_Int::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateSessionLow_Int::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateSessionLow_Int::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateSessionLow_Int::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionLow_Int.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateSessionLow_Int::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionLow_Int.SymbolID)
}

// optional int32 Price = 2;
inline bool MarketDataUpdateSessionLow_Int::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateSessionLow_Int::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateSessionLow_Int::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateSessionLow_Int::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 MarketDataUpdateSessionLow_Int::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateSessionLow_Int.Price)
  return price_;
}
inline void MarketDataUpdateSessionLow_Int::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateSessionLow_Int.Price)
}

// -------------------------------------------------------------------

// MarketDataUpdateLastTradeSnapshot

// optional uint32 SymbolID = 1;
inline bool MarketDataUpdateLastTradeSnapshot::has_symbolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataUpdateLastTradeSnapshot::set_has_symbolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataUpdateLastTradeSnapshot::clear_has_symbolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataUpdateLastTradeSnapshot::clear_symbolid() {
  symbolid_ = 0u;
  clear_has_symbolid();
}
inline ::google::protobuf::uint32 MarketDataUpdateLastTradeSnapshot::symbolid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateLastTradeSnapshot.SymbolID)
  return symbolid_;
}
inline void MarketDataUpdateLastTradeSnapshot::set_symbolid(::google::protobuf::uint32 value) {
  set_has_symbolid();
  symbolid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateLastTradeSnapshot.SymbolID)
}

// optional double LastTradePrice = 2;
inline bool MarketDataUpdateLastTradeSnapshot::has_lasttradeprice() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataUpdateLastTradeSnapshot::set_has_lasttradeprice() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataUpdateLastTradeSnapshot::clear_has_lasttradeprice() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataUpdateLastTradeSnapshot::clear_lasttradeprice() {
  lasttradeprice_ = 0;
  clear_has_lasttradeprice();
}
inline double MarketDataUpdateLastTradeSnapshot::lasttradeprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateLastTradeSnapshot.LastTradePrice)
  return lasttradeprice_;
}
inline void MarketDataUpdateLastTradeSnapshot::set_lasttradeprice(double value) {
  set_has_lasttradeprice();
  lasttradeprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateLastTradeSnapshot.LastTradePrice)
}

// optional double LastTradeVolume = 3;
inline bool MarketDataUpdateLastTradeSnapshot::has_lasttradevolume() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataUpdateLastTradeSnapshot::set_has_lasttradevolume() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataUpdateLastTradeSnapshot::clear_has_lasttradevolume() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataUpdateLastTradeSnapshot::clear_lasttradevolume() {
  lasttradevolume_ = 0;
  clear_has_lasttradevolume();
}
inline double MarketDataUpdateLastTradeSnapshot::lasttradevolume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateLastTradeSnapshot.LastTradeVolume)
  return lasttradevolume_;
}
inline void MarketDataUpdateLastTradeSnapshot::set_lasttradevolume(double value) {
  set_has_lasttradevolume();
  lasttradevolume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateLastTradeSnapshot.LastTradeVolume)
}

// optional double LastTradeDateTime = 4;
inline bool MarketDataUpdateLastTradeSnapshot::has_lasttradedatetime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataUpdateLastTradeSnapshot::set_has_lasttradedatetime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataUpdateLastTradeSnapshot::clear_has_lasttradedatetime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataUpdateLastTradeSnapshot::clear_lasttradedatetime() {
  lasttradedatetime_ = 0;
  clear_has_lasttradedatetime();
}
inline double MarketDataUpdateLastTradeSnapshot::lasttradedatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.MarketDataUpdateLastTradeSnapshot.LastTradeDateTime)
  return lasttradedatetime_;
}
inline void MarketDataUpdateLastTradeSnapshot::set_lasttradedatetime(double value) {
  set_has_lasttradedatetime();
  lasttradedatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.MarketDataUpdateLastTradeSnapshot.LastTradeDateTime)
}

// -------------------------------------------------------------------

// SubmitNewSingleOrder

// optional string Symbol = 1;
inline bool SubmitNewSingleOrder::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubmitNewSingleOrder::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubmitNewSingleOrder::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubmitNewSingleOrder::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& SubmitNewSingleOrder::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.Symbol)
  return *symbol_;
}
inline void SubmitNewSingleOrder::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.Symbol)
}
inline void SubmitNewSingleOrder::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrder.Symbol)
}
inline void SubmitNewSingleOrder::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrder.Symbol)
}
inline ::std::string* SubmitNewSingleOrder::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrder.Symbol)
  return symbol_;
}
inline ::std::string* SubmitNewSingleOrder::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewSingleOrder::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrder.Symbol)
}

// optional string Exchange = 2;
inline bool SubmitNewSingleOrder::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubmitNewSingleOrder::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubmitNewSingleOrder::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubmitNewSingleOrder::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& SubmitNewSingleOrder::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.Exchange)
  return *exchange_;
}
inline void SubmitNewSingleOrder::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.Exchange)
}
inline void SubmitNewSingleOrder::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrder.Exchange)
}
inline void SubmitNewSingleOrder::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrder.Exchange)
}
inline ::std::string* SubmitNewSingleOrder::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrder.Exchange)
  return exchange_;
}
inline ::std::string* SubmitNewSingleOrder::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewSingleOrder::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrder.Exchange)
}

// optional string TradeAccount = 3;
inline bool SubmitNewSingleOrder::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubmitNewSingleOrder::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubmitNewSingleOrder::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubmitNewSingleOrder::clear_tradeaccount() {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_->clear();
  }
  clear_has_tradeaccount();
}
inline const ::std::string& SubmitNewSingleOrder::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.TradeAccount)
  return *tradeaccount_;
}
inline void SubmitNewSingleOrder::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.TradeAccount)
}
inline void SubmitNewSingleOrder::set_tradeaccount(const char* value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrder.TradeAccount)
}
inline void SubmitNewSingleOrder::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrder.TradeAccount)
}
inline ::std::string* SubmitNewSingleOrder::mutable_tradeaccount() {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrder.TradeAccount)
  return tradeaccount_;
}
inline ::std::string* SubmitNewSingleOrder::release_tradeaccount() {
  clear_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tradeaccount_;
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewSingleOrder::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tradeaccount_;
  }
  if (tradeaccount) {
    set_has_tradeaccount();
    tradeaccount_ = tradeaccount;
  } else {
    clear_has_tradeaccount();
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrder.TradeAccount)
}

// optional string ClientOrderID = 4;
inline bool SubmitNewSingleOrder::has_clientorderid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubmitNewSingleOrder::set_has_clientorderid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubmitNewSingleOrder::clear_has_clientorderid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubmitNewSingleOrder::clear_clientorderid() {
  if (clientorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_->clear();
  }
  clear_has_clientorderid();
}
inline const ::std::string& SubmitNewSingleOrder::clientorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.ClientOrderID)
  return *clientorderid_;
}
inline void SubmitNewSingleOrder::set_clientorderid(const ::std::string& value) {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  clientorderid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.ClientOrderID)
}
inline void SubmitNewSingleOrder::set_clientorderid(const char* value) {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  clientorderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrder.ClientOrderID)
}
inline void SubmitNewSingleOrder::set_clientorderid(const char* value, size_t size) {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  clientorderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrder.ClientOrderID)
}
inline ::std::string* SubmitNewSingleOrder::mutable_clientorderid() {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrder.ClientOrderID)
  return clientorderid_;
}
inline ::std::string* SubmitNewSingleOrder::release_clientorderid() {
  clear_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientorderid_;
    clientorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewSingleOrder::set_allocated_clientorderid(::std::string* clientorderid) {
  if (clientorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientorderid_;
  }
  if (clientorderid) {
    set_has_clientorderid();
    clientorderid_ = clientorderid;
  } else {
    clear_has_clientorderid();
    clientorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrder.ClientOrderID)
}

// optional .DTC_PB.OrderTypeEnum OrderType = 5;
inline bool SubmitNewSingleOrder::has_ordertype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubmitNewSingleOrder::set_has_ordertype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubmitNewSingleOrder::clear_has_ordertype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubmitNewSingleOrder::clear_ordertype() {
  ordertype_ = 0;
  clear_has_ordertype();
}
inline ::DTC_PB::OrderTypeEnum SubmitNewSingleOrder::ordertype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.OrderType)
  return static_cast< ::DTC_PB::OrderTypeEnum >(ordertype_);
}
inline void SubmitNewSingleOrder::set_ordertype(::DTC_PB::OrderTypeEnum value) {
  assert(::DTC_PB::OrderTypeEnum_IsValid(value));
  set_has_ordertype();
  ordertype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.OrderType)
}

// optional .DTC_PB.BuySellEnum BuySell = 6;
inline bool SubmitNewSingleOrder::has_buysell() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SubmitNewSingleOrder::set_has_buysell() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SubmitNewSingleOrder::clear_has_buysell() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SubmitNewSingleOrder::clear_buysell() {
  buysell_ = 0;
  clear_has_buysell();
}
inline ::DTC_PB::BuySellEnum SubmitNewSingleOrder::buysell() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.BuySell)
  return static_cast< ::DTC_PB::BuySellEnum >(buysell_);
}
inline void SubmitNewSingleOrder::set_buysell(::DTC_PB::BuySellEnum value) {
  assert(::DTC_PB::BuySellEnum_IsValid(value));
  set_has_buysell();
  buysell_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.BuySell)
}

// optional double Price1 = 7;
inline bool SubmitNewSingleOrder::has_price1() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SubmitNewSingleOrder::set_has_price1() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SubmitNewSingleOrder::clear_has_price1() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SubmitNewSingleOrder::clear_price1() {
  price1_ = 0;
  clear_has_price1();
}
inline double SubmitNewSingleOrder::price1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.Price1)
  return price1_;
}
inline void SubmitNewSingleOrder::set_price1(double value) {
  set_has_price1();
  price1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.Price1)
}

// optional double Price2 = 8;
inline bool SubmitNewSingleOrder::has_price2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SubmitNewSingleOrder::set_has_price2() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SubmitNewSingleOrder::clear_has_price2() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SubmitNewSingleOrder::clear_price2() {
  price2_ = 0;
  clear_has_price2();
}
inline double SubmitNewSingleOrder::price2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.Price2)
  return price2_;
}
inline void SubmitNewSingleOrder::set_price2(double value) {
  set_has_price2();
  price2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.Price2)
}

// optional double Quantity = 9;
inline bool SubmitNewSingleOrder::has_quantity() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SubmitNewSingleOrder::set_has_quantity() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SubmitNewSingleOrder::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SubmitNewSingleOrder::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline double SubmitNewSingleOrder::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.Quantity)
  return quantity_;
}
inline void SubmitNewSingleOrder::set_quantity(double value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.Quantity)
}

// optional .DTC_PB.TimeInForceEnum TimeInForce = 10;
inline bool SubmitNewSingleOrder::has_timeinforce() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SubmitNewSingleOrder::set_has_timeinforce() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SubmitNewSingleOrder::clear_has_timeinforce() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SubmitNewSingleOrder::clear_timeinforce() {
  timeinforce_ = 0;
  clear_has_timeinforce();
}
inline ::DTC_PB::TimeInForceEnum SubmitNewSingleOrder::timeinforce() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.TimeInForce)
  return static_cast< ::DTC_PB::TimeInForceEnum >(timeinforce_);
}
inline void SubmitNewSingleOrder::set_timeinforce(::DTC_PB::TimeInForceEnum value) {
  assert(::DTC_PB::TimeInForceEnum_IsValid(value));
  set_has_timeinforce();
  timeinforce_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.TimeInForce)
}

// optional sfixed64 GoodTillDateTime = 11;
inline bool SubmitNewSingleOrder::has_goodtilldatetime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SubmitNewSingleOrder::set_has_goodtilldatetime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SubmitNewSingleOrder::clear_has_goodtilldatetime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SubmitNewSingleOrder::clear_goodtilldatetime() {
  goodtilldatetime_ = GOOGLE_LONGLONG(0);
  clear_has_goodtilldatetime();
}
inline ::google::protobuf::int64 SubmitNewSingleOrder::goodtilldatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.GoodTillDateTime)
  return goodtilldatetime_;
}
inline void SubmitNewSingleOrder::set_goodtilldatetime(::google::protobuf::int64 value) {
  set_has_goodtilldatetime();
  goodtilldatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.GoodTillDateTime)
}

// optional uint32 IsAutomatedOrder = 12;
inline bool SubmitNewSingleOrder::has_isautomatedorder() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SubmitNewSingleOrder::set_has_isautomatedorder() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SubmitNewSingleOrder::clear_has_isautomatedorder() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SubmitNewSingleOrder::clear_isautomatedorder() {
  isautomatedorder_ = 0u;
  clear_has_isautomatedorder();
}
inline ::google::protobuf::uint32 SubmitNewSingleOrder::isautomatedorder() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.IsAutomatedOrder)
  return isautomatedorder_;
}
inline void SubmitNewSingleOrder::set_isautomatedorder(::google::protobuf::uint32 value) {
  set_has_isautomatedorder();
  isautomatedorder_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.IsAutomatedOrder)
}

// optional uint32 IsParentOrder = 13;
inline bool SubmitNewSingleOrder::has_isparentorder() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SubmitNewSingleOrder::set_has_isparentorder() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SubmitNewSingleOrder::clear_has_isparentorder() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SubmitNewSingleOrder::clear_isparentorder() {
  isparentorder_ = 0u;
  clear_has_isparentorder();
}
inline ::google::protobuf::uint32 SubmitNewSingleOrder::isparentorder() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.IsParentOrder)
  return isparentorder_;
}
inline void SubmitNewSingleOrder::set_isparentorder(::google::protobuf::uint32 value) {
  set_has_isparentorder();
  isparentorder_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.IsParentOrder)
}

// optional string FreeFormText = 14;
inline bool SubmitNewSingleOrder::has_freeformtext() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SubmitNewSingleOrder::set_has_freeformtext() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SubmitNewSingleOrder::clear_has_freeformtext() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SubmitNewSingleOrder::clear_freeformtext() {
  if (freeformtext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_->clear();
  }
  clear_has_freeformtext();
}
inline const ::std::string& SubmitNewSingleOrder::freeformtext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.FreeFormText)
  return *freeformtext_;
}
inline void SubmitNewSingleOrder::set_freeformtext(const ::std::string& value) {
  set_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_ = new ::std::string;
  }
  freeformtext_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.FreeFormText)
}
inline void SubmitNewSingleOrder::set_freeformtext(const char* value) {
  set_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_ = new ::std::string;
  }
  freeformtext_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrder.FreeFormText)
}
inline void SubmitNewSingleOrder::set_freeformtext(const char* value, size_t size) {
  set_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_ = new ::std::string;
  }
  freeformtext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrder.FreeFormText)
}
inline ::std::string* SubmitNewSingleOrder::mutable_freeformtext() {
  set_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrder.FreeFormText)
  return freeformtext_;
}
inline ::std::string* SubmitNewSingleOrder::release_freeformtext() {
  clear_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = freeformtext_;
    freeformtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewSingleOrder::set_allocated_freeformtext(::std::string* freeformtext) {
  if (freeformtext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete freeformtext_;
  }
  if (freeformtext) {
    set_has_freeformtext();
    freeformtext_ = freeformtext;
  } else {
    clear_has_freeformtext();
    freeformtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrder.FreeFormText)
}

// optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 15;
inline bool SubmitNewSingleOrder::has_openorclose() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SubmitNewSingleOrder::set_has_openorclose() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SubmitNewSingleOrder::clear_has_openorclose() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SubmitNewSingleOrder::clear_openorclose() {
  openorclose_ = 0;
  clear_has_openorclose();
}
inline ::DTC_PB::OpenCloseTradeEnum SubmitNewSingleOrder::openorclose() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrder.OpenOrClose)
  return static_cast< ::DTC_PB::OpenCloseTradeEnum >(openorclose_);
}
inline void SubmitNewSingleOrder::set_openorclose(::DTC_PB::OpenCloseTradeEnum value) {
  assert(::DTC_PB::OpenCloseTradeEnum_IsValid(value));
  set_has_openorclose();
  openorclose_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrder.OpenOrClose)
}

// -------------------------------------------------------------------

// SubmitNewSingleOrderInt

// optional string Symbol = 1;
inline bool SubmitNewSingleOrderInt::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubmitNewSingleOrderInt::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubmitNewSingleOrderInt::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& SubmitNewSingleOrderInt::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.Symbol)
  return *symbol_;
}
inline void SubmitNewSingleOrderInt::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.Symbol)
}
inline void SubmitNewSingleOrderInt::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrderInt.Symbol)
}
inline void SubmitNewSingleOrderInt::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrderInt.Symbol)
}
inline ::std::string* SubmitNewSingleOrderInt::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrderInt.Symbol)
  return symbol_;
}
inline ::std::string* SubmitNewSingleOrderInt::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewSingleOrderInt::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrderInt.Symbol)
}

// optional string Exchange = 2;
inline bool SubmitNewSingleOrderInt::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubmitNewSingleOrderInt::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubmitNewSingleOrderInt::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& SubmitNewSingleOrderInt::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.Exchange)
  return *exchange_;
}
inline void SubmitNewSingleOrderInt::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.Exchange)
}
inline void SubmitNewSingleOrderInt::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrderInt.Exchange)
}
inline void SubmitNewSingleOrderInt::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrderInt.Exchange)
}
inline ::std::string* SubmitNewSingleOrderInt::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrderInt.Exchange)
  return exchange_;
}
inline ::std::string* SubmitNewSingleOrderInt::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewSingleOrderInt::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrderInt.Exchange)
}

// optional string TradeAccount = 3;
inline bool SubmitNewSingleOrderInt::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubmitNewSingleOrderInt::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubmitNewSingleOrderInt::clear_tradeaccount() {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_->clear();
  }
  clear_has_tradeaccount();
}
inline const ::std::string& SubmitNewSingleOrderInt::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.TradeAccount)
  return *tradeaccount_;
}
inline void SubmitNewSingleOrderInt::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.TradeAccount)
}
inline void SubmitNewSingleOrderInt::set_tradeaccount(const char* value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrderInt.TradeAccount)
}
inline void SubmitNewSingleOrderInt::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrderInt.TradeAccount)
}
inline ::std::string* SubmitNewSingleOrderInt::mutable_tradeaccount() {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrderInt.TradeAccount)
  return tradeaccount_;
}
inline ::std::string* SubmitNewSingleOrderInt::release_tradeaccount() {
  clear_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tradeaccount_;
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewSingleOrderInt::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tradeaccount_;
  }
  if (tradeaccount) {
    set_has_tradeaccount();
    tradeaccount_ = tradeaccount;
  } else {
    clear_has_tradeaccount();
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrderInt.TradeAccount)
}

// optional string ClientOrderID = 4;
inline bool SubmitNewSingleOrderInt::has_clientorderid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_clientorderid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubmitNewSingleOrderInt::clear_has_clientorderid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubmitNewSingleOrderInt::clear_clientorderid() {
  if (clientorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_->clear();
  }
  clear_has_clientorderid();
}
inline const ::std::string& SubmitNewSingleOrderInt::clientorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.ClientOrderID)
  return *clientorderid_;
}
inline void SubmitNewSingleOrderInt::set_clientorderid(const ::std::string& value) {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  clientorderid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.ClientOrderID)
}
inline void SubmitNewSingleOrderInt::set_clientorderid(const char* value) {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  clientorderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrderInt.ClientOrderID)
}
inline void SubmitNewSingleOrderInt::set_clientorderid(const char* value, size_t size) {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  clientorderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrderInt.ClientOrderID)
}
inline ::std::string* SubmitNewSingleOrderInt::mutable_clientorderid() {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrderInt.ClientOrderID)
  return clientorderid_;
}
inline ::std::string* SubmitNewSingleOrderInt::release_clientorderid() {
  clear_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientorderid_;
    clientorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewSingleOrderInt::set_allocated_clientorderid(::std::string* clientorderid) {
  if (clientorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientorderid_;
  }
  if (clientorderid) {
    set_has_clientorderid();
    clientorderid_ = clientorderid;
  } else {
    clear_has_clientorderid();
    clientorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrderInt.ClientOrderID)
}

// optional .DTC_PB.OrderTypeEnum OrderType = 5;
inline bool SubmitNewSingleOrderInt::has_ordertype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_ordertype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubmitNewSingleOrderInt::clear_has_ordertype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubmitNewSingleOrderInt::clear_ordertype() {
  ordertype_ = 0;
  clear_has_ordertype();
}
inline ::DTC_PB::OrderTypeEnum SubmitNewSingleOrderInt::ordertype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.OrderType)
  return static_cast< ::DTC_PB::OrderTypeEnum >(ordertype_);
}
inline void SubmitNewSingleOrderInt::set_ordertype(::DTC_PB::OrderTypeEnum value) {
  assert(::DTC_PB::OrderTypeEnum_IsValid(value));
  set_has_ordertype();
  ordertype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.OrderType)
}

// optional .DTC_PB.BuySellEnum BuySell = 6;
inline bool SubmitNewSingleOrderInt::has_buysell() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_buysell() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SubmitNewSingleOrderInt::clear_has_buysell() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SubmitNewSingleOrderInt::clear_buysell() {
  buysell_ = 0;
  clear_has_buysell();
}
inline ::DTC_PB::BuySellEnum SubmitNewSingleOrderInt::buysell() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.BuySell)
  return static_cast< ::DTC_PB::BuySellEnum >(buysell_);
}
inline void SubmitNewSingleOrderInt::set_buysell(::DTC_PB::BuySellEnum value) {
  assert(::DTC_PB::BuySellEnum_IsValid(value));
  set_has_buysell();
  buysell_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.BuySell)
}

// optional int64 Price1 = 7;
inline bool SubmitNewSingleOrderInt::has_price1() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_price1() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SubmitNewSingleOrderInt::clear_has_price1() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SubmitNewSingleOrderInt::clear_price1() {
  price1_ = GOOGLE_LONGLONG(0);
  clear_has_price1();
}
inline ::google::protobuf::int64 SubmitNewSingleOrderInt::price1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.Price1)
  return price1_;
}
inline void SubmitNewSingleOrderInt::set_price1(::google::protobuf::int64 value) {
  set_has_price1();
  price1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.Price1)
}

// optional int64 Price2 = 8;
inline bool SubmitNewSingleOrderInt::has_price2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_price2() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SubmitNewSingleOrderInt::clear_has_price2() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SubmitNewSingleOrderInt::clear_price2() {
  price2_ = GOOGLE_LONGLONG(0);
  clear_has_price2();
}
inline ::google::protobuf::int64 SubmitNewSingleOrderInt::price2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.Price2)
  return price2_;
}
inline void SubmitNewSingleOrderInt::set_price2(::google::protobuf::int64 value) {
  set_has_price2();
  price2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.Price2)
}

// optional float Divisor = 9;
inline bool SubmitNewSingleOrderInt::has_divisor() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_divisor() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SubmitNewSingleOrderInt::clear_has_divisor() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SubmitNewSingleOrderInt::clear_divisor() {
  divisor_ = 0;
  clear_has_divisor();
}
inline float SubmitNewSingleOrderInt::divisor() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.Divisor)
  return divisor_;
}
inline void SubmitNewSingleOrderInt::set_divisor(float value) {
  set_has_divisor();
  divisor_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.Divisor)
}

// optional int64 Quantity = 10;
inline bool SubmitNewSingleOrderInt::has_quantity() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_quantity() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SubmitNewSingleOrderInt::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SubmitNewSingleOrderInt::clear_quantity() {
  quantity_ = GOOGLE_LONGLONG(0);
  clear_has_quantity();
}
inline ::google::protobuf::int64 SubmitNewSingleOrderInt::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.Quantity)
  return quantity_;
}
inline void SubmitNewSingleOrderInt::set_quantity(::google::protobuf::int64 value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.Quantity)
}

// optional .DTC_PB.TimeInForceEnum TimeInForce = 11;
inline bool SubmitNewSingleOrderInt::has_timeinforce() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_timeinforce() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SubmitNewSingleOrderInt::clear_has_timeinforce() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SubmitNewSingleOrderInt::clear_timeinforce() {
  timeinforce_ = 0;
  clear_has_timeinforce();
}
inline ::DTC_PB::TimeInForceEnum SubmitNewSingleOrderInt::timeinforce() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.TimeInForce)
  return static_cast< ::DTC_PB::TimeInForceEnum >(timeinforce_);
}
inline void SubmitNewSingleOrderInt::set_timeinforce(::DTC_PB::TimeInForceEnum value) {
  assert(::DTC_PB::TimeInForceEnum_IsValid(value));
  set_has_timeinforce();
  timeinforce_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.TimeInForce)
}

// optional sfixed64 GoodTillDateTime = 12;
inline bool SubmitNewSingleOrderInt::has_goodtilldatetime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_goodtilldatetime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SubmitNewSingleOrderInt::clear_has_goodtilldatetime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SubmitNewSingleOrderInt::clear_goodtilldatetime() {
  goodtilldatetime_ = GOOGLE_LONGLONG(0);
  clear_has_goodtilldatetime();
}
inline ::google::protobuf::int64 SubmitNewSingleOrderInt::goodtilldatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.GoodTillDateTime)
  return goodtilldatetime_;
}
inline void SubmitNewSingleOrderInt::set_goodtilldatetime(::google::protobuf::int64 value) {
  set_has_goodtilldatetime();
  goodtilldatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.GoodTillDateTime)
}

// optional uint32 IsAutomatedOrder = 13;
inline bool SubmitNewSingleOrderInt::has_isautomatedorder() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_isautomatedorder() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SubmitNewSingleOrderInt::clear_has_isautomatedorder() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SubmitNewSingleOrderInt::clear_isautomatedorder() {
  isautomatedorder_ = 0u;
  clear_has_isautomatedorder();
}
inline ::google::protobuf::uint32 SubmitNewSingleOrderInt::isautomatedorder() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.IsAutomatedOrder)
  return isautomatedorder_;
}
inline void SubmitNewSingleOrderInt::set_isautomatedorder(::google::protobuf::uint32 value) {
  set_has_isautomatedorder();
  isautomatedorder_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.IsAutomatedOrder)
}

// optional uint32 IsParentOrder = 14;
inline bool SubmitNewSingleOrderInt::has_isparentorder() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_isparentorder() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SubmitNewSingleOrderInt::clear_has_isparentorder() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SubmitNewSingleOrderInt::clear_isparentorder() {
  isparentorder_ = 0u;
  clear_has_isparentorder();
}
inline ::google::protobuf::uint32 SubmitNewSingleOrderInt::isparentorder() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.IsParentOrder)
  return isparentorder_;
}
inline void SubmitNewSingleOrderInt::set_isparentorder(::google::protobuf::uint32 value) {
  set_has_isparentorder();
  isparentorder_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.IsParentOrder)
}

// optional string FreeFormText = 15;
inline bool SubmitNewSingleOrderInt::has_freeformtext() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_freeformtext() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SubmitNewSingleOrderInt::clear_has_freeformtext() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SubmitNewSingleOrderInt::clear_freeformtext() {
  if (freeformtext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_->clear();
  }
  clear_has_freeformtext();
}
inline const ::std::string& SubmitNewSingleOrderInt::freeformtext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.FreeFormText)
  return *freeformtext_;
}
inline void SubmitNewSingleOrderInt::set_freeformtext(const ::std::string& value) {
  set_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_ = new ::std::string;
  }
  freeformtext_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.FreeFormText)
}
inline void SubmitNewSingleOrderInt::set_freeformtext(const char* value) {
  set_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_ = new ::std::string;
  }
  freeformtext_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewSingleOrderInt.FreeFormText)
}
inline void SubmitNewSingleOrderInt::set_freeformtext(const char* value, size_t size) {
  set_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_ = new ::std::string;
  }
  freeformtext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewSingleOrderInt.FreeFormText)
}
inline ::std::string* SubmitNewSingleOrderInt::mutable_freeformtext() {
  set_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewSingleOrderInt.FreeFormText)
  return freeformtext_;
}
inline ::std::string* SubmitNewSingleOrderInt::release_freeformtext() {
  clear_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = freeformtext_;
    freeformtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewSingleOrderInt::set_allocated_freeformtext(::std::string* freeformtext) {
  if (freeformtext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete freeformtext_;
  }
  if (freeformtext) {
    set_has_freeformtext();
    freeformtext_ = freeformtext;
  } else {
    clear_has_freeformtext();
    freeformtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewSingleOrderInt.FreeFormText)
}

// optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 16;
inline bool SubmitNewSingleOrderInt::has_openorclose() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SubmitNewSingleOrderInt::set_has_openorclose() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SubmitNewSingleOrderInt::clear_has_openorclose() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SubmitNewSingleOrderInt::clear_openorclose() {
  openorclose_ = 0;
  clear_has_openorclose();
}
inline ::DTC_PB::OpenCloseTradeEnum SubmitNewSingleOrderInt::openorclose() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewSingleOrderInt.OpenOrClose)
  return static_cast< ::DTC_PB::OpenCloseTradeEnum >(openorclose_);
}
inline void SubmitNewSingleOrderInt::set_openorclose(::DTC_PB::OpenCloseTradeEnum value) {
  assert(::DTC_PB::OpenCloseTradeEnum_IsValid(value));
  set_has_openorclose();
  openorclose_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewSingleOrderInt.OpenOrClose)
}

// -------------------------------------------------------------------

// CancelReplaceOrder

// optional string ServerOrderID = 1;
inline bool CancelReplaceOrder::has_serverorderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CancelReplaceOrder::set_has_serverorderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CancelReplaceOrder::clear_has_serverorderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CancelReplaceOrder::clear_serverorderid() {
  if (serverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_->clear();
  }
  clear_has_serverorderid();
}
inline const ::std::string& CancelReplaceOrder::serverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrder.ServerOrderID)
  return *serverorderid_;
}
inline void CancelReplaceOrder::set_serverorderid(const ::std::string& value) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrder.ServerOrderID)
}
inline void CancelReplaceOrder::set_serverorderid(const char* value) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.CancelReplaceOrder.ServerOrderID)
}
inline void CancelReplaceOrder::set_serverorderid(const char* value, size_t size) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.CancelReplaceOrder.ServerOrderID)
}
inline ::std::string* CancelReplaceOrder::mutable_serverorderid() {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.CancelReplaceOrder.ServerOrderID)
  return serverorderid_;
}
inline ::std::string* CancelReplaceOrder::release_serverorderid() {
  clear_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serverorderid_;
    serverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CancelReplaceOrder::set_allocated_serverorderid(::std::string* serverorderid) {
  if (serverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serverorderid_;
  }
  if (serverorderid) {
    set_has_serverorderid();
    serverorderid_ = serverorderid;
  } else {
    clear_has_serverorderid();
    serverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.CancelReplaceOrder.ServerOrderID)
}

// optional string ClientOrderID = 2;
inline bool CancelReplaceOrder::has_clientorderid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CancelReplaceOrder::set_has_clientorderid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CancelReplaceOrder::clear_has_clientorderid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CancelReplaceOrder::clear_clientorderid() {
  if (clientorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_->clear();
  }
  clear_has_clientorderid();
}
inline const ::std::string& CancelReplaceOrder::clientorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrder.ClientOrderID)
  return *clientorderid_;
}
inline void CancelReplaceOrder::set_clientorderid(const ::std::string& value) {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  clientorderid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrder.ClientOrderID)
}
inline void CancelReplaceOrder::set_clientorderid(const char* value) {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  clientorderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.CancelReplaceOrder.ClientOrderID)
}
inline void CancelReplaceOrder::set_clientorderid(const char* value, size_t size) {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  clientorderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.CancelReplaceOrder.ClientOrderID)
}
inline ::std::string* CancelReplaceOrder::mutable_clientorderid() {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.CancelReplaceOrder.ClientOrderID)
  return clientorderid_;
}
inline ::std::string* CancelReplaceOrder::release_clientorderid() {
  clear_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientorderid_;
    clientorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CancelReplaceOrder::set_allocated_clientorderid(::std::string* clientorderid) {
  if (clientorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientorderid_;
  }
  if (clientorderid) {
    set_has_clientorderid();
    clientorderid_ = clientorderid;
  } else {
    clear_has_clientorderid();
    clientorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.CancelReplaceOrder.ClientOrderID)
}

// optional double Price1 = 3;
inline bool CancelReplaceOrder::has_price1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CancelReplaceOrder::set_has_price1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CancelReplaceOrder::clear_has_price1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CancelReplaceOrder::clear_price1() {
  price1_ = 0;
  clear_has_price1();
}
inline double CancelReplaceOrder::price1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrder.Price1)
  return price1_;
}
inline void CancelReplaceOrder::set_price1(double value) {
  set_has_price1();
  price1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrder.Price1)
}

// optional double Price2 = 4;
inline bool CancelReplaceOrder::has_price2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CancelReplaceOrder::set_has_price2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CancelReplaceOrder::clear_has_price2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CancelReplaceOrder::clear_price2() {
  price2_ = 0;
  clear_has_price2();
}
inline double CancelReplaceOrder::price2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrder.Price2)
  return price2_;
}
inline void CancelReplaceOrder::set_price2(double value) {
  set_has_price2();
  price2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrder.Price2)
}

// optional double Quantity = 5;
inline bool CancelReplaceOrder::has_quantity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CancelReplaceOrder::set_has_quantity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CancelReplaceOrder::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CancelReplaceOrder::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline double CancelReplaceOrder::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrder.Quantity)
  return quantity_;
}
inline void CancelReplaceOrder::set_quantity(double value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrder.Quantity)
}

// optional uint32 Price1IsSet = 6;
inline bool CancelReplaceOrder::has_price1isset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CancelReplaceOrder::set_has_price1isset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CancelReplaceOrder::clear_has_price1isset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CancelReplaceOrder::clear_price1isset() {
  price1isset_ = 0u;
  clear_has_price1isset();
}
inline ::google::protobuf::uint32 CancelReplaceOrder::price1isset() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrder.Price1IsSet)
  return price1isset_;
}
inline void CancelReplaceOrder::set_price1isset(::google::protobuf::uint32 value) {
  set_has_price1isset();
  price1isset_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrder.Price1IsSet)
}

// optional uint32 Price2IsSet = 7;
inline bool CancelReplaceOrder::has_price2isset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CancelReplaceOrder::set_has_price2isset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CancelReplaceOrder::clear_has_price2isset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CancelReplaceOrder::clear_price2isset() {
  price2isset_ = 0u;
  clear_has_price2isset();
}
inline ::google::protobuf::uint32 CancelReplaceOrder::price2isset() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrder.Price2IsSet)
  return price2isset_;
}
inline void CancelReplaceOrder::set_price2isset(::google::protobuf::uint32 value) {
  set_has_price2isset();
  price2isset_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrder.Price2IsSet)
}

// -------------------------------------------------------------------

// CancelReplaceOrderInt

// optional string ServerOrderID = 1;
inline bool CancelReplaceOrderInt::has_serverorderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CancelReplaceOrderInt::set_has_serverorderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CancelReplaceOrderInt::clear_has_serverorderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CancelReplaceOrderInt::clear_serverorderid() {
  if (serverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_->clear();
  }
  clear_has_serverorderid();
}
inline const ::std::string& CancelReplaceOrderInt::serverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrderInt.ServerOrderID)
  return *serverorderid_;
}
inline void CancelReplaceOrderInt::set_serverorderid(const ::std::string& value) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrderInt.ServerOrderID)
}
inline void CancelReplaceOrderInt::set_serverorderid(const char* value) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.CancelReplaceOrderInt.ServerOrderID)
}
inline void CancelReplaceOrderInt::set_serverorderid(const char* value, size_t size) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.CancelReplaceOrderInt.ServerOrderID)
}
inline ::std::string* CancelReplaceOrderInt::mutable_serverorderid() {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.CancelReplaceOrderInt.ServerOrderID)
  return serverorderid_;
}
inline ::std::string* CancelReplaceOrderInt::release_serverorderid() {
  clear_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serverorderid_;
    serverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CancelReplaceOrderInt::set_allocated_serverorderid(::std::string* serverorderid) {
  if (serverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serverorderid_;
  }
  if (serverorderid) {
    set_has_serverorderid();
    serverorderid_ = serverorderid;
  } else {
    clear_has_serverorderid();
    serverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.CancelReplaceOrderInt.ServerOrderID)
}

// optional string ClientOrderID = 2;
inline bool CancelReplaceOrderInt::has_clientorderid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CancelReplaceOrderInt::set_has_clientorderid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CancelReplaceOrderInt::clear_has_clientorderid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CancelReplaceOrderInt::clear_clientorderid() {
  if (clientorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_->clear();
  }
  clear_has_clientorderid();
}
inline const ::std::string& CancelReplaceOrderInt::clientorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrderInt.ClientOrderID)
  return *clientorderid_;
}
inline void CancelReplaceOrderInt::set_clientorderid(const ::std::string& value) {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  clientorderid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrderInt.ClientOrderID)
}
inline void CancelReplaceOrderInt::set_clientorderid(const char* value) {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  clientorderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.CancelReplaceOrderInt.ClientOrderID)
}
inline void CancelReplaceOrderInt::set_clientorderid(const char* value, size_t size) {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  clientorderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.CancelReplaceOrderInt.ClientOrderID)
}
inline ::std::string* CancelReplaceOrderInt::mutable_clientorderid() {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.CancelReplaceOrderInt.ClientOrderID)
  return clientorderid_;
}
inline ::std::string* CancelReplaceOrderInt::release_clientorderid() {
  clear_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientorderid_;
    clientorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CancelReplaceOrderInt::set_allocated_clientorderid(::std::string* clientorderid) {
  if (clientorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientorderid_;
  }
  if (clientorderid) {
    set_has_clientorderid();
    clientorderid_ = clientorderid;
  } else {
    clear_has_clientorderid();
    clientorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.CancelReplaceOrderInt.ClientOrderID)
}

// optional int64 Price1 = 3;
inline bool CancelReplaceOrderInt::has_price1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CancelReplaceOrderInt::set_has_price1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CancelReplaceOrderInt::clear_has_price1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CancelReplaceOrderInt::clear_price1() {
  price1_ = GOOGLE_LONGLONG(0);
  clear_has_price1();
}
inline ::google::protobuf::int64 CancelReplaceOrderInt::price1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrderInt.Price1)
  return price1_;
}
inline void CancelReplaceOrderInt::set_price1(::google::protobuf::int64 value) {
  set_has_price1();
  price1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrderInt.Price1)
}

// optional int64 Price2 = 4;
inline bool CancelReplaceOrderInt::has_price2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CancelReplaceOrderInt::set_has_price2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CancelReplaceOrderInt::clear_has_price2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CancelReplaceOrderInt::clear_price2() {
  price2_ = GOOGLE_LONGLONG(0);
  clear_has_price2();
}
inline ::google::protobuf::int64 CancelReplaceOrderInt::price2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrderInt.Price2)
  return price2_;
}
inline void CancelReplaceOrderInt::set_price2(::google::protobuf::int64 value) {
  set_has_price2();
  price2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrderInt.Price2)
}

// optional float Divisor = 5;
inline bool CancelReplaceOrderInt::has_divisor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CancelReplaceOrderInt::set_has_divisor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CancelReplaceOrderInt::clear_has_divisor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CancelReplaceOrderInt::clear_divisor() {
  divisor_ = 0;
  clear_has_divisor();
}
inline float CancelReplaceOrderInt::divisor() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrderInt.Divisor)
  return divisor_;
}
inline void CancelReplaceOrderInt::set_divisor(float value) {
  set_has_divisor();
  divisor_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrderInt.Divisor)
}

// optional int64 Quantity = 6;
inline bool CancelReplaceOrderInt::has_quantity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CancelReplaceOrderInt::set_has_quantity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CancelReplaceOrderInt::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CancelReplaceOrderInt::clear_quantity() {
  quantity_ = GOOGLE_LONGLONG(0);
  clear_has_quantity();
}
inline ::google::protobuf::int64 CancelReplaceOrderInt::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrderInt.Quantity)
  return quantity_;
}
inline void CancelReplaceOrderInt::set_quantity(::google::protobuf::int64 value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrderInt.Quantity)
}

// optional uint32 Price1IsSet = 7;
inline bool CancelReplaceOrderInt::has_price1isset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CancelReplaceOrderInt::set_has_price1isset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CancelReplaceOrderInt::clear_has_price1isset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CancelReplaceOrderInt::clear_price1isset() {
  price1isset_ = 0u;
  clear_has_price1isset();
}
inline ::google::protobuf::uint32 CancelReplaceOrderInt::price1isset() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrderInt.Price1IsSet)
  return price1isset_;
}
inline void CancelReplaceOrderInt::set_price1isset(::google::protobuf::uint32 value) {
  set_has_price1isset();
  price1isset_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrderInt.Price1IsSet)
}

// optional uint32 Price2IsSet = 8;
inline bool CancelReplaceOrderInt::has_price2isset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CancelReplaceOrderInt::set_has_price2isset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CancelReplaceOrderInt::clear_has_price2isset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CancelReplaceOrderInt::clear_price2isset() {
  price2isset_ = 0u;
  clear_has_price2isset();
}
inline ::google::protobuf::uint32 CancelReplaceOrderInt::price2isset() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelReplaceOrderInt.Price2IsSet)
  return price2isset_;
}
inline void CancelReplaceOrderInt::set_price2isset(::google::protobuf::uint32 value) {
  set_has_price2isset();
  price2isset_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CancelReplaceOrderInt.Price2IsSet)
}

// -------------------------------------------------------------------

// CancelOrder

// optional string ServerOrderID = 1;
inline bool CancelOrder::has_serverorderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CancelOrder::set_has_serverorderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CancelOrder::clear_has_serverorderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CancelOrder::clear_serverorderid() {
  if (serverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_->clear();
  }
  clear_has_serverorderid();
}
inline const ::std::string& CancelOrder::serverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelOrder.ServerOrderID)
  return *serverorderid_;
}
inline void CancelOrder::set_serverorderid(const ::std::string& value) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.CancelOrder.ServerOrderID)
}
inline void CancelOrder::set_serverorderid(const char* value) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.CancelOrder.ServerOrderID)
}
inline void CancelOrder::set_serverorderid(const char* value, size_t size) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.CancelOrder.ServerOrderID)
}
inline ::std::string* CancelOrder::mutable_serverorderid() {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.CancelOrder.ServerOrderID)
  return serverorderid_;
}
inline ::std::string* CancelOrder::release_serverorderid() {
  clear_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serverorderid_;
    serverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CancelOrder::set_allocated_serverorderid(::std::string* serverorderid) {
  if (serverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serverorderid_;
  }
  if (serverorderid) {
    set_has_serverorderid();
    serverorderid_ = serverorderid;
  } else {
    clear_has_serverorderid();
    serverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.CancelOrder.ServerOrderID)
}

// optional string ClientOrderID = 2;
inline bool CancelOrder::has_clientorderid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CancelOrder::set_has_clientorderid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CancelOrder::clear_has_clientorderid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CancelOrder::clear_clientorderid() {
  if (clientorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_->clear();
  }
  clear_has_clientorderid();
}
inline const ::std::string& CancelOrder::clientorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CancelOrder.ClientOrderID)
  return *clientorderid_;
}
inline void CancelOrder::set_clientorderid(const ::std::string& value) {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  clientorderid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.CancelOrder.ClientOrderID)
}
inline void CancelOrder::set_clientorderid(const char* value) {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  clientorderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.CancelOrder.ClientOrderID)
}
inline void CancelOrder::set_clientorderid(const char* value, size_t size) {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  clientorderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.CancelOrder.ClientOrderID)
}
inline ::std::string* CancelOrder::mutable_clientorderid() {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.CancelOrder.ClientOrderID)
  return clientorderid_;
}
inline ::std::string* CancelOrder::release_clientorderid() {
  clear_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientorderid_;
    clientorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CancelOrder::set_allocated_clientorderid(::std::string* clientorderid) {
  if (clientorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientorderid_;
  }
  if (clientorderid) {
    set_has_clientorderid();
    clientorderid_ = clientorderid;
  } else {
    clear_has_clientorderid();
    clientorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.CancelOrder.ClientOrderID)
}

// -------------------------------------------------------------------

// SubmitNewOCOOrder

// optional string Symbol = 1;
inline bool SubmitNewOCOOrder::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubmitNewOCOOrder::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubmitNewOCOOrder::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubmitNewOCOOrder::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& SubmitNewOCOOrder::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.Symbol)
  return *symbol_;
}
inline void SubmitNewOCOOrder::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.Symbol)
}
inline void SubmitNewOCOOrder::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrder.Symbol)
}
inline void SubmitNewOCOOrder::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrder.Symbol)
}
inline ::std::string* SubmitNewOCOOrder::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrder.Symbol)
  return symbol_;
}
inline ::std::string* SubmitNewOCOOrder::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewOCOOrder::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrder.Symbol)
}

// optional string Exchange = 2;
inline bool SubmitNewOCOOrder::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubmitNewOCOOrder::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubmitNewOCOOrder::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubmitNewOCOOrder::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& SubmitNewOCOOrder::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.Exchange)
  return *exchange_;
}
inline void SubmitNewOCOOrder::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.Exchange)
}
inline void SubmitNewOCOOrder::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrder.Exchange)
}
inline void SubmitNewOCOOrder::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrder.Exchange)
}
inline ::std::string* SubmitNewOCOOrder::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrder.Exchange)
  return exchange_;
}
inline ::std::string* SubmitNewOCOOrder::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewOCOOrder::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrder.Exchange)
}

// optional string ClientOrderID_1 = 3;
inline bool SubmitNewOCOOrder::has_clientorderid_1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubmitNewOCOOrder::set_has_clientorderid_1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubmitNewOCOOrder::clear_has_clientorderid_1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubmitNewOCOOrder::clear_clientorderid_1() {
  if (clientorderid_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_1_->clear();
  }
  clear_has_clientorderid_1();
}
inline const ::std::string& SubmitNewOCOOrder::clientorderid_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.ClientOrderID_1)
  return *clientorderid_1_;
}
inline void SubmitNewOCOOrder::set_clientorderid_1(const ::std::string& value) {
  set_has_clientorderid_1();
  if (clientorderid_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_1_ = new ::std::string;
  }
  clientorderid_1_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.ClientOrderID_1)
}
inline void SubmitNewOCOOrder::set_clientorderid_1(const char* value) {
  set_has_clientorderid_1();
  if (clientorderid_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_1_ = new ::std::string;
  }
  clientorderid_1_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrder.ClientOrderID_1)
}
inline void SubmitNewOCOOrder::set_clientorderid_1(const char* value, size_t size) {
  set_has_clientorderid_1();
  if (clientorderid_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_1_ = new ::std::string;
  }
  clientorderid_1_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrder.ClientOrderID_1)
}
inline ::std::string* SubmitNewOCOOrder::mutable_clientorderid_1() {
  set_has_clientorderid_1();
  if (clientorderid_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_1_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrder.ClientOrderID_1)
  return clientorderid_1_;
}
inline ::std::string* SubmitNewOCOOrder::release_clientorderid_1() {
  clear_has_clientorderid_1();
  if (clientorderid_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientorderid_1_;
    clientorderid_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewOCOOrder::set_allocated_clientorderid_1(::std::string* clientorderid_1) {
  if (clientorderid_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientorderid_1_;
  }
  if (clientorderid_1) {
    set_has_clientorderid_1();
    clientorderid_1_ = clientorderid_1;
  } else {
    clear_has_clientorderid_1();
    clientorderid_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrder.ClientOrderID_1)
}

// optional .DTC_PB.OrderTypeEnum OrderType_1 = 4;
inline bool SubmitNewOCOOrder::has_ordertype_1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubmitNewOCOOrder::set_has_ordertype_1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubmitNewOCOOrder::clear_has_ordertype_1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubmitNewOCOOrder::clear_ordertype_1() {
  ordertype_1_ = 0;
  clear_has_ordertype_1();
}
inline ::DTC_PB::OrderTypeEnum SubmitNewOCOOrder::ordertype_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.OrderType_1)
  return static_cast< ::DTC_PB::OrderTypeEnum >(ordertype_1_);
}
inline void SubmitNewOCOOrder::set_ordertype_1(::DTC_PB::OrderTypeEnum value) {
  assert(::DTC_PB::OrderTypeEnum_IsValid(value));
  set_has_ordertype_1();
  ordertype_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.OrderType_1)
}

// optional .DTC_PB.BuySellEnum BuySell_1 = 5;
inline bool SubmitNewOCOOrder::has_buysell_1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubmitNewOCOOrder::set_has_buysell_1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubmitNewOCOOrder::clear_has_buysell_1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubmitNewOCOOrder::clear_buysell_1() {
  buysell_1_ = 0;
  clear_has_buysell_1();
}
inline ::DTC_PB::BuySellEnum SubmitNewOCOOrder::buysell_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.BuySell_1)
  return static_cast< ::DTC_PB::BuySellEnum >(buysell_1_);
}
inline void SubmitNewOCOOrder::set_buysell_1(::DTC_PB::BuySellEnum value) {
  assert(::DTC_PB::BuySellEnum_IsValid(value));
  set_has_buysell_1();
  buysell_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.BuySell_1)
}

// optional double Price1_1 = 6;
inline bool SubmitNewOCOOrder::has_price1_1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SubmitNewOCOOrder::set_has_price1_1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SubmitNewOCOOrder::clear_has_price1_1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SubmitNewOCOOrder::clear_price1_1() {
  price1_1_ = 0;
  clear_has_price1_1();
}
inline double SubmitNewOCOOrder::price1_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.Price1_1)
  return price1_1_;
}
inline void SubmitNewOCOOrder::set_price1_1(double value) {
  set_has_price1_1();
  price1_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.Price1_1)
}

// optional double Price2_1 = 7;
inline bool SubmitNewOCOOrder::has_price2_1() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SubmitNewOCOOrder::set_has_price2_1() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SubmitNewOCOOrder::clear_has_price2_1() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SubmitNewOCOOrder::clear_price2_1() {
  price2_1_ = 0;
  clear_has_price2_1();
}
inline double SubmitNewOCOOrder::price2_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.Price2_1)
  return price2_1_;
}
inline void SubmitNewOCOOrder::set_price2_1(double value) {
  set_has_price2_1();
  price2_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.Price2_1)
}

// optional double Quantity_1 = 8;
inline bool SubmitNewOCOOrder::has_quantity_1() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SubmitNewOCOOrder::set_has_quantity_1() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SubmitNewOCOOrder::clear_has_quantity_1() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SubmitNewOCOOrder::clear_quantity_1() {
  quantity_1_ = 0;
  clear_has_quantity_1();
}
inline double SubmitNewOCOOrder::quantity_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.Quantity_1)
  return quantity_1_;
}
inline void SubmitNewOCOOrder::set_quantity_1(double value) {
  set_has_quantity_1();
  quantity_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.Quantity_1)
}

// optional string ClientOrderID_2 = 9;
inline bool SubmitNewOCOOrder::has_clientorderid_2() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SubmitNewOCOOrder::set_has_clientorderid_2() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SubmitNewOCOOrder::clear_has_clientorderid_2() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SubmitNewOCOOrder::clear_clientorderid_2() {
  if (clientorderid_2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_2_->clear();
  }
  clear_has_clientorderid_2();
}
inline const ::std::string& SubmitNewOCOOrder::clientorderid_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.ClientOrderID_2)
  return *clientorderid_2_;
}
inline void SubmitNewOCOOrder::set_clientorderid_2(const ::std::string& value) {
  set_has_clientorderid_2();
  if (clientorderid_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_2_ = new ::std::string;
  }
  clientorderid_2_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.ClientOrderID_2)
}
inline void SubmitNewOCOOrder::set_clientorderid_2(const char* value) {
  set_has_clientorderid_2();
  if (clientorderid_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_2_ = new ::std::string;
  }
  clientorderid_2_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrder.ClientOrderID_2)
}
inline void SubmitNewOCOOrder::set_clientorderid_2(const char* value, size_t size) {
  set_has_clientorderid_2();
  if (clientorderid_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_2_ = new ::std::string;
  }
  clientorderid_2_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrder.ClientOrderID_2)
}
inline ::std::string* SubmitNewOCOOrder::mutable_clientorderid_2() {
  set_has_clientorderid_2();
  if (clientorderid_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_2_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrder.ClientOrderID_2)
  return clientorderid_2_;
}
inline ::std::string* SubmitNewOCOOrder::release_clientorderid_2() {
  clear_has_clientorderid_2();
  if (clientorderid_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientorderid_2_;
    clientorderid_2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewOCOOrder::set_allocated_clientorderid_2(::std::string* clientorderid_2) {
  if (clientorderid_2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientorderid_2_;
  }
  if (clientorderid_2) {
    set_has_clientorderid_2();
    clientorderid_2_ = clientorderid_2;
  } else {
    clear_has_clientorderid_2();
    clientorderid_2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrder.ClientOrderID_2)
}

// optional .DTC_PB.OrderTypeEnum OrderType_2 = 10;
inline bool SubmitNewOCOOrder::has_ordertype_2() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SubmitNewOCOOrder::set_has_ordertype_2() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SubmitNewOCOOrder::clear_has_ordertype_2() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SubmitNewOCOOrder::clear_ordertype_2() {
  ordertype_2_ = 0;
  clear_has_ordertype_2();
}
inline ::DTC_PB::OrderTypeEnum SubmitNewOCOOrder::ordertype_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.OrderType_2)
  return static_cast< ::DTC_PB::OrderTypeEnum >(ordertype_2_);
}
inline void SubmitNewOCOOrder::set_ordertype_2(::DTC_PB::OrderTypeEnum value) {
  assert(::DTC_PB::OrderTypeEnum_IsValid(value));
  set_has_ordertype_2();
  ordertype_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.OrderType_2)
}

// optional .DTC_PB.BuySellEnum BuySell_2 = 11;
inline bool SubmitNewOCOOrder::has_buysell_2() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SubmitNewOCOOrder::set_has_buysell_2() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SubmitNewOCOOrder::clear_has_buysell_2() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SubmitNewOCOOrder::clear_buysell_2() {
  buysell_2_ = 0;
  clear_has_buysell_2();
}
inline ::DTC_PB::BuySellEnum SubmitNewOCOOrder::buysell_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.BuySell_2)
  return static_cast< ::DTC_PB::BuySellEnum >(buysell_2_);
}
inline void SubmitNewOCOOrder::set_buysell_2(::DTC_PB::BuySellEnum value) {
  assert(::DTC_PB::BuySellEnum_IsValid(value));
  set_has_buysell_2();
  buysell_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.BuySell_2)
}

// optional double Price1_2 = 12;
inline bool SubmitNewOCOOrder::has_price1_2() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SubmitNewOCOOrder::set_has_price1_2() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SubmitNewOCOOrder::clear_has_price1_2() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SubmitNewOCOOrder::clear_price1_2() {
  price1_2_ = 0;
  clear_has_price1_2();
}
inline double SubmitNewOCOOrder::price1_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.Price1_2)
  return price1_2_;
}
inline void SubmitNewOCOOrder::set_price1_2(double value) {
  set_has_price1_2();
  price1_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.Price1_2)
}

// optional double Price2_2 = 13;
inline bool SubmitNewOCOOrder::has_price2_2() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_price2_2() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SubmitNewOCOOrder::clear_has_price2_2() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SubmitNewOCOOrder::clear_price2_2() {
  price2_2_ = 0;
  clear_has_price2_2();
}
inline double SubmitNewOCOOrder::price2_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.Price2_2)
  return price2_2_;
}
inline void SubmitNewOCOOrder::set_price2_2(double value) {
  set_has_price2_2();
  price2_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.Price2_2)
}

// optional double Quantity_2 = 14;
inline bool SubmitNewOCOOrder::has_quantity_2() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_quantity_2() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SubmitNewOCOOrder::clear_has_quantity_2() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SubmitNewOCOOrder::clear_quantity_2() {
  quantity_2_ = 0;
  clear_has_quantity_2();
}
inline double SubmitNewOCOOrder::quantity_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.Quantity_2)
  return quantity_2_;
}
inline void SubmitNewOCOOrder::set_quantity_2(double value) {
  set_has_quantity_2();
  quantity_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.Quantity_2)
}

// optional .DTC_PB.TimeInForceEnum TimeInForce = 15;
inline bool SubmitNewOCOOrder::has_timeinforce() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_timeinforce() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SubmitNewOCOOrder::clear_has_timeinforce() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SubmitNewOCOOrder::clear_timeinforce() {
  timeinforce_ = 0;
  clear_has_timeinforce();
}
inline ::DTC_PB::TimeInForceEnum SubmitNewOCOOrder::timeinforce() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.TimeInForce)
  return static_cast< ::DTC_PB::TimeInForceEnum >(timeinforce_);
}
inline void SubmitNewOCOOrder::set_timeinforce(::DTC_PB::TimeInForceEnum value) {
  assert(::DTC_PB::TimeInForceEnum_IsValid(value));
  set_has_timeinforce();
  timeinforce_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.TimeInForce)
}

// optional sfixed64 GoodTillDateTime = 16;
inline bool SubmitNewOCOOrder::has_goodtilldatetime() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_goodtilldatetime() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SubmitNewOCOOrder::clear_has_goodtilldatetime() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SubmitNewOCOOrder::clear_goodtilldatetime() {
  goodtilldatetime_ = GOOGLE_LONGLONG(0);
  clear_has_goodtilldatetime();
}
inline ::google::protobuf::int64 SubmitNewOCOOrder::goodtilldatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.GoodTillDateTime)
  return goodtilldatetime_;
}
inline void SubmitNewOCOOrder::set_goodtilldatetime(::google::protobuf::int64 value) {
  set_has_goodtilldatetime();
  goodtilldatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.GoodTillDateTime)
}

// optional string TradeAccount = 17;
inline bool SubmitNewOCOOrder::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SubmitNewOCOOrder::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SubmitNewOCOOrder::clear_tradeaccount() {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_->clear();
  }
  clear_has_tradeaccount();
}
inline const ::std::string& SubmitNewOCOOrder::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.TradeAccount)
  return *tradeaccount_;
}
inline void SubmitNewOCOOrder::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.TradeAccount)
}
inline void SubmitNewOCOOrder::set_tradeaccount(const char* value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrder.TradeAccount)
}
inline void SubmitNewOCOOrder::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrder.TradeAccount)
}
inline ::std::string* SubmitNewOCOOrder::mutable_tradeaccount() {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrder.TradeAccount)
  return tradeaccount_;
}
inline ::std::string* SubmitNewOCOOrder::release_tradeaccount() {
  clear_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tradeaccount_;
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewOCOOrder::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tradeaccount_;
  }
  if (tradeaccount) {
    set_has_tradeaccount();
    tradeaccount_ = tradeaccount;
  } else {
    clear_has_tradeaccount();
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrder.TradeAccount)
}

// optional uint32 IsAutomatedOrder = 18;
inline bool SubmitNewOCOOrder::has_isautomatedorder() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_isautomatedorder() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SubmitNewOCOOrder::clear_has_isautomatedorder() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SubmitNewOCOOrder::clear_isautomatedorder() {
  isautomatedorder_ = 0u;
  clear_has_isautomatedorder();
}
inline ::google::protobuf::uint32 SubmitNewOCOOrder::isautomatedorder() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.IsAutomatedOrder)
  return isautomatedorder_;
}
inline void SubmitNewOCOOrder::set_isautomatedorder(::google::protobuf::uint32 value) {
  set_has_isautomatedorder();
  isautomatedorder_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.IsAutomatedOrder)
}

// optional string ParentTriggerClientOrderID = 19;
inline bool SubmitNewOCOOrder::has_parenttriggerclientorderid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_parenttriggerclientorderid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SubmitNewOCOOrder::clear_has_parenttriggerclientorderid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SubmitNewOCOOrder::clear_parenttriggerclientorderid() {
  if (parenttriggerclientorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parenttriggerclientorderid_->clear();
  }
  clear_has_parenttriggerclientorderid();
}
inline const ::std::string& SubmitNewOCOOrder::parenttriggerclientorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.ParentTriggerClientOrderID)
  return *parenttriggerclientorderid_;
}
inline void SubmitNewOCOOrder::set_parenttriggerclientorderid(const ::std::string& value) {
  set_has_parenttriggerclientorderid();
  if (parenttriggerclientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parenttriggerclientorderid_ = new ::std::string;
  }
  parenttriggerclientorderid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.ParentTriggerClientOrderID)
}
inline void SubmitNewOCOOrder::set_parenttriggerclientorderid(const char* value) {
  set_has_parenttriggerclientorderid();
  if (parenttriggerclientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parenttriggerclientorderid_ = new ::std::string;
  }
  parenttriggerclientorderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrder.ParentTriggerClientOrderID)
}
inline void SubmitNewOCOOrder::set_parenttriggerclientorderid(const char* value, size_t size) {
  set_has_parenttriggerclientorderid();
  if (parenttriggerclientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parenttriggerclientorderid_ = new ::std::string;
  }
  parenttriggerclientorderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrder.ParentTriggerClientOrderID)
}
inline ::std::string* SubmitNewOCOOrder::mutable_parenttriggerclientorderid() {
  set_has_parenttriggerclientorderid();
  if (parenttriggerclientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parenttriggerclientorderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrder.ParentTriggerClientOrderID)
  return parenttriggerclientorderid_;
}
inline ::std::string* SubmitNewOCOOrder::release_parenttriggerclientorderid() {
  clear_has_parenttriggerclientorderid();
  if (parenttriggerclientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = parenttriggerclientorderid_;
    parenttriggerclientorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewOCOOrder::set_allocated_parenttriggerclientorderid(::std::string* parenttriggerclientorderid) {
  if (parenttriggerclientorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete parenttriggerclientorderid_;
  }
  if (parenttriggerclientorderid) {
    set_has_parenttriggerclientorderid();
    parenttriggerclientorderid_ = parenttriggerclientorderid;
  } else {
    clear_has_parenttriggerclientorderid();
    parenttriggerclientorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrder.ParentTriggerClientOrderID)
}

// optional string FreeFormText = 20;
inline bool SubmitNewOCOOrder::has_freeformtext() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_freeformtext() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SubmitNewOCOOrder::clear_has_freeformtext() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SubmitNewOCOOrder::clear_freeformtext() {
  if (freeformtext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_->clear();
  }
  clear_has_freeformtext();
}
inline const ::std::string& SubmitNewOCOOrder::freeformtext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.FreeFormText)
  return *freeformtext_;
}
inline void SubmitNewOCOOrder::set_freeformtext(const ::std::string& value) {
  set_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_ = new ::std::string;
  }
  freeformtext_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.FreeFormText)
}
inline void SubmitNewOCOOrder::set_freeformtext(const char* value) {
  set_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_ = new ::std::string;
  }
  freeformtext_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrder.FreeFormText)
}
inline void SubmitNewOCOOrder::set_freeformtext(const char* value, size_t size) {
  set_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_ = new ::std::string;
  }
  freeformtext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrder.FreeFormText)
}
inline ::std::string* SubmitNewOCOOrder::mutable_freeformtext() {
  set_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrder.FreeFormText)
  return freeformtext_;
}
inline ::std::string* SubmitNewOCOOrder::release_freeformtext() {
  clear_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = freeformtext_;
    freeformtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewOCOOrder::set_allocated_freeformtext(::std::string* freeformtext) {
  if (freeformtext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete freeformtext_;
  }
  if (freeformtext) {
    set_has_freeformtext();
    freeformtext_ = freeformtext;
  } else {
    clear_has_freeformtext();
    freeformtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrder.FreeFormText)
}

// optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 21;
inline bool SubmitNewOCOOrder::has_openorclose() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SubmitNewOCOOrder::set_has_openorclose() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SubmitNewOCOOrder::clear_has_openorclose() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SubmitNewOCOOrder::clear_openorclose() {
  openorclose_ = 0;
  clear_has_openorclose();
}
inline ::DTC_PB::OpenCloseTradeEnum SubmitNewOCOOrder::openorclose() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrder.OpenOrClose)
  return static_cast< ::DTC_PB::OpenCloseTradeEnum >(openorclose_);
}
inline void SubmitNewOCOOrder::set_openorclose(::DTC_PB::OpenCloseTradeEnum value) {
  assert(::DTC_PB::OpenCloseTradeEnum_IsValid(value));
  set_has_openorclose();
  openorclose_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrder.OpenOrClose)
}

// -------------------------------------------------------------------

// SubmitNewOCOOrderInt

// optional string Symbol = 1;
inline bool SubmitNewOCOOrderInt::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubmitNewOCOOrderInt::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubmitNewOCOOrderInt::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& SubmitNewOCOOrderInt::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.Symbol)
  return *symbol_;
}
inline void SubmitNewOCOOrderInt::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.Symbol)
}
inline void SubmitNewOCOOrderInt::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrderInt.Symbol)
}
inline void SubmitNewOCOOrderInt::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrderInt.Symbol)
}
inline ::std::string* SubmitNewOCOOrderInt::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrderInt.Symbol)
  return symbol_;
}
inline ::std::string* SubmitNewOCOOrderInt::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewOCOOrderInt::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrderInt.Symbol)
}

// optional string Exchange = 2;
inline bool SubmitNewOCOOrderInt::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubmitNewOCOOrderInt::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubmitNewOCOOrderInt::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& SubmitNewOCOOrderInt::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.Exchange)
  return *exchange_;
}
inline void SubmitNewOCOOrderInt::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.Exchange)
}
inline void SubmitNewOCOOrderInt::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrderInt.Exchange)
}
inline void SubmitNewOCOOrderInt::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrderInt.Exchange)
}
inline ::std::string* SubmitNewOCOOrderInt::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrderInt.Exchange)
  return exchange_;
}
inline ::std::string* SubmitNewOCOOrderInt::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewOCOOrderInt::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrderInt.Exchange)
}

// optional string ClientOrderID_1 = 3;
inline bool SubmitNewOCOOrderInt::has_clientorderid_1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_clientorderid_1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubmitNewOCOOrderInt::clear_has_clientorderid_1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubmitNewOCOOrderInt::clear_clientorderid_1() {
  if (clientorderid_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_1_->clear();
  }
  clear_has_clientorderid_1();
}
inline const ::std::string& SubmitNewOCOOrderInt::clientorderid_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_1)
  return *clientorderid_1_;
}
inline void SubmitNewOCOOrderInt::set_clientorderid_1(const ::std::string& value) {
  set_has_clientorderid_1();
  if (clientorderid_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_1_ = new ::std::string;
  }
  clientorderid_1_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_1)
}
inline void SubmitNewOCOOrderInt::set_clientorderid_1(const char* value) {
  set_has_clientorderid_1();
  if (clientorderid_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_1_ = new ::std::string;
  }
  clientorderid_1_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_1)
}
inline void SubmitNewOCOOrderInt::set_clientorderid_1(const char* value, size_t size) {
  set_has_clientorderid_1();
  if (clientorderid_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_1_ = new ::std::string;
  }
  clientorderid_1_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_1)
}
inline ::std::string* SubmitNewOCOOrderInt::mutable_clientorderid_1() {
  set_has_clientorderid_1();
  if (clientorderid_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_1_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_1)
  return clientorderid_1_;
}
inline ::std::string* SubmitNewOCOOrderInt::release_clientorderid_1() {
  clear_has_clientorderid_1();
  if (clientorderid_1_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientorderid_1_;
    clientorderid_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewOCOOrderInt::set_allocated_clientorderid_1(::std::string* clientorderid_1) {
  if (clientorderid_1_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientorderid_1_;
  }
  if (clientorderid_1) {
    set_has_clientorderid_1();
    clientorderid_1_ = clientorderid_1;
  } else {
    clear_has_clientorderid_1();
    clientorderid_1_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_1)
}

// optional .DTC_PB.OrderTypeEnum OrderType_1 = 4;
inline bool SubmitNewOCOOrderInt::has_ordertype_1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_ordertype_1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubmitNewOCOOrderInt::clear_has_ordertype_1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubmitNewOCOOrderInt::clear_ordertype_1() {
  ordertype_1_ = 0;
  clear_has_ordertype_1();
}
inline ::DTC_PB::OrderTypeEnum SubmitNewOCOOrderInt::ordertype_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.OrderType_1)
  return static_cast< ::DTC_PB::OrderTypeEnum >(ordertype_1_);
}
inline void SubmitNewOCOOrderInt::set_ordertype_1(::DTC_PB::OrderTypeEnum value) {
  assert(::DTC_PB::OrderTypeEnum_IsValid(value));
  set_has_ordertype_1();
  ordertype_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.OrderType_1)
}

// optional .DTC_PB.BuySellEnum BuySell_1 = 5;
inline bool SubmitNewOCOOrderInt::has_buysell_1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_buysell_1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubmitNewOCOOrderInt::clear_has_buysell_1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubmitNewOCOOrderInt::clear_buysell_1() {
  buysell_1_ = 0;
  clear_has_buysell_1();
}
inline ::DTC_PB::BuySellEnum SubmitNewOCOOrderInt::buysell_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.BuySell_1)
  return static_cast< ::DTC_PB::BuySellEnum >(buysell_1_);
}
inline void SubmitNewOCOOrderInt::set_buysell_1(::DTC_PB::BuySellEnum value) {
  assert(::DTC_PB::BuySellEnum_IsValid(value));
  set_has_buysell_1();
  buysell_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.BuySell_1)
}

// optional int64 Price1_1 = 6;
inline bool SubmitNewOCOOrderInt::has_price1_1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_price1_1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SubmitNewOCOOrderInt::clear_has_price1_1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SubmitNewOCOOrderInt::clear_price1_1() {
  price1_1_ = GOOGLE_LONGLONG(0);
  clear_has_price1_1();
}
inline ::google::protobuf::int64 SubmitNewOCOOrderInt::price1_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.Price1_1)
  return price1_1_;
}
inline void SubmitNewOCOOrderInt::set_price1_1(::google::protobuf::int64 value) {
  set_has_price1_1();
  price1_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.Price1_1)
}

// optional int64 Price2_1 = 7;
inline bool SubmitNewOCOOrderInt::has_price2_1() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_price2_1() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SubmitNewOCOOrderInt::clear_has_price2_1() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SubmitNewOCOOrderInt::clear_price2_1() {
  price2_1_ = GOOGLE_LONGLONG(0);
  clear_has_price2_1();
}
inline ::google::protobuf::int64 SubmitNewOCOOrderInt::price2_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.Price2_1)
  return price2_1_;
}
inline void SubmitNewOCOOrderInt::set_price2_1(::google::protobuf::int64 value) {
  set_has_price2_1();
  price2_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.Price2_1)
}

// optional int64 Quantity_1 = 8;
inline bool SubmitNewOCOOrderInt::has_quantity_1() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_quantity_1() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SubmitNewOCOOrderInt::clear_has_quantity_1() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SubmitNewOCOOrderInt::clear_quantity_1() {
  quantity_1_ = GOOGLE_LONGLONG(0);
  clear_has_quantity_1();
}
inline ::google::protobuf::int64 SubmitNewOCOOrderInt::quantity_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.Quantity_1)
  return quantity_1_;
}
inline void SubmitNewOCOOrderInt::set_quantity_1(::google::protobuf::int64 value) {
  set_has_quantity_1();
  quantity_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.Quantity_1)
}

// optional string ClientOrderID_2 = 9;
inline bool SubmitNewOCOOrderInt::has_clientorderid_2() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_clientorderid_2() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SubmitNewOCOOrderInt::clear_has_clientorderid_2() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SubmitNewOCOOrderInt::clear_clientorderid_2() {
  if (clientorderid_2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_2_->clear();
  }
  clear_has_clientorderid_2();
}
inline const ::std::string& SubmitNewOCOOrderInt::clientorderid_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_2)
  return *clientorderid_2_;
}
inline void SubmitNewOCOOrderInt::set_clientorderid_2(const ::std::string& value) {
  set_has_clientorderid_2();
  if (clientorderid_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_2_ = new ::std::string;
  }
  clientorderid_2_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_2)
}
inline void SubmitNewOCOOrderInt::set_clientorderid_2(const char* value) {
  set_has_clientorderid_2();
  if (clientorderid_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_2_ = new ::std::string;
  }
  clientorderid_2_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_2)
}
inline void SubmitNewOCOOrderInt::set_clientorderid_2(const char* value, size_t size) {
  set_has_clientorderid_2();
  if (clientorderid_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_2_ = new ::std::string;
  }
  clientorderid_2_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_2)
}
inline ::std::string* SubmitNewOCOOrderInt::mutable_clientorderid_2() {
  set_has_clientorderid_2();
  if (clientorderid_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_2_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_2)
  return clientorderid_2_;
}
inline ::std::string* SubmitNewOCOOrderInt::release_clientorderid_2() {
  clear_has_clientorderid_2();
  if (clientorderid_2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientorderid_2_;
    clientorderid_2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewOCOOrderInt::set_allocated_clientorderid_2(::std::string* clientorderid_2) {
  if (clientorderid_2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientorderid_2_;
  }
  if (clientorderid_2) {
    set_has_clientorderid_2();
    clientorderid_2_ = clientorderid_2;
  } else {
    clear_has_clientorderid_2();
    clientorderid_2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrderInt.ClientOrderID_2)
}

// optional .DTC_PB.OrderTypeEnum OrderType_2 = 10;
inline bool SubmitNewOCOOrderInt::has_ordertype_2() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_ordertype_2() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SubmitNewOCOOrderInt::clear_has_ordertype_2() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SubmitNewOCOOrderInt::clear_ordertype_2() {
  ordertype_2_ = 0;
  clear_has_ordertype_2();
}
inline ::DTC_PB::OrderTypeEnum SubmitNewOCOOrderInt::ordertype_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.OrderType_2)
  return static_cast< ::DTC_PB::OrderTypeEnum >(ordertype_2_);
}
inline void SubmitNewOCOOrderInt::set_ordertype_2(::DTC_PB::OrderTypeEnum value) {
  assert(::DTC_PB::OrderTypeEnum_IsValid(value));
  set_has_ordertype_2();
  ordertype_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.OrderType_2)
}

// optional .DTC_PB.BuySellEnum BuySell_2 = 11;
inline bool SubmitNewOCOOrderInt::has_buysell_2() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_buysell_2() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SubmitNewOCOOrderInt::clear_has_buysell_2() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SubmitNewOCOOrderInt::clear_buysell_2() {
  buysell_2_ = 0;
  clear_has_buysell_2();
}
inline ::DTC_PB::BuySellEnum SubmitNewOCOOrderInt::buysell_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.BuySell_2)
  return static_cast< ::DTC_PB::BuySellEnum >(buysell_2_);
}
inline void SubmitNewOCOOrderInt::set_buysell_2(::DTC_PB::BuySellEnum value) {
  assert(::DTC_PB::BuySellEnum_IsValid(value));
  set_has_buysell_2();
  buysell_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.BuySell_2)
}

// optional int64 Price1_2 = 12;
inline bool SubmitNewOCOOrderInt::has_price1_2() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_price1_2() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SubmitNewOCOOrderInt::clear_has_price1_2() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SubmitNewOCOOrderInt::clear_price1_2() {
  price1_2_ = GOOGLE_LONGLONG(0);
  clear_has_price1_2();
}
inline ::google::protobuf::int64 SubmitNewOCOOrderInt::price1_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.Price1_2)
  return price1_2_;
}
inline void SubmitNewOCOOrderInt::set_price1_2(::google::protobuf::int64 value) {
  set_has_price1_2();
  price1_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.Price1_2)
}

// optional int64 Price2_2 = 13;
inline bool SubmitNewOCOOrderInt::has_price2_2() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_price2_2() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SubmitNewOCOOrderInt::clear_has_price2_2() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SubmitNewOCOOrderInt::clear_price2_2() {
  price2_2_ = GOOGLE_LONGLONG(0);
  clear_has_price2_2();
}
inline ::google::protobuf::int64 SubmitNewOCOOrderInt::price2_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.Price2_2)
  return price2_2_;
}
inline void SubmitNewOCOOrderInt::set_price2_2(::google::protobuf::int64 value) {
  set_has_price2_2();
  price2_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.Price2_2)
}

// optional int64 Quantity_2 = 14;
inline bool SubmitNewOCOOrderInt::has_quantity_2() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_quantity_2() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SubmitNewOCOOrderInt::clear_has_quantity_2() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SubmitNewOCOOrderInt::clear_quantity_2() {
  quantity_2_ = GOOGLE_LONGLONG(0);
  clear_has_quantity_2();
}
inline ::google::protobuf::int64 SubmitNewOCOOrderInt::quantity_2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.Quantity_2)
  return quantity_2_;
}
inline void SubmitNewOCOOrderInt::set_quantity_2(::google::protobuf::int64 value) {
  set_has_quantity_2();
  quantity_2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.Quantity_2)
}

// optional .DTC_PB.TimeInForceEnum TimeInForce = 15;
inline bool SubmitNewOCOOrderInt::has_timeinforce() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_timeinforce() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SubmitNewOCOOrderInt::clear_has_timeinforce() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SubmitNewOCOOrderInt::clear_timeinforce() {
  timeinforce_ = 0;
  clear_has_timeinforce();
}
inline ::DTC_PB::TimeInForceEnum SubmitNewOCOOrderInt::timeinforce() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.TimeInForce)
  return static_cast< ::DTC_PB::TimeInForceEnum >(timeinforce_);
}
inline void SubmitNewOCOOrderInt::set_timeinforce(::DTC_PB::TimeInForceEnum value) {
  assert(::DTC_PB::TimeInForceEnum_IsValid(value));
  set_has_timeinforce();
  timeinforce_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.TimeInForce)
}

// optional sfixed64 GoodTillDateTime = 16;
inline bool SubmitNewOCOOrderInt::has_goodtilldatetime() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_goodtilldatetime() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SubmitNewOCOOrderInt::clear_has_goodtilldatetime() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SubmitNewOCOOrderInt::clear_goodtilldatetime() {
  goodtilldatetime_ = GOOGLE_LONGLONG(0);
  clear_has_goodtilldatetime();
}
inline ::google::protobuf::int64 SubmitNewOCOOrderInt::goodtilldatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.GoodTillDateTime)
  return goodtilldatetime_;
}
inline void SubmitNewOCOOrderInt::set_goodtilldatetime(::google::protobuf::int64 value) {
  set_has_goodtilldatetime();
  goodtilldatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.GoodTillDateTime)
}

// optional string TradeAccount = 17;
inline bool SubmitNewOCOOrderInt::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SubmitNewOCOOrderInt::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SubmitNewOCOOrderInt::clear_tradeaccount() {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_->clear();
  }
  clear_has_tradeaccount();
}
inline const ::std::string& SubmitNewOCOOrderInt::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.TradeAccount)
  return *tradeaccount_;
}
inline void SubmitNewOCOOrderInt::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.TradeAccount)
}
inline void SubmitNewOCOOrderInt::set_tradeaccount(const char* value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrderInt.TradeAccount)
}
inline void SubmitNewOCOOrderInt::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrderInt.TradeAccount)
}
inline ::std::string* SubmitNewOCOOrderInt::mutable_tradeaccount() {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrderInt.TradeAccount)
  return tradeaccount_;
}
inline ::std::string* SubmitNewOCOOrderInt::release_tradeaccount() {
  clear_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tradeaccount_;
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewOCOOrderInt::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tradeaccount_;
  }
  if (tradeaccount) {
    set_has_tradeaccount();
    tradeaccount_ = tradeaccount;
  } else {
    clear_has_tradeaccount();
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrderInt.TradeAccount)
}

// optional uint32 IsAutomatedOrder = 18;
inline bool SubmitNewOCOOrderInt::has_isautomatedorder() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_isautomatedorder() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SubmitNewOCOOrderInt::clear_has_isautomatedorder() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SubmitNewOCOOrderInt::clear_isautomatedorder() {
  isautomatedorder_ = 0u;
  clear_has_isautomatedorder();
}
inline ::google::protobuf::uint32 SubmitNewOCOOrderInt::isautomatedorder() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.IsAutomatedOrder)
  return isautomatedorder_;
}
inline void SubmitNewOCOOrderInt::set_isautomatedorder(::google::protobuf::uint32 value) {
  set_has_isautomatedorder();
  isautomatedorder_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.IsAutomatedOrder)
}

// optional string ParentTriggerClientOrderID = 19;
inline bool SubmitNewOCOOrderInt::has_parenttriggerclientorderid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_parenttriggerclientorderid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SubmitNewOCOOrderInt::clear_has_parenttriggerclientorderid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SubmitNewOCOOrderInt::clear_parenttriggerclientorderid() {
  if (parenttriggerclientorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parenttriggerclientorderid_->clear();
  }
  clear_has_parenttriggerclientorderid();
}
inline const ::std::string& SubmitNewOCOOrderInt::parenttriggerclientorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.ParentTriggerClientOrderID)
  return *parenttriggerclientorderid_;
}
inline void SubmitNewOCOOrderInt::set_parenttriggerclientorderid(const ::std::string& value) {
  set_has_parenttriggerclientorderid();
  if (parenttriggerclientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parenttriggerclientorderid_ = new ::std::string;
  }
  parenttriggerclientorderid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.ParentTriggerClientOrderID)
}
inline void SubmitNewOCOOrderInt::set_parenttriggerclientorderid(const char* value) {
  set_has_parenttriggerclientorderid();
  if (parenttriggerclientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parenttriggerclientorderid_ = new ::std::string;
  }
  parenttriggerclientorderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrderInt.ParentTriggerClientOrderID)
}
inline void SubmitNewOCOOrderInt::set_parenttriggerclientorderid(const char* value, size_t size) {
  set_has_parenttriggerclientorderid();
  if (parenttriggerclientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parenttriggerclientorderid_ = new ::std::string;
  }
  parenttriggerclientorderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrderInt.ParentTriggerClientOrderID)
}
inline ::std::string* SubmitNewOCOOrderInt::mutable_parenttriggerclientorderid() {
  set_has_parenttriggerclientorderid();
  if (parenttriggerclientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parenttriggerclientorderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrderInt.ParentTriggerClientOrderID)
  return parenttriggerclientorderid_;
}
inline ::std::string* SubmitNewOCOOrderInt::release_parenttriggerclientorderid() {
  clear_has_parenttriggerclientorderid();
  if (parenttriggerclientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = parenttriggerclientorderid_;
    parenttriggerclientorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewOCOOrderInt::set_allocated_parenttriggerclientorderid(::std::string* parenttriggerclientorderid) {
  if (parenttriggerclientorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete parenttriggerclientorderid_;
  }
  if (parenttriggerclientorderid) {
    set_has_parenttriggerclientorderid();
    parenttriggerclientorderid_ = parenttriggerclientorderid;
  } else {
    clear_has_parenttriggerclientorderid();
    parenttriggerclientorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrderInt.ParentTriggerClientOrderID)
}

// optional string FreeFormText = 20;
inline bool SubmitNewOCOOrderInt::has_freeformtext() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_freeformtext() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SubmitNewOCOOrderInt::clear_has_freeformtext() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SubmitNewOCOOrderInt::clear_freeformtext() {
  if (freeformtext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_->clear();
  }
  clear_has_freeformtext();
}
inline const ::std::string& SubmitNewOCOOrderInt::freeformtext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.FreeFormText)
  return *freeformtext_;
}
inline void SubmitNewOCOOrderInt::set_freeformtext(const ::std::string& value) {
  set_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_ = new ::std::string;
  }
  freeformtext_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.FreeFormText)
}
inline void SubmitNewOCOOrderInt::set_freeformtext(const char* value) {
  set_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_ = new ::std::string;
  }
  freeformtext_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SubmitNewOCOOrderInt.FreeFormText)
}
inline void SubmitNewOCOOrderInt::set_freeformtext(const char* value, size_t size) {
  set_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_ = new ::std::string;
  }
  freeformtext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SubmitNewOCOOrderInt.FreeFormText)
}
inline ::std::string* SubmitNewOCOOrderInt::mutable_freeformtext() {
  set_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    freeformtext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SubmitNewOCOOrderInt.FreeFormText)
  return freeformtext_;
}
inline ::std::string* SubmitNewOCOOrderInt::release_freeformtext() {
  clear_has_freeformtext();
  if (freeformtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = freeformtext_;
    freeformtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SubmitNewOCOOrderInt::set_allocated_freeformtext(::std::string* freeformtext) {
  if (freeformtext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete freeformtext_;
  }
  if (freeformtext) {
    set_has_freeformtext();
    freeformtext_ = freeformtext;
  } else {
    clear_has_freeformtext();
    freeformtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SubmitNewOCOOrderInt.FreeFormText)
}

// optional float Divisor = 21;
inline bool SubmitNewOCOOrderInt::has_divisor() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_divisor() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SubmitNewOCOOrderInt::clear_has_divisor() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SubmitNewOCOOrderInt::clear_divisor() {
  divisor_ = 0;
  clear_has_divisor();
}
inline float SubmitNewOCOOrderInt::divisor() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.Divisor)
  return divisor_;
}
inline void SubmitNewOCOOrderInt::set_divisor(float value) {
  set_has_divisor();
  divisor_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.Divisor)
}

// optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 22;
inline bool SubmitNewOCOOrderInt::has_openorclose() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SubmitNewOCOOrderInt::set_has_openorclose() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SubmitNewOCOOrderInt::clear_has_openorclose() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SubmitNewOCOOrderInt::clear_openorclose() {
  openorclose_ = 0;
  clear_has_openorclose();
}
inline ::DTC_PB::OpenCloseTradeEnum SubmitNewOCOOrderInt::openorclose() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SubmitNewOCOOrderInt.OpenOrClose)
  return static_cast< ::DTC_PB::OpenCloseTradeEnum >(openorclose_);
}
inline void SubmitNewOCOOrderInt::set_openorclose(::DTC_PB::OpenCloseTradeEnum value) {
  assert(::DTC_PB::OpenCloseTradeEnum_IsValid(value));
  set_has_openorclose();
  openorclose_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SubmitNewOCOOrderInt.OpenOrClose)
}

// -------------------------------------------------------------------

// OpenOrdersRequest

// optional int32 RequestID = 1;
inline bool OpenOrdersRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenOrdersRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenOrdersRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenOrdersRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 OpenOrdersRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OpenOrdersRequest.RequestID)
  return requestid_;
}
inline void OpenOrdersRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OpenOrdersRequest.RequestID)
}

// optional int32 RequestAllOrders = 2;
inline bool OpenOrdersRequest::has_requestallorders() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpenOrdersRequest::set_has_requestallorders() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpenOrdersRequest::clear_has_requestallorders() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpenOrdersRequest::clear_requestallorders() {
  requestallorders_ = 0;
  clear_has_requestallorders();
}
inline ::google::protobuf::int32 OpenOrdersRequest::requestallorders() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OpenOrdersRequest.RequestAllOrders)
  return requestallorders_;
}
inline void OpenOrdersRequest::set_requestallorders(::google::protobuf::int32 value) {
  set_has_requestallorders();
  requestallorders_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OpenOrdersRequest.RequestAllOrders)
}

// optional string ServerOrderID = 3;
inline bool OpenOrdersRequest::has_serverorderid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OpenOrdersRequest::set_has_serverorderid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OpenOrdersRequest::clear_has_serverorderid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OpenOrdersRequest::clear_serverorderid() {
  if (serverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_->clear();
  }
  clear_has_serverorderid();
}
inline const ::std::string& OpenOrdersRequest::serverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OpenOrdersRequest.ServerOrderID)
  return *serverorderid_;
}
inline void OpenOrdersRequest::set_serverorderid(const ::std::string& value) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.OpenOrdersRequest.ServerOrderID)
}
inline void OpenOrdersRequest::set_serverorderid(const char* value) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.OpenOrdersRequest.ServerOrderID)
}
inline void OpenOrdersRequest::set_serverorderid(const char* value, size_t size) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OpenOrdersRequest.ServerOrderID)
}
inline ::std::string* OpenOrdersRequest::mutable_serverorderid() {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.OpenOrdersRequest.ServerOrderID)
  return serverorderid_;
}
inline ::std::string* OpenOrdersRequest::release_serverorderid() {
  clear_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serverorderid_;
    serverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OpenOrdersRequest::set_allocated_serverorderid(::std::string* serverorderid) {
  if (serverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serverorderid_;
  }
  if (serverorderid) {
    set_has_serverorderid();
    serverorderid_ = serverorderid;
  } else {
    clear_has_serverorderid();
    serverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OpenOrdersRequest.ServerOrderID)
}

// -------------------------------------------------------------------

// HistoricalOrderFillsRequest

// optional int32 RequestID = 1;
inline bool HistoricalOrderFillsRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalOrderFillsRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalOrderFillsRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalOrderFillsRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalOrderFillsRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillsRequest.RequestID)
  return requestid_;
}
inline void HistoricalOrderFillsRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillsRequest.RequestID)
}

// optional string ServerOrderID = 2;
inline bool HistoricalOrderFillsRequest::has_serverorderid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalOrderFillsRequest::set_has_serverorderid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalOrderFillsRequest::clear_has_serverorderid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalOrderFillsRequest::clear_serverorderid() {
  if (serverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_->clear();
  }
  clear_has_serverorderid();
}
inline const ::std::string& HistoricalOrderFillsRequest::serverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillsRequest.ServerOrderID)
  return *serverorderid_;
}
inline void HistoricalOrderFillsRequest::set_serverorderid(const ::std::string& value) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillsRequest.ServerOrderID)
}
inline void HistoricalOrderFillsRequest::set_serverorderid(const char* value) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalOrderFillsRequest.ServerOrderID)
}
inline void HistoricalOrderFillsRequest::set_serverorderid(const char* value, size_t size) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalOrderFillsRequest.ServerOrderID)
}
inline ::std::string* HistoricalOrderFillsRequest::mutable_serverorderid() {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalOrderFillsRequest.ServerOrderID)
  return serverorderid_;
}
inline ::std::string* HistoricalOrderFillsRequest::release_serverorderid() {
  clear_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serverorderid_;
    serverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HistoricalOrderFillsRequest::set_allocated_serverorderid(::std::string* serverorderid) {
  if (serverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serverorderid_;
  }
  if (serverorderid) {
    set_has_serverorderid();
    serverorderid_ = serverorderid;
  } else {
    clear_has_serverorderid();
    serverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalOrderFillsRequest.ServerOrderID)
}

// optional int32 NumberOfDays = 3;
inline bool HistoricalOrderFillsRequest::has_numberofdays() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoricalOrderFillsRequest::set_has_numberofdays() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoricalOrderFillsRequest::clear_has_numberofdays() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoricalOrderFillsRequest::clear_numberofdays() {
  numberofdays_ = 0;
  clear_has_numberofdays();
}
inline ::google::protobuf::int32 HistoricalOrderFillsRequest::numberofdays() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillsRequest.NumberOfDays)
  return numberofdays_;
}
inline void HistoricalOrderFillsRequest::set_numberofdays(::google::protobuf::int32 value) {
  set_has_numberofdays();
  numberofdays_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillsRequest.NumberOfDays)
}

// optional string TradeAccount = 4;
inline bool HistoricalOrderFillsRequest::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoricalOrderFillsRequest::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoricalOrderFillsRequest::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoricalOrderFillsRequest::clear_tradeaccount() {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_->clear();
  }
  clear_has_tradeaccount();
}
inline const ::std::string& HistoricalOrderFillsRequest::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillsRequest.TradeAccount)
  return *tradeaccount_;
}
inline void HistoricalOrderFillsRequest::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillsRequest.TradeAccount)
}
inline void HistoricalOrderFillsRequest::set_tradeaccount(const char* value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalOrderFillsRequest.TradeAccount)
}
inline void HistoricalOrderFillsRequest::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalOrderFillsRequest.TradeAccount)
}
inline ::std::string* HistoricalOrderFillsRequest::mutable_tradeaccount() {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalOrderFillsRequest.TradeAccount)
  return tradeaccount_;
}
inline ::std::string* HistoricalOrderFillsRequest::release_tradeaccount() {
  clear_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tradeaccount_;
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HistoricalOrderFillsRequest::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tradeaccount_;
  }
  if (tradeaccount) {
    set_has_tradeaccount();
    tradeaccount_ = tradeaccount;
  } else {
    clear_has_tradeaccount();
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalOrderFillsRequest.TradeAccount)
}

// -------------------------------------------------------------------

// HistoricalOrderFillsReject

// optional int32 RequestID = 1;
inline bool HistoricalOrderFillsReject::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalOrderFillsReject::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalOrderFillsReject::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalOrderFillsReject::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalOrderFillsReject::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillsReject.RequestID)
  return requestid_;
}
inline void HistoricalOrderFillsReject::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillsReject.RequestID)
}

// optional string RejectText = 2;
inline bool HistoricalOrderFillsReject::has_rejecttext() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalOrderFillsReject::set_has_rejecttext() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalOrderFillsReject::clear_has_rejecttext() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalOrderFillsReject::clear_rejecttext() {
  if (rejecttext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_->clear();
  }
  clear_has_rejecttext();
}
inline const ::std::string& HistoricalOrderFillsReject::rejecttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillsReject.RejectText)
  return *rejecttext_;
}
inline void HistoricalOrderFillsReject::set_rejecttext(const ::std::string& value) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillsReject.RejectText)
}
inline void HistoricalOrderFillsReject::set_rejecttext(const char* value) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalOrderFillsReject.RejectText)
}
inline void HistoricalOrderFillsReject::set_rejecttext(const char* value, size_t size) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalOrderFillsReject.RejectText)
}
inline ::std::string* HistoricalOrderFillsReject::mutable_rejecttext() {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalOrderFillsReject.RejectText)
  return rejecttext_;
}
inline ::std::string* HistoricalOrderFillsReject::release_rejecttext() {
  clear_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rejecttext_;
    rejecttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HistoricalOrderFillsReject::set_allocated_rejecttext(::std::string* rejecttext) {
  if (rejecttext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rejecttext_;
  }
  if (rejecttext) {
    set_has_rejecttext();
    rejecttext_ = rejecttext;
  } else {
    clear_has_rejecttext();
    rejecttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalOrderFillsReject.RejectText)
}

// -------------------------------------------------------------------

// CurrentPositionsRequest

// optional int32 RequestID = 1;
inline bool CurrentPositionsRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CurrentPositionsRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CurrentPositionsRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CurrentPositionsRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 CurrentPositionsRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CurrentPositionsRequest.RequestID)
  return requestid_;
}
inline void CurrentPositionsRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CurrentPositionsRequest.RequestID)
}

// optional string TradeAccount = 2;
inline bool CurrentPositionsRequest::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CurrentPositionsRequest::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CurrentPositionsRequest::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CurrentPositionsRequest::clear_tradeaccount() {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_->clear();
  }
  clear_has_tradeaccount();
}
inline const ::std::string& CurrentPositionsRequest::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CurrentPositionsRequest.TradeAccount)
  return *tradeaccount_;
}
inline void CurrentPositionsRequest::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.CurrentPositionsRequest.TradeAccount)
}
inline void CurrentPositionsRequest::set_tradeaccount(const char* value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.CurrentPositionsRequest.TradeAccount)
}
inline void CurrentPositionsRequest::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.CurrentPositionsRequest.TradeAccount)
}
inline ::std::string* CurrentPositionsRequest::mutable_tradeaccount() {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.CurrentPositionsRequest.TradeAccount)
  return tradeaccount_;
}
inline ::std::string* CurrentPositionsRequest::release_tradeaccount() {
  clear_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tradeaccount_;
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CurrentPositionsRequest::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tradeaccount_;
  }
  if (tradeaccount) {
    set_has_tradeaccount();
    tradeaccount_ = tradeaccount;
  } else {
    clear_has_tradeaccount();
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.CurrentPositionsRequest.TradeAccount)
}

// -------------------------------------------------------------------

// CurrentPositionsReject

// optional int32 RequestID = 1;
inline bool CurrentPositionsReject::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CurrentPositionsReject::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CurrentPositionsReject::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CurrentPositionsReject::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 CurrentPositionsReject::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CurrentPositionsReject.RequestID)
  return requestid_;
}
inline void CurrentPositionsReject::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.CurrentPositionsReject.RequestID)
}

// optional string RejectText = 2;
inline bool CurrentPositionsReject::has_rejecttext() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CurrentPositionsReject::set_has_rejecttext() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CurrentPositionsReject::clear_has_rejecttext() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CurrentPositionsReject::clear_rejecttext() {
  if (rejecttext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_->clear();
  }
  clear_has_rejecttext();
}
inline const ::std::string& CurrentPositionsReject::rejecttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.CurrentPositionsReject.RejectText)
  return *rejecttext_;
}
inline void CurrentPositionsReject::set_rejecttext(const ::std::string& value) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.CurrentPositionsReject.RejectText)
}
inline void CurrentPositionsReject::set_rejecttext(const char* value) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.CurrentPositionsReject.RejectText)
}
inline void CurrentPositionsReject::set_rejecttext(const char* value, size_t size) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.CurrentPositionsReject.RejectText)
}
inline ::std::string* CurrentPositionsReject::mutable_rejecttext() {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.CurrentPositionsReject.RejectText)
  return rejecttext_;
}
inline ::std::string* CurrentPositionsReject::release_rejecttext() {
  clear_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rejecttext_;
    rejecttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CurrentPositionsReject::set_allocated_rejecttext(::std::string* rejecttext) {
  if (rejecttext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rejecttext_;
  }
  if (rejecttext) {
    set_has_rejecttext();
    rejecttext_ = rejecttext;
  } else {
    clear_has_rejecttext();
    rejecttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.CurrentPositionsReject.RejectText)
}

// -------------------------------------------------------------------

// OrderUpdate

// optional int32 RequestID = 1;
inline bool OrderUpdate::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderUpdate::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderUpdate::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderUpdate::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 OrderUpdate::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.RequestID)
  return requestid_;
}
inline void OrderUpdate::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.RequestID)
}

// optional int32 TotalNumMessages = 2;
inline bool OrderUpdate::has_totalnummessages() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderUpdate::set_has_totalnummessages() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderUpdate::clear_has_totalnummessages() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderUpdate::clear_totalnummessages() {
  totalnummessages_ = 0;
  clear_has_totalnummessages();
}
inline ::google::protobuf::int32 OrderUpdate::totalnummessages() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.TotalNumMessages)
  return totalnummessages_;
}
inline void OrderUpdate::set_totalnummessages(::google::protobuf::int32 value) {
  set_has_totalnummessages();
  totalnummessages_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.TotalNumMessages)
}

// optional int32 MessageNumber = 3;
inline bool OrderUpdate::has_messagenumber() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderUpdate::set_has_messagenumber() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderUpdate::clear_has_messagenumber() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderUpdate::clear_messagenumber() {
  messagenumber_ = 0;
  clear_has_messagenumber();
}
inline ::google::protobuf::int32 OrderUpdate::messagenumber() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.MessageNumber)
  return messagenumber_;
}
inline void OrderUpdate::set_messagenumber(::google::protobuf::int32 value) {
  set_has_messagenumber();
  messagenumber_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.MessageNumber)
}

// optional string Symbol = 4;
inline bool OrderUpdate::has_symbol() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderUpdate::set_has_symbol() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderUpdate::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderUpdate::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& OrderUpdate::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.Symbol)
  return *symbol_;
}
inline void OrderUpdate::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.Symbol)
}
inline void OrderUpdate::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.Symbol)
}
inline void OrderUpdate::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.Symbol)
}
inline ::std::string* OrderUpdate::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.Symbol)
  return symbol_;
}
inline ::std::string* OrderUpdate::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderUpdate::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.Symbol)
}

// optional string Exchange = 5;
inline bool OrderUpdate::has_exchange() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderUpdate::set_has_exchange() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderUpdate::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderUpdate::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& OrderUpdate::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.Exchange)
  return *exchange_;
}
inline void OrderUpdate::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.Exchange)
}
inline void OrderUpdate::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.Exchange)
}
inline void OrderUpdate::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.Exchange)
}
inline ::std::string* OrderUpdate::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.Exchange)
  return exchange_;
}
inline ::std::string* OrderUpdate::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderUpdate::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.Exchange)
}

// optional string PreviousServerOrderID = 6;
inline bool OrderUpdate::has_previousserverorderid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderUpdate::set_has_previousserverorderid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderUpdate::clear_has_previousserverorderid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderUpdate::clear_previousserverorderid() {
  if (previousserverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previousserverorderid_->clear();
  }
  clear_has_previousserverorderid();
}
inline const ::std::string& OrderUpdate::previousserverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.PreviousServerOrderID)
  return *previousserverorderid_;
}
inline void OrderUpdate::set_previousserverorderid(const ::std::string& value) {
  set_has_previousserverorderid();
  if (previousserverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previousserverorderid_ = new ::std::string;
  }
  previousserverorderid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.PreviousServerOrderID)
}
inline void OrderUpdate::set_previousserverorderid(const char* value) {
  set_has_previousserverorderid();
  if (previousserverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previousserverorderid_ = new ::std::string;
  }
  previousserverorderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.PreviousServerOrderID)
}
inline void OrderUpdate::set_previousserverorderid(const char* value, size_t size) {
  set_has_previousserverorderid();
  if (previousserverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previousserverorderid_ = new ::std::string;
  }
  previousserverorderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.PreviousServerOrderID)
}
inline ::std::string* OrderUpdate::mutable_previousserverorderid() {
  set_has_previousserverorderid();
  if (previousserverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previousserverorderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.PreviousServerOrderID)
  return previousserverorderid_;
}
inline ::std::string* OrderUpdate::release_previousserverorderid() {
  clear_has_previousserverorderid();
  if (previousserverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = previousserverorderid_;
    previousserverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderUpdate::set_allocated_previousserverorderid(::std::string* previousserverorderid) {
  if (previousserverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete previousserverorderid_;
  }
  if (previousserverorderid) {
    set_has_previousserverorderid();
    previousserverorderid_ = previousserverorderid;
  } else {
    clear_has_previousserverorderid();
    previousserverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.PreviousServerOrderID)
}

// optional string ServerOrderID = 7;
inline bool OrderUpdate::has_serverorderid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrderUpdate::set_has_serverorderid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrderUpdate::clear_has_serverorderid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrderUpdate::clear_serverorderid() {
  if (serverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_->clear();
  }
  clear_has_serverorderid();
}
inline const ::std::string& OrderUpdate::serverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.ServerOrderID)
  return *serverorderid_;
}
inline void OrderUpdate::set_serverorderid(const ::std::string& value) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.ServerOrderID)
}
inline void OrderUpdate::set_serverorderid(const char* value) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.ServerOrderID)
}
inline void OrderUpdate::set_serverorderid(const char* value, size_t size) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.ServerOrderID)
}
inline ::std::string* OrderUpdate::mutable_serverorderid() {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.ServerOrderID)
  return serverorderid_;
}
inline ::std::string* OrderUpdate::release_serverorderid() {
  clear_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serverorderid_;
    serverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderUpdate::set_allocated_serverorderid(::std::string* serverorderid) {
  if (serverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serverorderid_;
  }
  if (serverorderid) {
    set_has_serverorderid();
    serverorderid_ = serverorderid;
  } else {
    clear_has_serverorderid();
    serverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.ServerOrderID)
}

// optional string ClientOrderID = 8;
inline bool OrderUpdate::has_clientorderid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OrderUpdate::set_has_clientorderid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OrderUpdate::clear_has_clientorderid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OrderUpdate::clear_clientorderid() {
  if (clientorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_->clear();
  }
  clear_has_clientorderid();
}
inline const ::std::string& OrderUpdate::clientorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.ClientOrderID)
  return *clientorderid_;
}
inline void OrderUpdate::set_clientorderid(const ::std::string& value) {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  clientorderid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.ClientOrderID)
}
inline void OrderUpdate::set_clientorderid(const char* value) {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  clientorderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.ClientOrderID)
}
inline void OrderUpdate::set_clientorderid(const char* value, size_t size) {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  clientorderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.ClientOrderID)
}
inline ::std::string* OrderUpdate::mutable_clientorderid() {
  set_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientorderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.ClientOrderID)
  return clientorderid_;
}
inline ::std::string* OrderUpdate::release_clientorderid() {
  clear_has_clientorderid();
  if (clientorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientorderid_;
    clientorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderUpdate::set_allocated_clientorderid(::std::string* clientorderid) {
  if (clientorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientorderid_;
  }
  if (clientorderid) {
    set_has_clientorderid();
    clientorderid_ = clientorderid;
  } else {
    clear_has_clientorderid();
    clientorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.ClientOrderID)
}

// optional string ExchangeOrderID = 9;
inline bool OrderUpdate::has_exchangeorderid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OrderUpdate::set_has_exchangeorderid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OrderUpdate::clear_has_exchangeorderid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OrderUpdate::clear_exchangeorderid() {
  if (exchangeorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchangeorderid_->clear();
  }
  clear_has_exchangeorderid();
}
inline const ::std::string& OrderUpdate::exchangeorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.ExchangeOrderID)
  return *exchangeorderid_;
}
inline void OrderUpdate::set_exchangeorderid(const ::std::string& value) {
  set_has_exchangeorderid();
  if (exchangeorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchangeorderid_ = new ::std::string;
  }
  exchangeorderid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.ExchangeOrderID)
}
inline void OrderUpdate::set_exchangeorderid(const char* value) {
  set_has_exchangeorderid();
  if (exchangeorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchangeorderid_ = new ::std::string;
  }
  exchangeorderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.ExchangeOrderID)
}
inline void OrderUpdate::set_exchangeorderid(const char* value, size_t size) {
  set_has_exchangeorderid();
  if (exchangeorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchangeorderid_ = new ::std::string;
  }
  exchangeorderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.ExchangeOrderID)
}
inline ::std::string* OrderUpdate::mutable_exchangeorderid() {
  set_has_exchangeorderid();
  if (exchangeorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchangeorderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.ExchangeOrderID)
  return exchangeorderid_;
}
inline ::std::string* OrderUpdate::release_exchangeorderid() {
  clear_has_exchangeorderid();
  if (exchangeorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchangeorderid_;
    exchangeorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderUpdate::set_allocated_exchangeorderid(::std::string* exchangeorderid) {
  if (exchangeorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchangeorderid_;
  }
  if (exchangeorderid) {
    set_has_exchangeorderid();
    exchangeorderid_ = exchangeorderid;
  } else {
    clear_has_exchangeorderid();
    exchangeorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.ExchangeOrderID)
}

// optional .DTC_PB.OrderStatusEnum OrderStatus = 10;
inline bool OrderUpdate::has_orderstatus() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OrderUpdate::set_has_orderstatus() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OrderUpdate::clear_has_orderstatus() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OrderUpdate::clear_orderstatus() {
  orderstatus_ = 0;
  clear_has_orderstatus();
}
inline ::DTC_PB::OrderStatusEnum OrderUpdate::orderstatus() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.OrderStatus)
  return static_cast< ::DTC_PB::OrderStatusEnum >(orderstatus_);
}
inline void OrderUpdate::set_orderstatus(::DTC_PB::OrderStatusEnum value) {
  assert(::DTC_PB::OrderStatusEnum_IsValid(value));
  set_has_orderstatus();
  orderstatus_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.OrderStatus)
}

// optional .DTC_PB.OrderUpdateReasonEnum OrderUpdateReason = 11;
inline bool OrderUpdate::has_orderupdatereason() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void OrderUpdate::set_has_orderupdatereason() {
  _has_bits_[0] |= 0x00000400u;
}
inline void OrderUpdate::clear_has_orderupdatereason() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void OrderUpdate::clear_orderupdatereason() {
  orderupdatereason_ = 0;
  clear_has_orderupdatereason();
}
inline ::DTC_PB::OrderUpdateReasonEnum OrderUpdate::orderupdatereason() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.OrderUpdateReason)
  return static_cast< ::DTC_PB::OrderUpdateReasonEnum >(orderupdatereason_);
}
inline void OrderUpdate::set_orderupdatereason(::DTC_PB::OrderUpdateReasonEnum value) {
  assert(::DTC_PB::OrderUpdateReasonEnum_IsValid(value));
  set_has_orderupdatereason();
  orderupdatereason_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.OrderUpdateReason)
}

// optional .DTC_PB.OrderTypeEnum OrderType = 12;
inline bool OrderUpdate::has_ordertype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void OrderUpdate::set_has_ordertype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void OrderUpdate::clear_has_ordertype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void OrderUpdate::clear_ordertype() {
  ordertype_ = 0;
  clear_has_ordertype();
}
inline ::DTC_PB::OrderTypeEnum OrderUpdate::ordertype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.OrderType)
  return static_cast< ::DTC_PB::OrderTypeEnum >(ordertype_);
}
inline void OrderUpdate::set_ordertype(::DTC_PB::OrderTypeEnum value) {
  assert(::DTC_PB::OrderTypeEnum_IsValid(value));
  set_has_ordertype();
  ordertype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.OrderType)
}

// optional .DTC_PB.BuySellEnum BuySell = 13;
inline bool OrderUpdate::has_buysell() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void OrderUpdate::set_has_buysell() {
  _has_bits_[0] |= 0x00001000u;
}
inline void OrderUpdate::clear_has_buysell() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void OrderUpdate::clear_buysell() {
  buysell_ = 0;
  clear_has_buysell();
}
inline ::DTC_PB::BuySellEnum OrderUpdate::buysell() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.BuySell)
  return static_cast< ::DTC_PB::BuySellEnum >(buysell_);
}
inline void OrderUpdate::set_buysell(::DTC_PB::BuySellEnum value) {
  assert(::DTC_PB::BuySellEnum_IsValid(value));
  set_has_buysell();
  buysell_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.BuySell)
}

// optional double Price1 = 14;
inline bool OrderUpdate::has_price1() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void OrderUpdate::set_has_price1() {
  _has_bits_[0] |= 0x00002000u;
}
inline void OrderUpdate::clear_has_price1() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void OrderUpdate::clear_price1() {
  price1_ = 0;
  clear_has_price1();
}
inline double OrderUpdate::price1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.Price1)
  return price1_;
}
inline void OrderUpdate::set_price1(double value) {
  set_has_price1();
  price1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.Price1)
}

// optional double Price2 = 15;
inline bool OrderUpdate::has_price2() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void OrderUpdate::set_has_price2() {
  _has_bits_[0] |= 0x00004000u;
}
inline void OrderUpdate::clear_has_price2() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void OrderUpdate::clear_price2() {
  price2_ = 0;
  clear_has_price2();
}
inline double OrderUpdate::price2() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.Price2)
  return price2_;
}
inline void OrderUpdate::set_price2(double value) {
  set_has_price2();
  price2_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.Price2)
}

// optional .DTC_PB.TimeInForceEnum TimeInForce = 16;
inline bool OrderUpdate::has_timeinforce() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void OrderUpdate::set_has_timeinforce() {
  _has_bits_[0] |= 0x00008000u;
}
inline void OrderUpdate::clear_has_timeinforce() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void OrderUpdate::clear_timeinforce() {
  timeinforce_ = 0;
  clear_has_timeinforce();
}
inline ::DTC_PB::TimeInForceEnum OrderUpdate::timeinforce() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.TimeInForce)
  return static_cast< ::DTC_PB::TimeInForceEnum >(timeinforce_);
}
inline void OrderUpdate::set_timeinforce(::DTC_PB::TimeInForceEnum value) {
  assert(::DTC_PB::TimeInForceEnum_IsValid(value));
  set_has_timeinforce();
  timeinforce_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.TimeInForce)
}

// optional sfixed64 GoodTillDateTime = 17;
inline bool OrderUpdate::has_goodtilldatetime() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void OrderUpdate::set_has_goodtilldatetime() {
  _has_bits_[0] |= 0x00010000u;
}
inline void OrderUpdate::clear_has_goodtilldatetime() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void OrderUpdate::clear_goodtilldatetime() {
  goodtilldatetime_ = GOOGLE_LONGLONG(0);
  clear_has_goodtilldatetime();
}
inline ::google::protobuf::int64 OrderUpdate::goodtilldatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.GoodTillDateTime)
  return goodtilldatetime_;
}
inline void OrderUpdate::set_goodtilldatetime(::google::protobuf::int64 value) {
  set_has_goodtilldatetime();
  goodtilldatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.GoodTillDateTime)
}

// optional double OrderQuantity = 18;
inline bool OrderUpdate::has_orderquantity() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void OrderUpdate::set_has_orderquantity() {
  _has_bits_[0] |= 0x00020000u;
}
inline void OrderUpdate::clear_has_orderquantity() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void OrderUpdate::clear_orderquantity() {
  orderquantity_ = 0;
  clear_has_orderquantity();
}
inline double OrderUpdate::orderquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.OrderQuantity)
  return orderquantity_;
}
inline void OrderUpdate::set_orderquantity(double value) {
  set_has_orderquantity();
  orderquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.OrderQuantity)
}

// optional double FilledQuantity = 19;
inline bool OrderUpdate::has_filledquantity() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void OrderUpdate::set_has_filledquantity() {
  _has_bits_[0] |= 0x00040000u;
}
inline void OrderUpdate::clear_has_filledquantity() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void OrderUpdate::clear_filledquantity() {
  filledquantity_ = 0;
  clear_has_filledquantity();
}
inline double OrderUpdate::filledquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.FilledQuantity)
  return filledquantity_;
}
inline void OrderUpdate::set_filledquantity(double value) {
  set_has_filledquantity();
  filledquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.FilledQuantity)
}

// optional double RemainingQuantity = 20;
inline bool OrderUpdate::has_remainingquantity() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void OrderUpdate::set_has_remainingquantity() {
  _has_bits_[0] |= 0x00080000u;
}
inline void OrderUpdate::clear_has_remainingquantity() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void OrderUpdate::clear_remainingquantity() {
  remainingquantity_ = 0;
  clear_has_remainingquantity();
}
inline double OrderUpdate::remainingquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.RemainingQuantity)
  return remainingquantity_;
}
inline void OrderUpdate::set_remainingquantity(double value) {
  set_has_remainingquantity();
  remainingquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.RemainingQuantity)
}

// optional double AverageFillPrice = 21;
inline bool OrderUpdate::has_averagefillprice() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void OrderUpdate::set_has_averagefillprice() {
  _has_bits_[0] |= 0x00100000u;
}
inline void OrderUpdate::clear_has_averagefillprice() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void OrderUpdate::clear_averagefillprice() {
  averagefillprice_ = 0;
  clear_has_averagefillprice();
}
inline double OrderUpdate::averagefillprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.AverageFillPrice)
  return averagefillprice_;
}
inline void OrderUpdate::set_averagefillprice(double value) {
  set_has_averagefillprice();
  averagefillprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.AverageFillPrice)
}

// optional double LastFillPrice = 22;
inline bool OrderUpdate::has_lastfillprice() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void OrderUpdate::set_has_lastfillprice() {
  _has_bits_[0] |= 0x00200000u;
}
inline void OrderUpdate::clear_has_lastfillprice() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void OrderUpdate::clear_lastfillprice() {
  lastfillprice_ = 0;
  clear_has_lastfillprice();
}
inline double OrderUpdate::lastfillprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.LastFillPrice)
  return lastfillprice_;
}
inline void OrderUpdate::set_lastfillprice(double value) {
  set_has_lastfillprice();
  lastfillprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.LastFillPrice)
}

// optional sfixed64 LastFillDateTime = 23;
inline bool OrderUpdate::has_lastfilldatetime() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void OrderUpdate::set_has_lastfilldatetime() {
  _has_bits_[0] |= 0x00400000u;
}
inline void OrderUpdate::clear_has_lastfilldatetime() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void OrderUpdate::clear_lastfilldatetime() {
  lastfilldatetime_ = GOOGLE_LONGLONG(0);
  clear_has_lastfilldatetime();
}
inline ::google::protobuf::int64 OrderUpdate::lastfilldatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.LastFillDateTime)
  return lastfilldatetime_;
}
inline void OrderUpdate::set_lastfilldatetime(::google::protobuf::int64 value) {
  set_has_lastfilldatetime();
  lastfilldatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.LastFillDateTime)
}

// optional double LastFillQuantity = 24;
inline bool OrderUpdate::has_lastfillquantity() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void OrderUpdate::set_has_lastfillquantity() {
  _has_bits_[0] |= 0x00800000u;
}
inline void OrderUpdate::clear_has_lastfillquantity() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void OrderUpdate::clear_lastfillquantity() {
  lastfillquantity_ = 0;
  clear_has_lastfillquantity();
}
inline double OrderUpdate::lastfillquantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.LastFillQuantity)
  return lastfillquantity_;
}
inline void OrderUpdate::set_lastfillquantity(double value) {
  set_has_lastfillquantity();
  lastfillquantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.LastFillQuantity)
}

// optional string LastFillExecutionID = 25;
inline bool OrderUpdate::has_lastfillexecutionid() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void OrderUpdate::set_has_lastfillexecutionid() {
  _has_bits_[0] |= 0x01000000u;
}
inline void OrderUpdate::clear_has_lastfillexecutionid() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void OrderUpdate::clear_lastfillexecutionid() {
  if (lastfillexecutionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastfillexecutionid_->clear();
  }
  clear_has_lastfillexecutionid();
}
inline const ::std::string& OrderUpdate::lastfillexecutionid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.LastFillExecutionID)
  return *lastfillexecutionid_;
}
inline void OrderUpdate::set_lastfillexecutionid(const ::std::string& value) {
  set_has_lastfillexecutionid();
  if (lastfillexecutionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastfillexecutionid_ = new ::std::string;
  }
  lastfillexecutionid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.LastFillExecutionID)
}
inline void OrderUpdate::set_lastfillexecutionid(const char* value) {
  set_has_lastfillexecutionid();
  if (lastfillexecutionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastfillexecutionid_ = new ::std::string;
  }
  lastfillexecutionid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.LastFillExecutionID)
}
inline void OrderUpdate::set_lastfillexecutionid(const char* value, size_t size) {
  set_has_lastfillexecutionid();
  if (lastfillexecutionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastfillexecutionid_ = new ::std::string;
  }
  lastfillexecutionid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.LastFillExecutionID)
}
inline ::std::string* OrderUpdate::mutable_lastfillexecutionid() {
  set_has_lastfillexecutionid();
  if (lastfillexecutionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastfillexecutionid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.LastFillExecutionID)
  return lastfillexecutionid_;
}
inline ::std::string* OrderUpdate::release_lastfillexecutionid() {
  clear_has_lastfillexecutionid();
  if (lastfillexecutionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lastfillexecutionid_;
    lastfillexecutionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderUpdate::set_allocated_lastfillexecutionid(::std::string* lastfillexecutionid) {
  if (lastfillexecutionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lastfillexecutionid_;
  }
  if (lastfillexecutionid) {
    set_has_lastfillexecutionid();
    lastfillexecutionid_ = lastfillexecutionid;
  } else {
    clear_has_lastfillexecutionid();
    lastfillexecutionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.LastFillExecutionID)
}

// optional string TradeAccount = 26;
inline bool OrderUpdate::has_tradeaccount() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void OrderUpdate::set_has_tradeaccount() {
  _has_bits_[0] |= 0x02000000u;
}
inline void OrderUpdate::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void OrderUpdate::clear_tradeaccount() {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_->clear();
  }
  clear_has_tradeaccount();
}
inline const ::std::string& OrderUpdate::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.TradeAccount)
  return *tradeaccount_;
}
inline void OrderUpdate::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.TradeAccount)
}
inline void OrderUpdate::set_tradeaccount(const char* value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.TradeAccount)
}
inline void OrderUpdate::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.TradeAccount)
}
inline ::std::string* OrderUpdate::mutable_tradeaccount() {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.TradeAccount)
  return tradeaccount_;
}
inline ::std::string* OrderUpdate::release_tradeaccount() {
  clear_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tradeaccount_;
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderUpdate::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tradeaccount_;
  }
  if (tradeaccount) {
    set_has_tradeaccount();
    tradeaccount_ = tradeaccount;
  } else {
    clear_has_tradeaccount();
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.TradeAccount)
}

// optional string InfoText = 27;
inline bool OrderUpdate::has_infotext() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void OrderUpdate::set_has_infotext() {
  _has_bits_[0] |= 0x04000000u;
}
inline void OrderUpdate::clear_has_infotext() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void OrderUpdate::clear_infotext() {
  if (infotext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    infotext_->clear();
  }
  clear_has_infotext();
}
inline const ::std::string& OrderUpdate::infotext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.InfoText)
  return *infotext_;
}
inline void OrderUpdate::set_infotext(const ::std::string& value) {
  set_has_infotext();
  if (infotext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    infotext_ = new ::std::string;
  }
  infotext_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.InfoText)
}
inline void OrderUpdate::set_infotext(const char* value) {
  set_has_infotext();
  if (infotext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    infotext_ = new ::std::string;
  }
  infotext_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.InfoText)
}
inline void OrderUpdate::set_infotext(const char* value, size_t size) {
  set_has_infotext();
  if (infotext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    infotext_ = new ::std::string;
  }
  infotext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.InfoText)
}
inline ::std::string* OrderUpdate::mutable_infotext() {
  set_has_infotext();
  if (infotext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    infotext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.InfoText)
  return infotext_;
}
inline ::std::string* OrderUpdate::release_infotext() {
  clear_has_infotext();
  if (infotext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = infotext_;
    infotext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderUpdate::set_allocated_infotext(::std::string* infotext) {
  if (infotext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete infotext_;
  }
  if (infotext) {
    set_has_infotext();
    infotext_ = infotext;
  } else {
    clear_has_infotext();
    infotext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.InfoText)
}

// optional uint32 NoOrders = 28;
inline bool OrderUpdate::has_noorders() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void OrderUpdate::set_has_noorders() {
  _has_bits_[0] |= 0x08000000u;
}
inline void OrderUpdate::clear_has_noorders() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void OrderUpdate::clear_noorders() {
  noorders_ = 0u;
  clear_has_noorders();
}
inline ::google::protobuf::uint32 OrderUpdate::noorders() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.NoOrders)
  return noorders_;
}
inline void OrderUpdate::set_noorders(::google::protobuf::uint32 value) {
  set_has_noorders();
  noorders_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.NoOrders)
}

// optional string ParentServerOrderID = 29;
inline bool OrderUpdate::has_parentserverorderid() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void OrderUpdate::set_has_parentserverorderid() {
  _has_bits_[0] |= 0x10000000u;
}
inline void OrderUpdate::clear_has_parentserverorderid() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void OrderUpdate::clear_parentserverorderid() {
  if (parentserverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parentserverorderid_->clear();
  }
  clear_has_parentserverorderid();
}
inline const ::std::string& OrderUpdate::parentserverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.ParentServerOrderID)
  return *parentserverorderid_;
}
inline void OrderUpdate::set_parentserverorderid(const ::std::string& value) {
  set_has_parentserverorderid();
  if (parentserverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parentserverorderid_ = new ::std::string;
  }
  parentserverorderid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.ParentServerOrderID)
}
inline void OrderUpdate::set_parentserverorderid(const char* value) {
  set_has_parentserverorderid();
  if (parentserverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parentserverorderid_ = new ::std::string;
  }
  parentserverorderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.ParentServerOrderID)
}
inline void OrderUpdate::set_parentserverorderid(const char* value, size_t size) {
  set_has_parentserverorderid();
  if (parentserverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parentserverorderid_ = new ::std::string;
  }
  parentserverorderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.ParentServerOrderID)
}
inline ::std::string* OrderUpdate::mutable_parentserverorderid() {
  set_has_parentserverorderid();
  if (parentserverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parentserverorderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.ParentServerOrderID)
  return parentserverorderid_;
}
inline ::std::string* OrderUpdate::release_parentserverorderid() {
  clear_has_parentserverorderid();
  if (parentserverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = parentserverorderid_;
    parentserverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderUpdate::set_allocated_parentserverorderid(::std::string* parentserverorderid) {
  if (parentserverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete parentserverorderid_;
  }
  if (parentserverorderid) {
    set_has_parentserverorderid();
    parentserverorderid_ = parentserverorderid;
  } else {
    clear_has_parentserverorderid();
    parentserverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.ParentServerOrderID)
}

// optional string OCOLinkedOrderServerOrderID = 30;
inline bool OrderUpdate::has_ocolinkedorderserverorderid() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void OrderUpdate::set_has_ocolinkedorderserverorderid() {
  _has_bits_[0] |= 0x20000000u;
}
inline void OrderUpdate::clear_has_ocolinkedorderserverorderid() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void OrderUpdate::clear_ocolinkedorderserverorderid() {
  if (ocolinkedorderserverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ocolinkedorderserverorderid_->clear();
  }
  clear_has_ocolinkedorderserverorderid();
}
inline const ::std::string& OrderUpdate::ocolinkedorderserverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.OCOLinkedOrderServerOrderID)
  return *ocolinkedorderserverorderid_;
}
inline void OrderUpdate::set_ocolinkedorderserverorderid(const ::std::string& value) {
  set_has_ocolinkedorderserverorderid();
  if (ocolinkedorderserverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ocolinkedorderserverorderid_ = new ::std::string;
  }
  ocolinkedorderserverorderid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.OCOLinkedOrderServerOrderID)
}
inline void OrderUpdate::set_ocolinkedorderserverorderid(const char* value) {
  set_has_ocolinkedorderserverorderid();
  if (ocolinkedorderserverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ocolinkedorderserverorderid_ = new ::std::string;
  }
  ocolinkedorderserverorderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.OrderUpdate.OCOLinkedOrderServerOrderID)
}
inline void OrderUpdate::set_ocolinkedorderserverorderid(const char* value, size_t size) {
  set_has_ocolinkedorderserverorderid();
  if (ocolinkedorderserverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ocolinkedorderserverorderid_ = new ::std::string;
  }
  ocolinkedorderserverorderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OrderUpdate.OCOLinkedOrderServerOrderID)
}
inline ::std::string* OrderUpdate::mutable_ocolinkedorderserverorderid() {
  set_has_ocolinkedorderserverorderid();
  if (ocolinkedorderserverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ocolinkedorderserverorderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.OrderUpdate.OCOLinkedOrderServerOrderID)
  return ocolinkedorderserverorderid_;
}
inline ::std::string* OrderUpdate::release_ocolinkedorderserverorderid() {
  clear_has_ocolinkedorderserverorderid();
  if (ocolinkedorderserverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ocolinkedorderserverorderid_;
    ocolinkedorderserverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OrderUpdate::set_allocated_ocolinkedorderserverorderid(::std::string* ocolinkedorderserverorderid) {
  if (ocolinkedorderserverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ocolinkedorderserverorderid_;
  }
  if (ocolinkedorderserverorderid) {
    set_has_ocolinkedorderserverorderid();
    ocolinkedorderserverorderid_ = ocolinkedorderserverorderid;
  } else {
    clear_has_ocolinkedorderserverorderid();
    ocolinkedorderserverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OrderUpdate.OCOLinkedOrderServerOrderID)
}

// optional .DTC_PB.OpenCloseTradeEnum OpenOrClose = 31;
inline bool OrderUpdate::has_openorclose() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void OrderUpdate::set_has_openorclose() {
  _has_bits_[0] |= 0x40000000u;
}
inline void OrderUpdate::clear_has_openorclose() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void OrderUpdate::clear_openorclose() {
  openorclose_ = 0;
  clear_has_openorclose();
}
inline ::DTC_PB::OpenCloseTradeEnum OrderUpdate::openorclose() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OrderUpdate.OpenOrClose)
  return static_cast< ::DTC_PB::OpenCloseTradeEnum >(openorclose_);
}
inline void OrderUpdate::set_openorclose(::DTC_PB::OpenCloseTradeEnum value) {
  assert(::DTC_PB::OpenCloseTradeEnum_IsValid(value));
  set_has_openorclose();
  openorclose_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OrderUpdate.OpenOrClose)
}

// -------------------------------------------------------------------

// OpenOrdersReject

// optional int32 RequestID = 1;
inline bool OpenOrdersReject::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenOrdersReject::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenOrdersReject::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenOrdersReject::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 OpenOrdersReject::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OpenOrdersReject.RequestID)
  return requestid_;
}
inline void OpenOrdersReject::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.OpenOrdersReject.RequestID)
}

// optional string RejectText = 2;
inline bool OpenOrdersReject::has_rejecttext() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpenOrdersReject::set_has_rejecttext() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpenOrdersReject::clear_has_rejecttext() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpenOrdersReject::clear_rejecttext() {
  if (rejecttext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_->clear();
  }
  clear_has_rejecttext();
}
inline const ::std::string& OpenOrdersReject::rejecttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.OpenOrdersReject.RejectText)
  return *rejecttext_;
}
inline void OpenOrdersReject::set_rejecttext(const ::std::string& value) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.OpenOrdersReject.RejectText)
}
inline void OpenOrdersReject::set_rejecttext(const char* value) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.OpenOrdersReject.RejectText)
}
inline void OpenOrdersReject::set_rejecttext(const char* value, size_t size) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.OpenOrdersReject.RejectText)
}
inline ::std::string* OpenOrdersReject::mutable_rejecttext() {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.OpenOrdersReject.RejectText)
  return rejecttext_;
}
inline ::std::string* OpenOrdersReject::release_rejecttext() {
  clear_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rejecttext_;
    rejecttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OpenOrdersReject::set_allocated_rejecttext(::std::string* rejecttext) {
  if (rejecttext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rejecttext_;
  }
  if (rejecttext) {
    set_has_rejecttext();
    rejecttext_ = rejecttext;
  } else {
    clear_has_rejecttext();
    rejecttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.OpenOrdersReject.RejectText)
}

// -------------------------------------------------------------------

// HistoricalOrderFillResponse

// optional int32 RequestID = 1;
inline bool HistoricalOrderFillResponse::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalOrderFillResponse::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalOrderFillResponse::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalOrderFillResponse::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.RequestID)
  return requestid_;
}
inline void HistoricalOrderFillResponse::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.RequestID)
}

// optional int32 TotalNumberMessages = 2;
inline bool HistoricalOrderFillResponse::has_totalnumbermessages() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_totalnumbermessages() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalOrderFillResponse::clear_has_totalnumbermessages() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalOrderFillResponse::clear_totalnumbermessages() {
  totalnumbermessages_ = 0;
  clear_has_totalnumbermessages();
}
inline ::google::protobuf::int32 HistoricalOrderFillResponse::totalnumbermessages() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.TotalNumberMessages)
  return totalnumbermessages_;
}
inline void HistoricalOrderFillResponse::set_totalnumbermessages(::google::protobuf::int32 value) {
  set_has_totalnumbermessages();
  totalnumbermessages_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.TotalNumberMessages)
}

// optional int32 MessageNumber = 3;
inline bool HistoricalOrderFillResponse::has_messagenumber() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_messagenumber() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoricalOrderFillResponse::clear_has_messagenumber() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoricalOrderFillResponse::clear_messagenumber() {
  messagenumber_ = 0;
  clear_has_messagenumber();
}
inline ::google::protobuf::int32 HistoricalOrderFillResponse::messagenumber() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.MessageNumber)
  return messagenumber_;
}
inline void HistoricalOrderFillResponse::set_messagenumber(::google::protobuf::int32 value) {
  set_has_messagenumber();
  messagenumber_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.MessageNumber)
}

// optional string Symbol = 4;
inline bool HistoricalOrderFillResponse::has_symbol() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_symbol() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoricalOrderFillResponse::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoricalOrderFillResponse::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& HistoricalOrderFillResponse::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.Symbol)
  return *symbol_;
}
inline void HistoricalOrderFillResponse::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.Symbol)
}
inline void HistoricalOrderFillResponse::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalOrderFillResponse.Symbol)
}
inline void HistoricalOrderFillResponse::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalOrderFillResponse.Symbol)
}
inline ::std::string* HistoricalOrderFillResponse::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalOrderFillResponse.Symbol)
  return symbol_;
}
inline ::std::string* HistoricalOrderFillResponse::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HistoricalOrderFillResponse::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalOrderFillResponse.Symbol)
}

// optional string Exchange = 5;
inline bool HistoricalOrderFillResponse::has_exchange() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_exchange() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoricalOrderFillResponse::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoricalOrderFillResponse::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& HistoricalOrderFillResponse::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.Exchange)
  return *exchange_;
}
inline void HistoricalOrderFillResponse::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.Exchange)
}
inline void HistoricalOrderFillResponse::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalOrderFillResponse.Exchange)
}
inline void HistoricalOrderFillResponse::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalOrderFillResponse.Exchange)
}
inline ::std::string* HistoricalOrderFillResponse::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalOrderFillResponse.Exchange)
  return exchange_;
}
inline ::std::string* HistoricalOrderFillResponse::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HistoricalOrderFillResponse::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalOrderFillResponse.Exchange)
}

// optional string ServerOrderID = 6;
inline bool HistoricalOrderFillResponse::has_serverorderid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_serverorderid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HistoricalOrderFillResponse::clear_has_serverorderid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HistoricalOrderFillResponse::clear_serverorderid() {
  if (serverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_->clear();
  }
  clear_has_serverorderid();
}
inline const ::std::string& HistoricalOrderFillResponse::serverorderid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.ServerOrderID)
  return *serverorderid_;
}
inline void HistoricalOrderFillResponse::set_serverorderid(const ::std::string& value) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.ServerOrderID)
}
inline void HistoricalOrderFillResponse::set_serverorderid(const char* value) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalOrderFillResponse.ServerOrderID)
}
inline void HistoricalOrderFillResponse::set_serverorderid(const char* value, size_t size) {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  serverorderid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalOrderFillResponse.ServerOrderID)
}
inline ::std::string* HistoricalOrderFillResponse::mutable_serverorderid() {
  set_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverorderid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalOrderFillResponse.ServerOrderID)
  return serverorderid_;
}
inline ::std::string* HistoricalOrderFillResponse::release_serverorderid() {
  clear_has_serverorderid();
  if (serverorderid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serverorderid_;
    serverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HistoricalOrderFillResponse::set_allocated_serverorderid(::std::string* serverorderid) {
  if (serverorderid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serverorderid_;
  }
  if (serverorderid) {
    set_has_serverorderid();
    serverorderid_ = serverorderid;
  } else {
    clear_has_serverorderid();
    serverorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalOrderFillResponse.ServerOrderID)
}

// optional .DTC_PB.BuySellEnum BuySell = 7;
inline bool HistoricalOrderFillResponse::has_buysell() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_buysell() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HistoricalOrderFillResponse::clear_has_buysell() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HistoricalOrderFillResponse::clear_buysell() {
  buysell_ = 0;
  clear_has_buysell();
}
inline ::DTC_PB::BuySellEnum HistoricalOrderFillResponse::buysell() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.BuySell)
  return static_cast< ::DTC_PB::BuySellEnum >(buysell_);
}
inline void HistoricalOrderFillResponse::set_buysell(::DTC_PB::BuySellEnum value) {
  assert(::DTC_PB::BuySellEnum_IsValid(value));
  set_has_buysell();
  buysell_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.BuySell)
}

// optional double Price = 8;
inline bool HistoricalOrderFillResponse::has_price() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_price() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HistoricalOrderFillResponse::clear_has_price() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HistoricalOrderFillResponse::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double HistoricalOrderFillResponse::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.Price)
  return price_;
}
inline void HistoricalOrderFillResponse::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.Price)
}

// optional sfixed64 DateTime = 9;
inline bool HistoricalOrderFillResponse::has_datetime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_datetime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HistoricalOrderFillResponse::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HistoricalOrderFillResponse::clear_datetime() {
  datetime_ = GOOGLE_LONGLONG(0);
  clear_has_datetime();
}
inline ::google::protobuf::int64 HistoricalOrderFillResponse::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.DateTime)
  return datetime_;
}
inline void HistoricalOrderFillResponse::set_datetime(::google::protobuf::int64 value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.DateTime)
}

// optional double Quantity = 10;
inline bool HistoricalOrderFillResponse::has_quantity() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_quantity() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HistoricalOrderFillResponse::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HistoricalOrderFillResponse::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline double HistoricalOrderFillResponse::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.Quantity)
  return quantity_;
}
inline void HistoricalOrderFillResponse::set_quantity(double value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.Quantity)
}

// optional string UniqueExecutionID = 11;
inline bool HistoricalOrderFillResponse::has_uniqueexecutionid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_uniqueexecutionid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HistoricalOrderFillResponse::clear_has_uniqueexecutionid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HistoricalOrderFillResponse::clear_uniqueexecutionid() {
  if (uniqueexecutionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uniqueexecutionid_->clear();
  }
  clear_has_uniqueexecutionid();
}
inline const ::std::string& HistoricalOrderFillResponse::uniqueexecutionid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.UniqueExecutionID)
  return *uniqueexecutionid_;
}
inline void HistoricalOrderFillResponse::set_uniqueexecutionid(const ::std::string& value) {
  set_has_uniqueexecutionid();
  if (uniqueexecutionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uniqueexecutionid_ = new ::std::string;
  }
  uniqueexecutionid_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.UniqueExecutionID)
}
inline void HistoricalOrderFillResponse::set_uniqueexecutionid(const char* value) {
  set_has_uniqueexecutionid();
  if (uniqueexecutionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uniqueexecutionid_ = new ::std::string;
  }
  uniqueexecutionid_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalOrderFillResponse.UniqueExecutionID)
}
inline void HistoricalOrderFillResponse::set_uniqueexecutionid(const char* value, size_t size) {
  set_has_uniqueexecutionid();
  if (uniqueexecutionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uniqueexecutionid_ = new ::std::string;
  }
  uniqueexecutionid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalOrderFillResponse.UniqueExecutionID)
}
inline ::std::string* HistoricalOrderFillResponse::mutable_uniqueexecutionid() {
  set_has_uniqueexecutionid();
  if (uniqueexecutionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uniqueexecutionid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalOrderFillResponse.UniqueExecutionID)
  return uniqueexecutionid_;
}
inline ::std::string* HistoricalOrderFillResponse::release_uniqueexecutionid() {
  clear_has_uniqueexecutionid();
  if (uniqueexecutionid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = uniqueexecutionid_;
    uniqueexecutionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HistoricalOrderFillResponse::set_allocated_uniqueexecutionid(::std::string* uniqueexecutionid) {
  if (uniqueexecutionid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uniqueexecutionid_;
  }
  if (uniqueexecutionid) {
    set_has_uniqueexecutionid();
    uniqueexecutionid_ = uniqueexecutionid;
  } else {
    clear_has_uniqueexecutionid();
    uniqueexecutionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalOrderFillResponse.UniqueExecutionID)
}

// optional string TradeAccount = 12;
inline bool HistoricalOrderFillResponse::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000800u;
}
inline void HistoricalOrderFillResponse::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void HistoricalOrderFillResponse::clear_tradeaccount() {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_->clear();
  }
  clear_has_tradeaccount();
}
inline const ::std::string& HistoricalOrderFillResponse::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.TradeAccount)
  return *tradeaccount_;
}
inline void HistoricalOrderFillResponse::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.TradeAccount)
}
inline void HistoricalOrderFillResponse::set_tradeaccount(const char* value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalOrderFillResponse.TradeAccount)
}
inline void HistoricalOrderFillResponse::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalOrderFillResponse.TradeAccount)
}
inline ::std::string* HistoricalOrderFillResponse::mutable_tradeaccount() {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalOrderFillResponse.TradeAccount)
  return tradeaccount_;
}
inline ::std::string* HistoricalOrderFillResponse::release_tradeaccount() {
  clear_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tradeaccount_;
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HistoricalOrderFillResponse::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tradeaccount_;
  }
  if (tradeaccount) {
    set_has_tradeaccount();
    tradeaccount_ = tradeaccount;
  } else {
    clear_has_tradeaccount();
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalOrderFillResponse.TradeAccount)
}

// optional .DTC_PB.OpenCloseTradeEnum OpenClose = 13;
inline bool HistoricalOrderFillResponse::has_openclose() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_openclose() {
  _has_bits_[0] |= 0x00001000u;
}
inline void HistoricalOrderFillResponse::clear_has_openclose() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void HistoricalOrderFillResponse::clear_openclose() {
  openclose_ = 0;
  clear_has_openclose();
}
inline ::DTC_PB::OpenCloseTradeEnum HistoricalOrderFillResponse::openclose() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.OpenClose)
  return static_cast< ::DTC_PB::OpenCloseTradeEnum >(openclose_);
}
inline void HistoricalOrderFillResponse::set_openclose(::DTC_PB::OpenCloseTradeEnum value) {
  assert(::DTC_PB::OpenCloseTradeEnum_IsValid(value));
  set_has_openclose();
  openclose_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.OpenClose)
}

// optional uint32 NoOrderFills = 14;
inline bool HistoricalOrderFillResponse::has_noorderfills() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void HistoricalOrderFillResponse::set_has_noorderfills() {
  _has_bits_[0] |= 0x00002000u;
}
inline void HistoricalOrderFillResponse::clear_has_noorderfills() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void HistoricalOrderFillResponse::clear_noorderfills() {
  noorderfills_ = 0u;
  clear_has_noorderfills();
}
inline ::google::protobuf::uint32 HistoricalOrderFillResponse::noorderfills() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalOrderFillResponse.NoOrderFills)
  return noorderfills_;
}
inline void HistoricalOrderFillResponse::set_noorderfills(::google::protobuf::uint32 value) {
  set_has_noorderfills();
  noorderfills_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalOrderFillResponse.NoOrderFills)
}

// -------------------------------------------------------------------

// PositionUpdate

// optional int32 RequestID = 1;
inline bool PositionUpdate::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PositionUpdate::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PositionUpdate::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PositionUpdate::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 PositionUpdate::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.RequestID)
  return requestid_;
}
inline void PositionUpdate::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.RequestID)
}

// optional int32 TotalNumberMessages = 2;
inline bool PositionUpdate::has_totalnumbermessages() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PositionUpdate::set_has_totalnumbermessages() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PositionUpdate::clear_has_totalnumbermessages() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PositionUpdate::clear_totalnumbermessages() {
  totalnumbermessages_ = 0;
  clear_has_totalnumbermessages();
}
inline ::google::protobuf::int32 PositionUpdate::totalnumbermessages() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.TotalNumberMessages)
  return totalnumbermessages_;
}
inline void PositionUpdate::set_totalnumbermessages(::google::protobuf::int32 value) {
  set_has_totalnumbermessages();
  totalnumbermessages_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.TotalNumberMessages)
}

// optional int32 MessageNumber = 3;
inline bool PositionUpdate::has_messagenumber() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PositionUpdate::set_has_messagenumber() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PositionUpdate::clear_has_messagenumber() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PositionUpdate::clear_messagenumber() {
  messagenumber_ = 0;
  clear_has_messagenumber();
}
inline ::google::protobuf::int32 PositionUpdate::messagenumber() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.MessageNumber)
  return messagenumber_;
}
inline void PositionUpdate::set_messagenumber(::google::protobuf::int32 value) {
  set_has_messagenumber();
  messagenumber_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.MessageNumber)
}

// optional string Symbol = 4;
inline bool PositionUpdate::has_symbol() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PositionUpdate::set_has_symbol() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PositionUpdate::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PositionUpdate::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& PositionUpdate::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.Symbol)
  return *symbol_;
}
inline void PositionUpdate::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.Symbol)
}
inline void PositionUpdate::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.PositionUpdate.Symbol)
}
inline void PositionUpdate::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.PositionUpdate.Symbol)
}
inline ::std::string* PositionUpdate::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.PositionUpdate.Symbol)
  return symbol_;
}
inline ::std::string* PositionUpdate::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PositionUpdate::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.PositionUpdate.Symbol)
}

// optional string Exchange = 5;
inline bool PositionUpdate::has_exchange() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PositionUpdate::set_has_exchange() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PositionUpdate::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PositionUpdate::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& PositionUpdate::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.Exchange)
  return *exchange_;
}
inline void PositionUpdate::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.Exchange)
}
inline void PositionUpdate::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.PositionUpdate.Exchange)
}
inline void PositionUpdate::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.PositionUpdate.Exchange)
}
inline ::std::string* PositionUpdate::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.PositionUpdate.Exchange)
  return exchange_;
}
inline ::std::string* PositionUpdate::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PositionUpdate::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.PositionUpdate.Exchange)
}

// optional double Quantity = 6;
inline bool PositionUpdate::has_quantity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PositionUpdate::set_has_quantity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PositionUpdate::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PositionUpdate::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline double PositionUpdate::quantity() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.Quantity)
  return quantity_;
}
inline void PositionUpdate::set_quantity(double value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.Quantity)
}

// optional double AveragePrice = 7;
inline bool PositionUpdate::has_averageprice() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PositionUpdate::set_has_averageprice() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PositionUpdate::clear_has_averageprice() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PositionUpdate::clear_averageprice() {
  averageprice_ = 0;
  clear_has_averageprice();
}
inline double PositionUpdate::averageprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.AveragePrice)
  return averageprice_;
}
inline void PositionUpdate::set_averageprice(double value) {
  set_has_averageprice();
  averageprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.AveragePrice)
}

// optional string PositionIdentifier = 8;
inline bool PositionUpdate::has_positionidentifier() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PositionUpdate::set_has_positionidentifier() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PositionUpdate::clear_has_positionidentifier() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PositionUpdate::clear_positionidentifier() {
  if (positionidentifier_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    positionidentifier_->clear();
  }
  clear_has_positionidentifier();
}
inline const ::std::string& PositionUpdate::positionidentifier() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.PositionIdentifier)
  return *positionidentifier_;
}
inline void PositionUpdate::set_positionidentifier(const ::std::string& value) {
  set_has_positionidentifier();
  if (positionidentifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    positionidentifier_ = new ::std::string;
  }
  positionidentifier_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.PositionIdentifier)
}
inline void PositionUpdate::set_positionidentifier(const char* value) {
  set_has_positionidentifier();
  if (positionidentifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    positionidentifier_ = new ::std::string;
  }
  positionidentifier_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.PositionUpdate.PositionIdentifier)
}
inline void PositionUpdate::set_positionidentifier(const char* value, size_t size) {
  set_has_positionidentifier();
  if (positionidentifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    positionidentifier_ = new ::std::string;
  }
  positionidentifier_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.PositionUpdate.PositionIdentifier)
}
inline ::std::string* PositionUpdate::mutable_positionidentifier() {
  set_has_positionidentifier();
  if (positionidentifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    positionidentifier_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.PositionUpdate.PositionIdentifier)
  return positionidentifier_;
}
inline ::std::string* PositionUpdate::release_positionidentifier() {
  clear_has_positionidentifier();
  if (positionidentifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = positionidentifier_;
    positionidentifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PositionUpdate::set_allocated_positionidentifier(::std::string* positionidentifier) {
  if (positionidentifier_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete positionidentifier_;
  }
  if (positionidentifier) {
    set_has_positionidentifier();
    positionidentifier_ = positionidentifier;
  } else {
    clear_has_positionidentifier();
    positionidentifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.PositionUpdate.PositionIdentifier)
}

// optional string TradeAccount = 9;
inline bool PositionUpdate::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PositionUpdate::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PositionUpdate::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PositionUpdate::clear_tradeaccount() {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_->clear();
  }
  clear_has_tradeaccount();
}
inline const ::std::string& PositionUpdate::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.TradeAccount)
  return *tradeaccount_;
}
inline void PositionUpdate::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.TradeAccount)
}
inline void PositionUpdate::set_tradeaccount(const char* value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.PositionUpdate.TradeAccount)
}
inline void PositionUpdate::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.PositionUpdate.TradeAccount)
}
inline ::std::string* PositionUpdate::mutable_tradeaccount() {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.PositionUpdate.TradeAccount)
  return tradeaccount_;
}
inline ::std::string* PositionUpdate::release_tradeaccount() {
  clear_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tradeaccount_;
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PositionUpdate::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tradeaccount_;
  }
  if (tradeaccount) {
    set_has_tradeaccount();
    tradeaccount_ = tradeaccount;
  } else {
    clear_has_tradeaccount();
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.PositionUpdate.TradeAccount)
}

// optional uint32 NoPositions = 10;
inline bool PositionUpdate::has_nopositions() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PositionUpdate::set_has_nopositions() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PositionUpdate::clear_has_nopositions() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PositionUpdate::clear_nopositions() {
  nopositions_ = 0u;
  clear_has_nopositions();
}
inline ::google::protobuf::uint32 PositionUpdate::nopositions() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.NoPositions)
  return nopositions_;
}
inline void PositionUpdate::set_nopositions(::google::protobuf::uint32 value) {
  set_has_nopositions();
  nopositions_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.NoPositions)
}

// optional uint32 Unsolicited = 11;
inline bool PositionUpdate::has_unsolicited() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PositionUpdate::set_has_unsolicited() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PositionUpdate::clear_has_unsolicited() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PositionUpdate::clear_unsolicited() {
  unsolicited_ = 0u;
  clear_has_unsolicited();
}
inline ::google::protobuf::uint32 PositionUpdate::unsolicited() const {
  // @@protoc_insertion_point(field_get:DTC_PB.PositionUpdate.Unsolicited)
  return unsolicited_;
}
inline void PositionUpdate::set_unsolicited(::google::protobuf::uint32 value) {
  set_has_unsolicited();
  unsolicited_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.PositionUpdate.Unsolicited)
}

// -------------------------------------------------------------------

// TradeAccountsRequest

// optional int32 RequestID = 1;
inline bool TradeAccountsRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TradeAccountsRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TradeAccountsRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TradeAccountsRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 TradeAccountsRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.TradeAccountsRequest.RequestID)
  return requestid_;
}
inline void TradeAccountsRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.TradeAccountsRequest.RequestID)
}

// -------------------------------------------------------------------

// TradeAccountResponse

// optional int32 TotalNumberMessages = 1;
inline bool TradeAccountResponse::has_totalnumbermessages() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TradeAccountResponse::set_has_totalnumbermessages() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TradeAccountResponse::clear_has_totalnumbermessages() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TradeAccountResponse::clear_totalnumbermessages() {
  totalnumbermessages_ = 0;
  clear_has_totalnumbermessages();
}
inline ::google::protobuf::int32 TradeAccountResponse::totalnumbermessages() const {
  // @@protoc_insertion_point(field_get:DTC_PB.TradeAccountResponse.TotalNumberMessages)
  return totalnumbermessages_;
}
inline void TradeAccountResponse::set_totalnumbermessages(::google::protobuf::int32 value) {
  set_has_totalnumbermessages();
  totalnumbermessages_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.TradeAccountResponse.TotalNumberMessages)
}

// optional int32 MessageNumber = 2;
inline bool TradeAccountResponse::has_messagenumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TradeAccountResponse::set_has_messagenumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TradeAccountResponse::clear_has_messagenumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TradeAccountResponse::clear_messagenumber() {
  messagenumber_ = 0;
  clear_has_messagenumber();
}
inline ::google::protobuf::int32 TradeAccountResponse::messagenumber() const {
  // @@protoc_insertion_point(field_get:DTC_PB.TradeAccountResponse.MessageNumber)
  return messagenumber_;
}
inline void TradeAccountResponse::set_messagenumber(::google::protobuf::int32 value) {
  set_has_messagenumber();
  messagenumber_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.TradeAccountResponse.MessageNumber)
}

// optional string TradeAccount = 3;
inline bool TradeAccountResponse::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TradeAccountResponse::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TradeAccountResponse::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TradeAccountResponse::clear_tradeaccount() {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_->clear();
  }
  clear_has_tradeaccount();
}
inline const ::std::string& TradeAccountResponse::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.TradeAccountResponse.TradeAccount)
  return *tradeaccount_;
}
inline void TradeAccountResponse::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.TradeAccountResponse.TradeAccount)
}
inline void TradeAccountResponse::set_tradeaccount(const char* value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.TradeAccountResponse.TradeAccount)
}
inline void TradeAccountResponse::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.TradeAccountResponse.TradeAccount)
}
inline ::std::string* TradeAccountResponse::mutable_tradeaccount() {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.TradeAccountResponse.TradeAccount)
  return tradeaccount_;
}
inline ::std::string* TradeAccountResponse::release_tradeaccount() {
  clear_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tradeaccount_;
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TradeAccountResponse::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tradeaccount_;
  }
  if (tradeaccount) {
    set_has_tradeaccount();
    tradeaccount_ = tradeaccount;
  } else {
    clear_has_tradeaccount();
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.TradeAccountResponse.TradeAccount)
}

// optional int32 RequestID = 4;
inline bool TradeAccountResponse::has_requestid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TradeAccountResponse::set_has_requestid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TradeAccountResponse::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TradeAccountResponse::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 TradeAccountResponse::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.TradeAccountResponse.RequestID)
  return requestid_;
}
inline void TradeAccountResponse::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.TradeAccountResponse.RequestID)
}

// -------------------------------------------------------------------

// ExchangeListRequest

// optional int32 RequestID = 1;
inline bool ExchangeListRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExchangeListRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExchangeListRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExchangeListRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 ExchangeListRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.ExchangeListRequest.RequestID)
  return requestid_;
}
inline void ExchangeListRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.ExchangeListRequest.RequestID)
}

// -------------------------------------------------------------------

// ExchangeListResponse

// optional int32 RequestID = 1;
inline bool ExchangeListResponse::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExchangeListResponse::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExchangeListResponse::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExchangeListResponse::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 ExchangeListResponse::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.ExchangeListResponse.RequestID)
  return requestid_;
}
inline void ExchangeListResponse::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.ExchangeListResponse.RequestID)
}

// optional string Exchange = 2;
inline bool ExchangeListResponse::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExchangeListResponse::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExchangeListResponse::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExchangeListResponse::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& ExchangeListResponse::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.ExchangeListResponse.Exchange)
  return *exchange_;
}
inline void ExchangeListResponse::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.ExchangeListResponse.Exchange)
}
inline void ExchangeListResponse::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.ExchangeListResponse.Exchange)
}
inline void ExchangeListResponse::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.ExchangeListResponse.Exchange)
}
inline ::std::string* ExchangeListResponse::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.ExchangeListResponse.Exchange)
  return exchange_;
}
inline ::std::string* ExchangeListResponse::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExchangeListResponse::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.ExchangeListResponse.Exchange)
}

// optional uint32 IsFinalMessage = 3;
inline bool ExchangeListResponse::has_isfinalmessage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExchangeListResponse::set_has_isfinalmessage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExchangeListResponse::clear_has_isfinalmessage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExchangeListResponse::clear_isfinalmessage() {
  isfinalmessage_ = 0u;
  clear_has_isfinalmessage();
}
inline ::google::protobuf::uint32 ExchangeListResponse::isfinalmessage() const {
  // @@protoc_insertion_point(field_get:DTC_PB.ExchangeListResponse.IsFinalMessage)
  return isfinalmessage_;
}
inline void ExchangeListResponse::set_isfinalmessage(::google::protobuf::uint32 value) {
  set_has_isfinalmessage();
  isfinalmessage_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.ExchangeListResponse.IsFinalMessage)
}

// optional string Description = 4;
inline bool ExchangeListResponse::has_description() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExchangeListResponse::set_has_description() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExchangeListResponse::clear_has_description() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExchangeListResponse::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& ExchangeListResponse::description() const {
  // @@protoc_insertion_point(field_get:DTC_PB.ExchangeListResponse.Description)
  return *description_;
}
inline void ExchangeListResponse::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.ExchangeListResponse.Description)
}
inline void ExchangeListResponse::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.ExchangeListResponse.Description)
}
inline void ExchangeListResponse::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.ExchangeListResponse.Description)
}
inline ::std::string* ExchangeListResponse::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.ExchangeListResponse.Description)
  return description_;
}
inline ::std::string* ExchangeListResponse::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExchangeListResponse::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.ExchangeListResponse.Description)
}

// -------------------------------------------------------------------

// SymbolsForExchangeRequest

// optional int32 RequestID = 1;
inline bool SymbolsForExchangeRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolsForExchangeRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolsForExchangeRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolsForExchangeRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 SymbolsForExchangeRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolsForExchangeRequest.RequestID)
  return requestid_;
}
inline void SymbolsForExchangeRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolsForExchangeRequest.RequestID)
}

// optional string Exchange = 2;
inline bool SymbolsForExchangeRequest::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolsForExchangeRequest::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolsForExchangeRequest::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolsForExchangeRequest::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& SymbolsForExchangeRequest::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolsForExchangeRequest.Exchange)
  return *exchange_;
}
inline void SymbolsForExchangeRequest::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolsForExchangeRequest.Exchange)
}
inline void SymbolsForExchangeRequest::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SymbolsForExchangeRequest.Exchange)
}
inline void SymbolsForExchangeRequest::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SymbolsForExchangeRequest.Exchange)
}
inline ::std::string* SymbolsForExchangeRequest::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SymbolsForExchangeRequest.Exchange)
  return exchange_;
}
inline ::std::string* SymbolsForExchangeRequest::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SymbolsForExchangeRequest::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SymbolsForExchangeRequest.Exchange)
}

// optional .DTC_PB.SecurityTypeEnum SecurityType = 3;
inline bool SymbolsForExchangeRequest::has_securitytype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolsForExchangeRequest::set_has_securitytype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolsForExchangeRequest::clear_has_securitytype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolsForExchangeRequest::clear_securitytype() {
  securitytype_ = 0;
  clear_has_securitytype();
}
inline ::DTC_PB::SecurityTypeEnum SymbolsForExchangeRequest::securitytype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolsForExchangeRequest.SecurityType)
  return static_cast< ::DTC_PB::SecurityTypeEnum >(securitytype_);
}
inline void SymbolsForExchangeRequest::set_securitytype(::DTC_PB::SecurityTypeEnum value) {
  assert(::DTC_PB::SecurityTypeEnum_IsValid(value));
  set_has_securitytype();
  securitytype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolsForExchangeRequest.SecurityType)
}

// -------------------------------------------------------------------

// UnderlyingSymbolsForExchangeRequest

// optional int32 RequestID = 1;
inline bool UnderlyingSymbolsForExchangeRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnderlyingSymbolsForExchangeRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnderlyingSymbolsForExchangeRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnderlyingSymbolsForExchangeRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 UnderlyingSymbolsForExchangeRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.UnderlyingSymbolsForExchangeRequest.RequestID)
  return requestid_;
}
inline void UnderlyingSymbolsForExchangeRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.UnderlyingSymbolsForExchangeRequest.RequestID)
}

// optional string Exchange = 2;
inline bool UnderlyingSymbolsForExchangeRequest::has_exchange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnderlyingSymbolsForExchangeRequest::set_has_exchange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnderlyingSymbolsForExchangeRequest::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnderlyingSymbolsForExchangeRequest::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& UnderlyingSymbolsForExchangeRequest::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.UnderlyingSymbolsForExchangeRequest.Exchange)
  return *exchange_;
}
inline void UnderlyingSymbolsForExchangeRequest::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.UnderlyingSymbolsForExchangeRequest.Exchange)
}
inline void UnderlyingSymbolsForExchangeRequest::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.UnderlyingSymbolsForExchangeRequest.Exchange)
}
inline void UnderlyingSymbolsForExchangeRequest::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.UnderlyingSymbolsForExchangeRequest.Exchange)
}
inline ::std::string* UnderlyingSymbolsForExchangeRequest::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.UnderlyingSymbolsForExchangeRequest.Exchange)
  return exchange_;
}
inline ::std::string* UnderlyingSymbolsForExchangeRequest::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UnderlyingSymbolsForExchangeRequest::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.UnderlyingSymbolsForExchangeRequest.Exchange)
}

// optional .DTC_PB.SecurityTypeEnum SecurityType = 3;
inline bool UnderlyingSymbolsForExchangeRequest::has_securitytype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnderlyingSymbolsForExchangeRequest::set_has_securitytype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnderlyingSymbolsForExchangeRequest::clear_has_securitytype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnderlyingSymbolsForExchangeRequest::clear_securitytype() {
  securitytype_ = 0;
  clear_has_securitytype();
}
inline ::DTC_PB::SecurityTypeEnum UnderlyingSymbolsForExchangeRequest::securitytype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.UnderlyingSymbolsForExchangeRequest.SecurityType)
  return static_cast< ::DTC_PB::SecurityTypeEnum >(securitytype_);
}
inline void UnderlyingSymbolsForExchangeRequest::set_securitytype(::DTC_PB::SecurityTypeEnum value) {
  assert(::DTC_PB::SecurityTypeEnum_IsValid(value));
  set_has_securitytype();
  securitytype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.UnderlyingSymbolsForExchangeRequest.SecurityType)
}

// -------------------------------------------------------------------

// SymbolsForUnderlyingRequest

// optional int32 RequestID = 1;
inline bool SymbolsForUnderlyingRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolsForUnderlyingRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolsForUnderlyingRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolsForUnderlyingRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 SymbolsForUnderlyingRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolsForUnderlyingRequest.RequestID)
  return requestid_;
}
inline void SymbolsForUnderlyingRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolsForUnderlyingRequest.RequestID)
}

// optional string UnderlyingSymbol = 2;
inline bool SymbolsForUnderlyingRequest::has_underlyingsymbol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolsForUnderlyingRequest::set_has_underlyingsymbol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolsForUnderlyingRequest::clear_has_underlyingsymbol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolsForUnderlyingRequest::clear_underlyingsymbol() {
  if (underlyingsymbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlyingsymbol_->clear();
  }
  clear_has_underlyingsymbol();
}
inline const ::std::string& SymbolsForUnderlyingRequest::underlyingsymbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolsForUnderlyingRequest.UnderlyingSymbol)
  return *underlyingsymbol_;
}
inline void SymbolsForUnderlyingRequest::set_underlyingsymbol(const ::std::string& value) {
  set_has_underlyingsymbol();
  if (underlyingsymbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlyingsymbol_ = new ::std::string;
  }
  underlyingsymbol_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolsForUnderlyingRequest.UnderlyingSymbol)
}
inline void SymbolsForUnderlyingRequest::set_underlyingsymbol(const char* value) {
  set_has_underlyingsymbol();
  if (underlyingsymbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlyingsymbol_ = new ::std::string;
  }
  underlyingsymbol_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SymbolsForUnderlyingRequest.UnderlyingSymbol)
}
inline void SymbolsForUnderlyingRequest::set_underlyingsymbol(const char* value, size_t size) {
  set_has_underlyingsymbol();
  if (underlyingsymbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlyingsymbol_ = new ::std::string;
  }
  underlyingsymbol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SymbolsForUnderlyingRequest.UnderlyingSymbol)
}
inline ::std::string* SymbolsForUnderlyingRequest::mutable_underlyingsymbol() {
  set_has_underlyingsymbol();
  if (underlyingsymbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlyingsymbol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SymbolsForUnderlyingRequest.UnderlyingSymbol)
  return underlyingsymbol_;
}
inline ::std::string* SymbolsForUnderlyingRequest::release_underlyingsymbol() {
  clear_has_underlyingsymbol();
  if (underlyingsymbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = underlyingsymbol_;
    underlyingsymbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SymbolsForUnderlyingRequest::set_allocated_underlyingsymbol(::std::string* underlyingsymbol) {
  if (underlyingsymbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete underlyingsymbol_;
  }
  if (underlyingsymbol) {
    set_has_underlyingsymbol();
    underlyingsymbol_ = underlyingsymbol;
  } else {
    clear_has_underlyingsymbol();
    underlyingsymbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SymbolsForUnderlyingRequest.UnderlyingSymbol)
}

// optional string Exchange = 3;
inline bool SymbolsForUnderlyingRequest::has_exchange() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolsForUnderlyingRequest::set_has_exchange() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolsForUnderlyingRequest::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolsForUnderlyingRequest::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& SymbolsForUnderlyingRequest::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolsForUnderlyingRequest.Exchange)
  return *exchange_;
}
inline void SymbolsForUnderlyingRequest::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolsForUnderlyingRequest.Exchange)
}
inline void SymbolsForUnderlyingRequest::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SymbolsForUnderlyingRequest.Exchange)
}
inline void SymbolsForUnderlyingRequest::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SymbolsForUnderlyingRequest.Exchange)
}
inline ::std::string* SymbolsForUnderlyingRequest::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SymbolsForUnderlyingRequest.Exchange)
  return exchange_;
}
inline ::std::string* SymbolsForUnderlyingRequest::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SymbolsForUnderlyingRequest::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SymbolsForUnderlyingRequest.Exchange)
}

// optional .DTC_PB.SecurityTypeEnum SecurityType = 4;
inline bool SymbolsForUnderlyingRequest::has_securitytype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SymbolsForUnderlyingRequest::set_has_securitytype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SymbolsForUnderlyingRequest::clear_has_securitytype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SymbolsForUnderlyingRequest::clear_securitytype() {
  securitytype_ = 0;
  clear_has_securitytype();
}
inline ::DTC_PB::SecurityTypeEnum SymbolsForUnderlyingRequest::securitytype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolsForUnderlyingRequest.SecurityType)
  return static_cast< ::DTC_PB::SecurityTypeEnum >(securitytype_);
}
inline void SymbolsForUnderlyingRequest::set_securitytype(::DTC_PB::SecurityTypeEnum value) {
  assert(::DTC_PB::SecurityTypeEnum_IsValid(value));
  set_has_securitytype();
  securitytype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolsForUnderlyingRequest.SecurityType)
}

// -------------------------------------------------------------------

// SymbolSearchRequest

// optional int32 RequestID = 1;
inline bool SymbolSearchRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolSearchRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolSearchRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolSearchRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 SymbolSearchRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolSearchRequest.RequestID)
  return requestid_;
}
inline void SymbolSearchRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolSearchRequest.RequestID)
}

// optional string SearchText = 2;
inline bool SymbolSearchRequest::has_searchtext() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolSearchRequest::set_has_searchtext() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolSearchRequest::clear_has_searchtext() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolSearchRequest::clear_searchtext() {
  if (searchtext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    searchtext_->clear();
  }
  clear_has_searchtext();
}
inline const ::std::string& SymbolSearchRequest::searchtext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolSearchRequest.SearchText)
  return *searchtext_;
}
inline void SymbolSearchRequest::set_searchtext(const ::std::string& value) {
  set_has_searchtext();
  if (searchtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    searchtext_ = new ::std::string;
  }
  searchtext_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolSearchRequest.SearchText)
}
inline void SymbolSearchRequest::set_searchtext(const char* value) {
  set_has_searchtext();
  if (searchtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    searchtext_ = new ::std::string;
  }
  searchtext_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SymbolSearchRequest.SearchText)
}
inline void SymbolSearchRequest::set_searchtext(const char* value, size_t size) {
  set_has_searchtext();
  if (searchtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    searchtext_ = new ::std::string;
  }
  searchtext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SymbolSearchRequest.SearchText)
}
inline ::std::string* SymbolSearchRequest::mutable_searchtext() {
  set_has_searchtext();
  if (searchtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    searchtext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SymbolSearchRequest.SearchText)
  return searchtext_;
}
inline ::std::string* SymbolSearchRequest::release_searchtext() {
  clear_has_searchtext();
  if (searchtext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = searchtext_;
    searchtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SymbolSearchRequest::set_allocated_searchtext(::std::string* searchtext) {
  if (searchtext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete searchtext_;
  }
  if (searchtext) {
    set_has_searchtext();
    searchtext_ = searchtext;
  } else {
    clear_has_searchtext();
    searchtext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SymbolSearchRequest.SearchText)
}

// optional string Exchange = 3;
inline bool SymbolSearchRequest::has_exchange() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolSearchRequest::set_has_exchange() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolSearchRequest::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolSearchRequest::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& SymbolSearchRequest::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolSearchRequest.Exchange)
  return *exchange_;
}
inline void SymbolSearchRequest::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolSearchRequest.Exchange)
}
inline void SymbolSearchRequest::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SymbolSearchRequest.Exchange)
}
inline void SymbolSearchRequest::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SymbolSearchRequest.Exchange)
}
inline ::std::string* SymbolSearchRequest::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SymbolSearchRequest.Exchange)
  return exchange_;
}
inline ::std::string* SymbolSearchRequest::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SymbolSearchRequest::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SymbolSearchRequest.Exchange)
}

// optional .DTC_PB.SecurityTypeEnum SecurityType = 4;
inline bool SymbolSearchRequest::has_securitytype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SymbolSearchRequest::set_has_securitytype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SymbolSearchRequest::clear_has_securitytype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SymbolSearchRequest::clear_securitytype() {
  securitytype_ = 0;
  clear_has_securitytype();
}
inline ::DTC_PB::SecurityTypeEnum SymbolSearchRequest::securitytype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolSearchRequest.SecurityType)
  return static_cast< ::DTC_PB::SecurityTypeEnum >(securitytype_);
}
inline void SymbolSearchRequest::set_securitytype(::DTC_PB::SecurityTypeEnum value) {
  assert(::DTC_PB::SecurityTypeEnum_IsValid(value));
  set_has_securitytype();
  securitytype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolSearchRequest.SecurityType)
}

// optional .DTC_PB.SearchTypeEnum SearchType = 5;
inline bool SymbolSearchRequest::has_searchtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SymbolSearchRequest::set_has_searchtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SymbolSearchRequest::clear_has_searchtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SymbolSearchRequest::clear_searchtype() {
  searchtype_ = 0;
  clear_has_searchtype();
}
inline ::DTC_PB::SearchTypeEnum SymbolSearchRequest::searchtype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SymbolSearchRequest.SearchType)
  return static_cast< ::DTC_PB::SearchTypeEnum >(searchtype_);
}
inline void SymbolSearchRequest::set_searchtype(::DTC_PB::SearchTypeEnum value) {
  assert(::DTC_PB::SearchTypeEnum_IsValid(value));
  set_has_searchtype();
  searchtype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SymbolSearchRequest.SearchType)
}

// -------------------------------------------------------------------

// SecurityDefinitionForSymbolRequest

// optional int32 RequestID = 1;
inline bool SecurityDefinitionForSymbolRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecurityDefinitionForSymbolRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecurityDefinitionForSymbolRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecurityDefinitionForSymbolRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 SecurityDefinitionForSymbolRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionForSymbolRequest.RequestID)
  return requestid_;
}
inline void SecurityDefinitionForSymbolRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionForSymbolRequest.RequestID)
}

// optional string Symbol = 2;
inline bool SecurityDefinitionForSymbolRequest::has_symbol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecurityDefinitionForSymbolRequest::set_has_symbol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecurityDefinitionForSymbolRequest::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecurityDefinitionForSymbolRequest::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& SecurityDefinitionForSymbolRequest::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionForSymbolRequest.Symbol)
  return *symbol_;
}
inline void SecurityDefinitionForSymbolRequest::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionForSymbolRequest.Symbol)
}
inline void SecurityDefinitionForSymbolRequest::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SecurityDefinitionForSymbolRequest.Symbol)
}
inline void SecurityDefinitionForSymbolRequest::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SecurityDefinitionForSymbolRequest.Symbol)
}
inline ::std::string* SecurityDefinitionForSymbolRequest::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SecurityDefinitionForSymbolRequest.Symbol)
  return symbol_;
}
inline ::std::string* SecurityDefinitionForSymbolRequest::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SecurityDefinitionForSymbolRequest::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SecurityDefinitionForSymbolRequest.Symbol)
}

// optional string Exchange = 3;
inline bool SecurityDefinitionForSymbolRequest::has_exchange() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecurityDefinitionForSymbolRequest::set_has_exchange() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecurityDefinitionForSymbolRequest::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecurityDefinitionForSymbolRequest::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& SecurityDefinitionForSymbolRequest::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionForSymbolRequest.Exchange)
  return *exchange_;
}
inline void SecurityDefinitionForSymbolRequest::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionForSymbolRequest.Exchange)
}
inline void SecurityDefinitionForSymbolRequest::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SecurityDefinitionForSymbolRequest.Exchange)
}
inline void SecurityDefinitionForSymbolRequest::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SecurityDefinitionForSymbolRequest.Exchange)
}
inline ::std::string* SecurityDefinitionForSymbolRequest::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SecurityDefinitionForSymbolRequest.Exchange)
  return exchange_;
}
inline ::std::string* SecurityDefinitionForSymbolRequest::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SecurityDefinitionForSymbolRequest::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SecurityDefinitionForSymbolRequest.Exchange)
}

// -------------------------------------------------------------------

// SecurityDefinitionResponse

// optional int32 RequestID = 1;
inline bool SecurityDefinitionResponse::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecurityDefinitionResponse::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecurityDefinitionResponse::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecurityDefinitionResponse::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 SecurityDefinitionResponse::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.RequestID)
  return requestid_;
}
inline void SecurityDefinitionResponse::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.RequestID)
}

// optional string Symbol = 2;
inline bool SecurityDefinitionResponse::has_symbol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecurityDefinitionResponse::set_has_symbol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecurityDefinitionResponse::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecurityDefinitionResponse::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& SecurityDefinitionResponse::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.Symbol)
  return *symbol_;
}
inline void SecurityDefinitionResponse::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.Symbol)
}
inline void SecurityDefinitionResponse::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SecurityDefinitionResponse.Symbol)
}
inline void SecurityDefinitionResponse::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SecurityDefinitionResponse.Symbol)
}
inline ::std::string* SecurityDefinitionResponse::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SecurityDefinitionResponse.Symbol)
  return symbol_;
}
inline ::std::string* SecurityDefinitionResponse::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SecurityDefinitionResponse::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SecurityDefinitionResponse.Symbol)
}

// optional string Exchange = 3;
inline bool SecurityDefinitionResponse::has_exchange() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecurityDefinitionResponse::set_has_exchange() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecurityDefinitionResponse::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecurityDefinitionResponse::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& SecurityDefinitionResponse::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.Exchange)
  return *exchange_;
}
inline void SecurityDefinitionResponse::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.Exchange)
}
inline void SecurityDefinitionResponse::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SecurityDefinitionResponse.Exchange)
}
inline void SecurityDefinitionResponse::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SecurityDefinitionResponse.Exchange)
}
inline ::std::string* SecurityDefinitionResponse::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SecurityDefinitionResponse.Exchange)
  return exchange_;
}
inline ::std::string* SecurityDefinitionResponse::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SecurityDefinitionResponse::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SecurityDefinitionResponse.Exchange)
}

// optional .DTC_PB.SecurityTypeEnum SecurityType = 4;
inline bool SecurityDefinitionResponse::has_securitytype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SecurityDefinitionResponse::set_has_securitytype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SecurityDefinitionResponse::clear_has_securitytype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SecurityDefinitionResponse::clear_securitytype() {
  securitytype_ = 0;
  clear_has_securitytype();
}
inline ::DTC_PB::SecurityTypeEnum SecurityDefinitionResponse::securitytype() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.SecurityType)
  return static_cast< ::DTC_PB::SecurityTypeEnum >(securitytype_);
}
inline void SecurityDefinitionResponse::set_securitytype(::DTC_PB::SecurityTypeEnum value) {
  assert(::DTC_PB::SecurityTypeEnum_IsValid(value));
  set_has_securitytype();
  securitytype_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.SecurityType)
}

// optional string Description = 5;
inline bool SecurityDefinitionResponse::has_description() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SecurityDefinitionResponse::set_has_description() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SecurityDefinitionResponse::clear_has_description() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SecurityDefinitionResponse::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& SecurityDefinitionResponse::description() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.Description)
  return *description_;
}
inline void SecurityDefinitionResponse::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.Description)
}
inline void SecurityDefinitionResponse::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SecurityDefinitionResponse.Description)
}
inline void SecurityDefinitionResponse::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SecurityDefinitionResponse.Description)
}
inline ::std::string* SecurityDefinitionResponse::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SecurityDefinitionResponse.Description)
  return description_;
}
inline ::std::string* SecurityDefinitionResponse::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SecurityDefinitionResponse::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SecurityDefinitionResponse.Description)
}

// optional float MinPriceIncrement = 6;
inline bool SecurityDefinitionResponse::has_minpriceincrement() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SecurityDefinitionResponse::set_has_minpriceincrement() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SecurityDefinitionResponse::clear_has_minpriceincrement() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SecurityDefinitionResponse::clear_minpriceincrement() {
  minpriceincrement_ = 0;
  clear_has_minpriceincrement();
}
inline float SecurityDefinitionResponse::minpriceincrement() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.MinPriceIncrement)
  return minpriceincrement_;
}
inline void SecurityDefinitionResponse::set_minpriceincrement(float value) {
  set_has_minpriceincrement();
  minpriceincrement_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.MinPriceIncrement)
}

// optional .DTC_PB.PriceDisplayFormatEnum PriceDisplayFormat = 7;
inline bool SecurityDefinitionResponse::has_pricedisplayformat() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SecurityDefinitionResponse::set_has_pricedisplayformat() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SecurityDefinitionResponse::clear_has_pricedisplayformat() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SecurityDefinitionResponse::clear_pricedisplayformat() {
  pricedisplayformat_ = -1;
  clear_has_pricedisplayformat();
}
inline ::DTC_PB::PriceDisplayFormatEnum SecurityDefinitionResponse::pricedisplayformat() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.PriceDisplayFormat)
  return static_cast< ::DTC_PB::PriceDisplayFormatEnum >(pricedisplayformat_);
}
inline void SecurityDefinitionResponse::set_pricedisplayformat(::DTC_PB::PriceDisplayFormatEnum value) {
  assert(::DTC_PB::PriceDisplayFormatEnum_IsValid(value));
  set_has_pricedisplayformat();
  pricedisplayformat_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.PriceDisplayFormat)
}

// optional float CurrencyValuePerIncrement = 8;
inline bool SecurityDefinitionResponse::has_currencyvalueperincrement() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SecurityDefinitionResponse::set_has_currencyvalueperincrement() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SecurityDefinitionResponse::clear_has_currencyvalueperincrement() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SecurityDefinitionResponse::clear_currencyvalueperincrement() {
  currencyvalueperincrement_ = 0;
  clear_has_currencyvalueperincrement();
}
inline float SecurityDefinitionResponse::currencyvalueperincrement() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.CurrencyValuePerIncrement)
  return currencyvalueperincrement_;
}
inline void SecurityDefinitionResponse::set_currencyvalueperincrement(float value) {
  set_has_currencyvalueperincrement();
  currencyvalueperincrement_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.CurrencyValuePerIncrement)
}

// optional uint32 IsFinalMessage = 9;
inline bool SecurityDefinitionResponse::has_isfinalmessage() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SecurityDefinitionResponse::set_has_isfinalmessage() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SecurityDefinitionResponse::clear_has_isfinalmessage() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SecurityDefinitionResponse::clear_isfinalmessage() {
  isfinalmessage_ = 0u;
  clear_has_isfinalmessage();
}
inline ::google::protobuf::uint32 SecurityDefinitionResponse::isfinalmessage() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.IsFinalMessage)
  return isfinalmessage_;
}
inline void SecurityDefinitionResponse::set_isfinalmessage(::google::protobuf::uint32 value) {
  set_has_isfinalmessage();
  isfinalmessage_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.IsFinalMessage)
}

// optional float FloatToIntPriceMultiplier = 10;
inline bool SecurityDefinitionResponse::has_floattointpricemultiplier() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SecurityDefinitionResponse::set_has_floattointpricemultiplier() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SecurityDefinitionResponse::clear_has_floattointpricemultiplier() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SecurityDefinitionResponse::clear_floattointpricemultiplier() {
  floattointpricemultiplier_ = 0;
  clear_has_floattointpricemultiplier();
}
inline float SecurityDefinitionResponse::floattointpricemultiplier() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.FloatToIntPriceMultiplier)
  return floattointpricemultiplier_;
}
inline void SecurityDefinitionResponse::set_floattointpricemultiplier(float value) {
  set_has_floattointpricemultiplier();
  floattointpricemultiplier_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.FloatToIntPriceMultiplier)
}

// optional float IntToFloatPriceDivisor = 11;
inline bool SecurityDefinitionResponse::has_inttofloatpricedivisor() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SecurityDefinitionResponse::set_has_inttofloatpricedivisor() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SecurityDefinitionResponse::clear_has_inttofloatpricedivisor() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SecurityDefinitionResponse::clear_inttofloatpricedivisor() {
  inttofloatpricedivisor_ = 0;
  clear_has_inttofloatpricedivisor();
}
inline float SecurityDefinitionResponse::inttofloatpricedivisor() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.IntToFloatPriceDivisor)
  return inttofloatpricedivisor_;
}
inline void SecurityDefinitionResponse::set_inttofloatpricedivisor(float value) {
  set_has_inttofloatpricedivisor();
  inttofloatpricedivisor_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.IntToFloatPriceDivisor)
}

// optional string UnderlyingSymbol = 12;
inline bool SecurityDefinitionResponse::has_underlyingsymbol() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SecurityDefinitionResponse::set_has_underlyingsymbol() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SecurityDefinitionResponse::clear_has_underlyingsymbol() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SecurityDefinitionResponse::clear_underlyingsymbol() {
  if (underlyingsymbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlyingsymbol_->clear();
  }
  clear_has_underlyingsymbol();
}
inline const ::std::string& SecurityDefinitionResponse::underlyingsymbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.UnderlyingSymbol)
  return *underlyingsymbol_;
}
inline void SecurityDefinitionResponse::set_underlyingsymbol(const ::std::string& value) {
  set_has_underlyingsymbol();
  if (underlyingsymbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlyingsymbol_ = new ::std::string;
  }
  underlyingsymbol_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.UnderlyingSymbol)
}
inline void SecurityDefinitionResponse::set_underlyingsymbol(const char* value) {
  set_has_underlyingsymbol();
  if (underlyingsymbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlyingsymbol_ = new ::std::string;
  }
  underlyingsymbol_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SecurityDefinitionResponse.UnderlyingSymbol)
}
inline void SecurityDefinitionResponse::set_underlyingsymbol(const char* value, size_t size) {
  set_has_underlyingsymbol();
  if (underlyingsymbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlyingsymbol_ = new ::std::string;
  }
  underlyingsymbol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SecurityDefinitionResponse.UnderlyingSymbol)
}
inline ::std::string* SecurityDefinitionResponse::mutable_underlyingsymbol() {
  set_has_underlyingsymbol();
  if (underlyingsymbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    underlyingsymbol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SecurityDefinitionResponse.UnderlyingSymbol)
  return underlyingsymbol_;
}
inline ::std::string* SecurityDefinitionResponse::release_underlyingsymbol() {
  clear_has_underlyingsymbol();
  if (underlyingsymbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = underlyingsymbol_;
    underlyingsymbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SecurityDefinitionResponse::set_allocated_underlyingsymbol(::std::string* underlyingsymbol) {
  if (underlyingsymbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete underlyingsymbol_;
  }
  if (underlyingsymbol) {
    set_has_underlyingsymbol();
    underlyingsymbol_ = underlyingsymbol;
  } else {
    clear_has_underlyingsymbol();
    underlyingsymbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SecurityDefinitionResponse.UnderlyingSymbol)
}

// optional uint32 UpdatesBidAskOnly = 13;
inline bool SecurityDefinitionResponse::has_updatesbidaskonly() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_updatesbidaskonly() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SecurityDefinitionResponse::clear_has_updatesbidaskonly() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SecurityDefinitionResponse::clear_updatesbidaskonly() {
  updatesbidaskonly_ = 0u;
  clear_has_updatesbidaskonly();
}
inline ::google::protobuf::uint32 SecurityDefinitionResponse::updatesbidaskonly() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.UpdatesBidAskOnly)
  return updatesbidaskonly_;
}
inline void SecurityDefinitionResponse::set_updatesbidaskonly(::google::protobuf::uint32 value) {
  set_has_updatesbidaskonly();
  updatesbidaskonly_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.UpdatesBidAskOnly)
}

// optional float StrikePrice = 14;
inline bool SecurityDefinitionResponse::has_strikeprice() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_strikeprice() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SecurityDefinitionResponse::clear_has_strikeprice() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SecurityDefinitionResponse::clear_strikeprice() {
  strikeprice_ = 0;
  clear_has_strikeprice();
}
inline float SecurityDefinitionResponse::strikeprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.StrikePrice)
  return strikeprice_;
}
inline void SecurityDefinitionResponse::set_strikeprice(float value) {
  set_has_strikeprice();
  strikeprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.StrikePrice)
}

// optional .DTC_PB.PutCallEnum PutOrCall = 15;
inline bool SecurityDefinitionResponse::has_putorcall() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_putorcall() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SecurityDefinitionResponse::clear_has_putorcall() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SecurityDefinitionResponse::clear_putorcall() {
  putorcall_ = 0;
  clear_has_putorcall();
}
inline ::DTC_PB::PutCallEnum SecurityDefinitionResponse::putorcall() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.PutOrCall)
  return static_cast< ::DTC_PB::PutCallEnum >(putorcall_);
}
inline void SecurityDefinitionResponse::set_putorcall(::DTC_PB::PutCallEnum value) {
  assert(::DTC_PB::PutCallEnum_IsValid(value));
  set_has_putorcall();
  putorcall_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.PutOrCall)
}

// optional uint32 ShortInterest = 16;
inline bool SecurityDefinitionResponse::has_shortinterest() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_shortinterest() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SecurityDefinitionResponse::clear_has_shortinterest() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SecurityDefinitionResponse::clear_shortinterest() {
  shortinterest_ = 0u;
  clear_has_shortinterest();
}
inline ::google::protobuf::uint32 SecurityDefinitionResponse::shortinterest() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.ShortInterest)
  return shortinterest_;
}
inline void SecurityDefinitionResponse::set_shortinterest(::google::protobuf::uint32 value) {
  set_has_shortinterest();
  shortinterest_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.ShortInterest)
}

// optional sfixed32 SecurityExpirationDate = 17;
inline bool SecurityDefinitionResponse::has_securityexpirationdate() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_securityexpirationdate() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SecurityDefinitionResponse::clear_has_securityexpirationdate() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SecurityDefinitionResponse::clear_securityexpirationdate() {
  securityexpirationdate_ = 0;
  clear_has_securityexpirationdate();
}
inline ::google::protobuf::int32 SecurityDefinitionResponse::securityexpirationdate() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.SecurityExpirationDate)
  return securityexpirationdate_;
}
inline void SecurityDefinitionResponse::set_securityexpirationdate(::google::protobuf::int32 value) {
  set_has_securityexpirationdate();
  securityexpirationdate_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.SecurityExpirationDate)
}

// optional float BuyRolloverInterest = 18;
inline bool SecurityDefinitionResponse::has_buyrolloverinterest() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_buyrolloverinterest() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SecurityDefinitionResponse::clear_has_buyrolloverinterest() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SecurityDefinitionResponse::clear_buyrolloverinterest() {
  buyrolloverinterest_ = 0;
  clear_has_buyrolloverinterest();
}
inline float SecurityDefinitionResponse::buyrolloverinterest() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.BuyRolloverInterest)
  return buyrolloverinterest_;
}
inline void SecurityDefinitionResponse::set_buyrolloverinterest(float value) {
  set_has_buyrolloverinterest();
  buyrolloverinterest_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.BuyRolloverInterest)
}

// optional float SellRolloverInterest = 19;
inline bool SecurityDefinitionResponse::has_sellrolloverinterest() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_sellrolloverinterest() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SecurityDefinitionResponse::clear_has_sellrolloverinterest() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SecurityDefinitionResponse::clear_sellrolloverinterest() {
  sellrolloverinterest_ = 0;
  clear_has_sellrolloverinterest();
}
inline float SecurityDefinitionResponse::sellrolloverinterest() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.SellRolloverInterest)
  return sellrolloverinterest_;
}
inline void SecurityDefinitionResponse::set_sellrolloverinterest(float value) {
  set_has_sellrolloverinterest();
  sellrolloverinterest_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.SellRolloverInterest)
}

// optional float EarningsPerShare = 20;
inline bool SecurityDefinitionResponse::has_earningspershare() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_earningspershare() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SecurityDefinitionResponse::clear_has_earningspershare() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SecurityDefinitionResponse::clear_earningspershare() {
  earningspershare_ = 0;
  clear_has_earningspershare();
}
inline float SecurityDefinitionResponse::earningspershare() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.EarningsPerShare)
  return earningspershare_;
}
inline void SecurityDefinitionResponse::set_earningspershare(float value) {
  set_has_earningspershare();
  earningspershare_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.EarningsPerShare)
}

// optional uint32 SharesOutstanding = 21;
inline bool SecurityDefinitionResponse::has_sharesoutstanding() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_sharesoutstanding() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SecurityDefinitionResponse::clear_has_sharesoutstanding() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SecurityDefinitionResponse::clear_sharesoutstanding() {
  sharesoutstanding_ = 0u;
  clear_has_sharesoutstanding();
}
inline ::google::protobuf::uint32 SecurityDefinitionResponse::sharesoutstanding() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.SharesOutstanding)
  return sharesoutstanding_;
}
inline void SecurityDefinitionResponse::set_sharesoutstanding(::google::protobuf::uint32 value) {
  set_has_sharesoutstanding();
  sharesoutstanding_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.SharesOutstanding)
}

// optional float IntToFloatQuantityDivisor = 22;
inline bool SecurityDefinitionResponse::has_inttofloatquantitydivisor() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SecurityDefinitionResponse::set_has_inttofloatquantitydivisor() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SecurityDefinitionResponse::clear_has_inttofloatquantitydivisor() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SecurityDefinitionResponse::clear_inttofloatquantitydivisor() {
  inttofloatquantitydivisor_ = 0;
  clear_has_inttofloatquantitydivisor();
}
inline float SecurityDefinitionResponse::inttofloatquantitydivisor() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionResponse.IntToFloatQuantityDivisor)
  return inttofloatquantitydivisor_;
}
inline void SecurityDefinitionResponse::set_inttofloatquantitydivisor(float value) {
  set_has_inttofloatquantitydivisor();
  inttofloatquantitydivisor_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionResponse.IntToFloatQuantityDivisor)
}

// -------------------------------------------------------------------

// SecurityDefinitionReject

// optional int32 RequestID = 1;
inline bool SecurityDefinitionReject::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecurityDefinitionReject::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecurityDefinitionReject::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecurityDefinitionReject::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 SecurityDefinitionReject::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionReject.RequestID)
  return requestid_;
}
inline void SecurityDefinitionReject::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionReject.RequestID)
}

// optional string RejectText = 2;
inline bool SecurityDefinitionReject::has_rejecttext() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecurityDefinitionReject::set_has_rejecttext() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecurityDefinitionReject::clear_has_rejecttext() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecurityDefinitionReject::clear_rejecttext() {
  if (rejecttext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_->clear();
  }
  clear_has_rejecttext();
}
inline const ::std::string& SecurityDefinitionReject::rejecttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.SecurityDefinitionReject.RejectText)
  return *rejecttext_;
}
inline void SecurityDefinitionReject::set_rejecttext(const ::std::string& value) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.SecurityDefinitionReject.RejectText)
}
inline void SecurityDefinitionReject::set_rejecttext(const char* value) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.SecurityDefinitionReject.RejectText)
}
inline void SecurityDefinitionReject::set_rejecttext(const char* value, size_t size) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.SecurityDefinitionReject.RejectText)
}
inline ::std::string* SecurityDefinitionReject::mutable_rejecttext() {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.SecurityDefinitionReject.RejectText)
  return rejecttext_;
}
inline ::std::string* SecurityDefinitionReject::release_rejecttext() {
  clear_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rejecttext_;
    rejecttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SecurityDefinitionReject::set_allocated_rejecttext(::std::string* rejecttext) {
  if (rejecttext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rejecttext_;
  }
  if (rejecttext) {
    set_has_rejecttext();
    rejecttext_ = rejecttext;
  } else {
    clear_has_rejecttext();
    rejecttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.SecurityDefinitionReject.RejectText)
}

// -------------------------------------------------------------------

// AccountBalanceRequest

// optional int32 RequestID = 1;
inline bool AccountBalanceRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountBalanceRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountBalanceRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountBalanceRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 AccountBalanceRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceRequest.RequestID)
  return requestid_;
}
inline void AccountBalanceRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceRequest.RequestID)
}

// optional string TradeAccount = 2;
inline bool AccountBalanceRequest::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountBalanceRequest::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountBalanceRequest::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountBalanceRequest::clear_tradeaccount() {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_->clear();
  }
  clear_has_tradeaccount();
}
inline const ::std::string& AccountBalanceRequest::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceRequest.TradeAccount)
  return *tradeaccount_;
}
inline void AccountBalanceRequest::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceRequest.TradeAccount)
}
inline void AccountBalanceRequest::set_tradeaccount(const char* value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.AccountBalanceRequest.TradeAccount)
}
inline void AccountBalanceRequest::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.AccountBalanceRequest.TradeAccount)
}
inline ::std::string* AccountBalanceRequest::mutable_tradeaccount() {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.AccountBalanceRequest.TradeAccount)
  return tradeaccount_;
}
inline ::std::string* AccountBalanceRequest::release_tradeaccount() {
  clear_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tradeaccount_;
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AccountBalanceRequest::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tradeaccount_;
  }
  if (tradeaccount) {
    set_has_tradeaccount();
    tradeaccount_ = tradeaccount;
  } else {
    clear_has_tradeaccount();
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.AccountBalanceRequest.TradeAccount)
}

// -------------------------------------------------------------------

// AccountBalanceReject

// optional int32 RequestID = 1;
inline bool AccountBalanceReject::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountBalanceReject::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountBalanceReject::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountBalanceReject::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 AccountBalanceReject::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceReject.RequestID)
  return requestid_;
}
inline void AccountBalanceReject::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceReject.RequestID)
}

// optional string RejectText = 2;
inline bool AccountBalanceReject::has_rejecttext() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountBalanceReject::set_has_rejecttext() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountBalanceReject::clear_has_rejecttext() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountBalanceReject::clear_rejecttext() {
  if (rejecttext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_->clear();
  }
  clear_has_rejecttext();
}
inline const ::std::string& AccountBalanceReject::rejecttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceReject.RejectText)
  return *rejecttext_;
}
inline void AccountBalanceReject::set_rejecttext(const ::std::string& value) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceReject.RejectText)
}
inline void AccountBalanceReject::set_rejecttext(const char* value) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.AccountBalanceReject.RejectText)
}
inline void AccountBalanceReject::set_rejecttext(const char* value, size_t size) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.AccountBalanceReject.RejectText)
}
inline ::std::string* AccountBalanceReject::mutable_rejecttext() {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.AccountBalanceReject.RejectText)
  return rejecttext_;
}
inline ::std::string* AccountBalanceReject::release_rejecttext() {
  clear_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rejecttext_;
    rejecttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AccountBalanceReject::set_allocated_rejecttext(::std::string* rejecttext) {
  if (rejecttext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rejecttext_;
  }
  if (rejecttext) {
    set_has_rejecttext();
    rejecttext_ = rejecttext;
  } else {
    clear_has_rejecttext();
    rejecttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.AccountBalanceReject.RejectText)
}

// -------------------------------------------------------------------

// AccountBalanceUpdate

// optional int32 RequestID = 1;
inline bool AccountBalanceUpdate::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountBalanceUpdate::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountBalanceUpdate::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountBalanceUpdate::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 AccountBalanceUpdate::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.RequestID)
  return requestid_;
}
inline void AccountBalanceUpdate::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.RequestID)
}

// optional double CashBalance = 2;
inline bool AccountBalanceUpdate::has_cashbalance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountBalanceUpdate::set_has_cashbalance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountBalanceUpdate::clear_has_cashbalance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountBalanceUpdate::clear_cashbalance() {
  cashbalance_ = 0;
  clear_has_cashbalance();
}
inline double AccountBalanceUpdate::cashbalance() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.CashBalance)
  return cashbalance_;
}
inline void AccountBalanceUpdate::set_cashbalance(double value) {
  set_has_cashbalance();
  cashbalance_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.CashBalance)
}

// optional double BalanceAvailableForNewPositions = 3;
inline bool AccountBalanceUpdate::has_balanceavailablefornewpositions() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountBalanceUpdate::set_has_balanceavailablefornewpositions() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountBalanceUpdate::clear_has_balanceavailablefornewpositions() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountBalanceUpdate::clear_balanceavailablefornewpositions() {
  balanceavailablefornewpositions_ = 0;
  clear_has_balanceavailablefornewpositions();
}
inline double AccountBalanceUpdate::balanceavailablefornewpositions() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.BalanceAvailableForNewPositions)
  return balanceavailablefornewpositions_;
}
inline void AccountBalanceUpdate::set_balanceavailablefornewpositions(double value) {
  set_has_balanceavailablefornewpositions();
  balanceavailablefornewpositions_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.BalanceAvailableForNewPositions)
}

// optional string AccountCurrency = 4;
inline bool AccountBalanceUpdate::has_accountcurrency() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountBalanceUpdate::set_has_accountcurrency() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountBalanceUpdate::clear_has_accountcurrency() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountBalanceUpdate::clear_accountcurrency() {
  if (accountcurrency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountcurrency_->clear();
  }
  clear_has_accountcurrency();
}
inline const ::std::string& AccountBalanceUpdate::accountcurrency() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.AccountCurrency)
  return *accountcurrency_;
}
inline void AccountBalanceUpdate::set_accountcurrency(const ::std::string& value) {
  set_has_accountcurrency();
  if (accountcurrency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountcurrency_ = new ::std::string;
  }
  accountcurrency_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.AccountCurrency)
}
inline void AccountBalanceUpdate::set_accountcurrency(const char* value) {
  set_has_accountcurrency();
  if (accountcurrency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountcurrency_ = new ::std::string;
  }
  accountcurrency_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.AccountBalanceUpdate.AccountCurrency)
}
inline void AccountBalanceUpdate::set_accountcurrency(const char* value, size_t size) {
  set_has_accountcurrency();
  if (accountcurrency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountcurrency_ = new ::std::string;
  }
  accountcurrency_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.AccountBalanceUpdate.AccountCurrency)
}
inline ::std::string* AccountBalanceUpdate::mutable_accountcurrency() {
  set_has_accountcurrency();
  if (accountcurrency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    accountcurrency_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.AccountBalanceUpdate.AccountCurrency)
  return accountcurrency_;
}
inline ::std::string* AccountBalanceUpdate::release_accountcurrency() {
  clear_has_accountcurrency();
  if (accountcurrency_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = accountcurrency_;
    accountcurrency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AccountBalanceUpdate::set_allocated_accountcurrency(::std::string* accountcurrency) {
  if (accountcurrency_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete accountcurrency_;
  }
  if (accountcurrency) {
    set_has_accountcurrency();
    accountcurrency_ = accountcurrency;
  } else {
    clear_has_accountcurrency();
    accountcurrency_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.AccountBalanceUpdate.AccountCurrency)
}

// optional string TradeAccount = 5;
inline bool AccountBalanceUpdate::has_tradeaccount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountBalanceUpdate::set_has_tradeaccount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountBalanceUpdate::clear_has_tradeaccount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountBalanceUpdate::clear_tradeaccount() {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_->clear();
  }
  clear_has_tradeaccount();
}
inline const ::std::string& AccountBalanceUpdate::tradeaccount() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.TradeAccount)
  return *tradeaccount_;
}
inline void AccountBalanceUpdate::set_tradeaccount(const ::std::string& value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.TradeAccount)
}
inline void AccountBalanceUpdate::set_tradeaccount(const char* value) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.AccountBalanceUpdate.TradeAccount)
}
inline void AccountBalanceUpdate::set_tradeaccount(const char* value, size_t size) {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  tradeaccount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.AccountBalanceUpdate.TradeAccount)
}
inline ::std::string* AccountBalanceUpdate::mutable_tradeaccount() {
  set_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tradeaccount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.AccountBalanceUpdate.TradeAccount)
  return tradeaccount_;
}
inline ::std::string* AccountBalanceUpdate::release_tradeaccount() {
  clear_has_tradeaccount();
  if (tradeaccount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tradeaccount_;
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AccountBalanceUpdate::set_allocated_tradeaccount(::std::string* tradeaccount) {
  if (tradeaccount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tradeaccount_;
  }
  if (tradeaccount) {
    set_has_tradeaccount();
    tradeaccount_ = tradeaccount;
  } else {
    clear_has_tradeaccount();
    tradeaccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.AccountBalanceUpdate.TradeAccount)
}

// optional double SecuritiesValue = 6;
inline bool AccountBalanceUpdate::has_securitiesvalue() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AccountBalanceUpdate::set_has_securitiesvalue() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AccountBalanceUpdate::clear_has_securitiesvalue() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AccountBalanceUpdate::clear_securitiesvalue() {
  securitiesvalue_ = 0;
  clear_has_securitiesvalue();
}
inline double AccountBalanceUpdate::securitiesvalue() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.SecuritiesValue)
  return securitiesvalue_;
}
inline void AccountBalanceUpdate::set_securitiesvalue(double value) {
  set_has_securitiesvalue();
  securitiesvalue_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.SecuritiesValue)
}

// optional double MarginRequirement = 7;
inline bool AccountBalanceUpdate::has_marginrequirement() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AccountBalanceUpdate::set_has_marginrequirement() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AccountBalanceUpdate::clear_has_marginrequirement() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AccountBalanceUpdate::clear_marginrequirement() {
  marginrequirement_ = 0;
  clear_has_marginrequirement();
}
inline double AccountBalanceUpdate::marginrequirement() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.MarginRequirement)
  return marginrequirement_;
}
inline void AccountBalanceUpdate::set_marginrequirement(double value) {
  set_has_marginrequirement();
  marginrequirement_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.MarginRequirement)
}

// optional int32 TotalNumberMessages = 8;
inline bool AccountBalanceUpdate::has_totalnumbermessages() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AccountBalanceUpdate::set_has_totalnumbermessages() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AccountBalanceUpdate::clear_has_totalnumbermessages() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AccountBalanceUpdate::clear_totalnumbermessages() {
  totalnumbermessages_ = 0;
  clear_has_totalnumbermessages();
}
inline ::google::protobuf::int32 AccountBalanceUpdate::totalnumbermessages() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.TotalNumberMessages)
  return totalnumbermessages_;
}
inline void AccountBalanceUpdate::set_totalnumbermessages(::google::protobuf::int32 value) {
  set_has_totalnumbermessages();
  totalnumbermessages_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.TotalNumberMessages)
}

// optional int32 MessageNumber = 9;
inline bool AccountBalanceUpdate::has_messagenumber() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AccountBalanceUpdate::set_has_messagenumber() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AccountBalanceUpdate::clear_has_messagenumber() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AccountBalanceUpdate::clear_messagenumber() {
  messagenumber_ = 0;
  clear_has_messagenumber();
}
inline ::google::protobuf::int32 AccountBalanceUpdate::messagenumber() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.MessageNumber)
  return messagenumber_;
}
inline void AccountBalanceUpdate::set_messagenumber(::google::protobuf::int32 value) {
  set_has_messagenumber();
  messagenumber_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.MessageNumber)
}

// optional uint32 NoAccountBalances = 10;
inline bool AccountBalanceUpdate::has_noaccountbalances() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AccountBalanceUpdate::set_has_noaccountbalances() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AccountBalanceUpdate::clear_has_noaccountbalances() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AccountBalanceUpdate::clear_noaccountbalances() {
  noaccountbalances_ = 0u;
  clear_has_noaccountbalances();
}
inline ::google::protobuf::uint32 AccountBalanceUpdate::noaccountbalances() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.NoAccountBalances)
  return noaccountbalances_;
}
inline void AccountBalanceUpdate::set_noaccountbalances(::google::protobuf::uint32 value) {
  set_has_noaccountbalances();
  noaccountbalances_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.NoAccountBalances)
}

// optional uint32 Unsolicited = 11;
inline bool AccountBalanceUpdate::has_unsolicited() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AccountBalanceUpdate::set_has_unsolicited() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AccountBalanceUpdate::clear_has_unsolicited() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AccountBalanceUpdate::clear_unsolicited() {
  unsolicited_ = 0u;
  clear_has_unsolicited();
}
inline ::google::protobuf::uint32 AccountBalanceUpdate::unsolicited() const {
  // @@protoc_insertion_point(field_get:DTC_PB.AccountBalanceUpdate.Unsolicited)
  return unsolicited_;
}
inline void AccountBalanceUpdate::set_unsolicited(::google::protobuf::uint32 value) {
  set_has_unsolicited();
  unsolicited_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.AccountBalanceUpdate.Unsolicited)
}

// -------------------------------------------------------------------

// UserMessage

// optional string UserMessage = 1;
inline bool UserMessage::has_usermessage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMessage::set_has_usermessage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMessage::clear_has_usermessage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMessage::clear_usermessage() {
  if (usermessage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usermessage_->clear();
  }
  clear_has_usermessage();
}
inline const ::std::string& UserMessage::usermessage() const {
  // @@protoc_insertion_point(field_get:DTC_PB.UserMessage.UserMessage)
  return *usermessage_;
}
inline void UserMessage::set_usermessage(const ::std::string& value) {
  set_has_usermessage();
  if (usermessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usermessage_ = new ::std::string;
  }
  usermessage_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.UserMessage.UserMessage)
}
inline void UserMessage::set_usermessage(const char* value) {
  set_has_usermessage();
  if (usermessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usermessage_ = new ::std::string;
  }
  usermessage_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.UserMessage.UserMessage)
}
inline void UserMessage::set_usermessage(const char* value, size_t size) {
  set_has_usermessage();
  if (usermessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usermessage_ = new ::std::string;
  }
  usermessage_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.UserMessage.UserMessage)
}
inline ::std::string* UserMessage::mutable_usermessage() {
  set_has_usermessage();
  if (usermessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    usermessage_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.UserMessage.UserMessage)
  return usermessage_;
}
inline ::std::string* UserMessage::release_usermessage() {
  clear_has_usermessage();
  if (usermessage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = usermessage_;
    usermessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserMessage::set_allocated_usermessage(::std::string* usermessage) {
  if (usermessage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete usermessage_;
  }
  if (usermessage) {
    set_has_usermessage();
    usermessage_ = usermessage;
  } else {
    clear_has_usermessage();
    usermessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.UserMessage.UserMessage)
}

// optional uint32 IsPopupMessage = 2;
inline bool UserMessage::has_ispopupmessage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserMessage::set_has_ispopupmessage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserMessage::clear_has_ispopupmessage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserMessage::clear_ispopupmessage() {
  ispopupmessage_ = 0u;
  clear_has_ispopupmessage();
}
inline ::google::protobuf::uint32 UserMessage::ispopupmessage() const {
  // @@protoc_insertion_point(field_get:DTC_PB.UserMessage.IsPopupMessage)
  return ispopupmessage_;
}
inline void UserMessage::set_ispopupmessage(::google::protobuf::uint32 value) {
  set_has_ispopupmessage();
  ispopupmessage_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.UserMessage.IsPopupMessage)
}

// -------------------------------------------------------------------

// GeneralLogMessage

// optional string MessageText = 3;
inline bool GeneralLogMessage::has_messagetext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GeneralLogMessage::set_has_messagetext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GeneralLogMessage::clear_has_messagetext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GeneralLogMessage::clear_messagetext() {
  if (messagetext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagetext_->clear();
  }
  clear_has_messagetext();
}
inline const ::std::string& GeneralLogMessage::messagetext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.GeneralLogMessage.MessageText)
  return *messagetext_;
}
inline void GeneralLogMessage::set_messagetext(const ::std::string& value) {
  set_has_messagetext();
  if (messagetext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagetext_ = new ::std::string;
  }
  messagetext_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.GeneralLogMessage.MessageText)
}
inline void GeneralLogMessage::set_messagetext(const char* value) {
  set_has_messagetext();
  if (messagetext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagetext_ = new ::std::string;
  }
  messagetext_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.GeneralLogMessage.MessageText)
}
inline void GeneralLogMessage::set_messagetext(const char* value, size_t size) {
  set_has_messagetext();
  if (messagetext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagetext_ = new ::std::string;
  }
  messagetext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.GeneralLogMessage.MessageText)
}
inline ::std::string* GeneralLogMessage::mutable_messagetext() {
  set_has_messagetext();
  if (messagetext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    messagetext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.GeneralLogMessage.MessageText)
  return messagetext_;
}
inline ::std::string* GeneralLogMessage::release_messagetext() {
  clear_has_messagetext();
  if (messagetext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = messagetext_;
    messagetext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GeneralLogMessage::set_allocated_messagetext(::std::string* messagetext) {
  if (messagetext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete messagetext_;
  }
  if (messagetext) {
    set_has_messagetext();
    messagetext_ = messagetext;
  } else {
    clear_has_messagetext();
    messagetext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.GeneralLogMessage.MessageText)
}

// -------------------------------------------------------------------

// HistoricalPriceDataRequest

// optional int32 RequestID = 1;
inline bool HistoricalPriceDataRequest::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalPriceDataRequest::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalPriceDataRequest::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalPriceDataRequest::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.RequestID)
  return requestid_;
}
inline void HistoricalPriceDataRequest::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.RequestID)
}

// optional string Symbol = 2;
inline bool HistoricalPriceDataRequest::has_symbol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_symbol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalPriceDataRequest::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalPriceDataRequest::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& HistoricalPriceDataRequest::symbol() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.Symbol)
  return *symbol_;
}
inline void HistoricalPriceDataRequest::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.Symbol)
}
inline void HistoricalPriceDataRequest::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalPriceDataRequest.Symbol)
}
inline void HistoricalPriceDataRequest::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalPriceDataRequest.Symbol)
}
inline ::std::string* HistoricalPriceDataRequest::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalPriceDataRequest.Symbol)
  return symbol_;
}
inline ::std::string* HistoricalPriceDataRequest::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HistoricalPriceDataRequest::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalPriceDataRequest.Symbol)
}

// optional string Exchange = 3;
inline bool HistoricalPriceDataRequest::has_exchange() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_exchange() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoricalPriceDataRequest::clear_has_exchange() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoricalPriceDataRequest::clear_exchange() {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_->clear();
  }
  clear_has_exchange();
}
inline const ::std::string& HistoricalPriceDataRequest::exchange() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.Exchange)
  return *exchange_;
}
inline void HistoricalPriceDataRequest::set_exchange(const ::std::string& value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.Exchange)
}
inline void HistoricalPriceDataRequest::set_exchange(const char* value) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalPriceDataRequest.Exchange)
}
inline void HistoricalPriceDataRequest::set_exchange(const char* value, size_t size) {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  exchange_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalPriceDataRequest.Exchange)
}
inline ::std::string* HistoricalPriceDataRequest::mutable_exchange() {
  set_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exchange_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalPriceDataRequest.Exchange)
  return exchange_;
}
inline ::std::string* HistoricalPriceDataRequest::release_exchange() {
  clear_has_exchange();
  if (exchange_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exchange_;
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HistoricalPriceDataRequest::set_allocated_exchange(::std::string* exchange) {
  if (exchange_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exchange_;
  }
  if (exchange) {
    set_has_exchange();
    exchange_ = exchange;
  } else {
    clear_has_exchange();
    exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalPriceDataRequest.Exchange)
}

// optional .DTC_PB.HistoricalDataIntervalEnum RecordInterval = 4;
inline bool HistoricalPriceDataRequest::has_recordinterval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_recordinterval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoricalPriceDataRequest::clear_has_recordinterval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoricalPriceDataRequest::clear_recordinterval() {
  recordinterval_ = 0;
  clear_has_recordinterval();
}
inline ::DTC_PB::HistoricalDataIntervalEnum HistoricalPriceDataRequest::recordinterval() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.RecordInterval)
  return static_cast< ::DTC_PB::HistoricalDataIntervalEnum >(recordinterval_);
}
inline void HistoricalPriceDataRequest::set_recordinterval(::DTC_PB::HistoricalDataIntervalEnum value) {
  assert(::DTC_PB::HistoricalDataIntervalEnum_IsValid(value));
  set_has_recordinterval();
  recordinterval_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.RecordInterval)
}

// optional sfixed64 StartDateTime = 5;
inline bool HistoricalPriceDataRequest::has_startdatetime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_startdatetime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoricalPriceDataRequest::clear_has_startdatetime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoricalPriceDataRequest::clear_startdatetime() {
  startdatetime_ = GOOGLE_LONGLONG(0);
  clear_has_startdatetime();
}
inline ::google::protobuf::int64 HistoricalPriceDataRequest::startdatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.StartDateTime)
  return startdatetime_;
}
inline void HistoricalPriceDataRequest::set_startdatetime(::google::protobuf::int64 value) {
  set_has_startdatetime();
  startdatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.StartDateTime)
}

// optional sfixed64 EndDateTime = 6;
inline bool HistoricalPriceDataRequest::has_enddatetime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_enddatetime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HistoricalPriceDataRequest::clear_has_enddatetime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HistoricalPriceDataRequest::clear_enddatetime() {
  enddatetime_ = GOOGLE_LONGLONG(0);
  clear_has_enddatetime();
}
inline ::google::protobuf::int64 HistoricalPriceDataRequest::enddatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.EndDateTime)
  return enddatetime_;
}
inline void HistoricalPriceDataRequest::set_enddatetime(::google::protobuf::int64 value) {
  set_has_enddatetime();
  enddatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.EndDateTime)
}

// optional uint32 MaxDaysToReturn = 7;
inline bool HistoricalPriceDataRequest::has_maxdaystoreturn() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_maxdaystoreturn() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HistoricalPriceDataRequest::clear_has_maxdaystoreturn() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HistoricalPriceDataRequest::clear_maxdaystoreturn() {
  maxdaystoreturn_ = 0u;
  clear_has_maxdaystoreturn();
}
inline ::google::protobuf::uint32 HistoricalPriceDataRequest::maxdaystoreturn() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.MaxDaysToReturn)
  return maxdaystoreturn_;
}
inline void HistoricalPriceDataRequest::set_maxdaystoreturn(::google::protobuf::uint32 value) {
  set_has_maxdaystoreturn();
  maxdaystoreturn_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.MaxDaysToReturn)
}

// optional uint32 UseZLibCompression = 8;
inline bool HistoricalPriceDataRequest::has_usezlibcompression() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_usezlibcompression() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HistoricalPriceDataRequest::clear_has_usezlibcompression() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HistoricalPriceDataRequest::clear_usezlibcompression() {
  usezlibcompression_ = 0u;
  clear_has_usezlibcompression();
}
inline ::google::protobuf::uint32 HistoricalPriceDataRequest::usezlibcompression() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.UseZLibCompression)
  return usezlibcompression_;
}
inline void HistoricalPriceDataRequest::set_usezlibcompression(::google::protobuf::uint32 value) {
  set_has_usezlibcompression();
  usezlibcompression_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.UseZLibCompression)
}

// optional uint32 RequestDividendAdjustedStockData = 9;
inline bool HistoricalPriceDataRequest::has_requestdividendadjustedstockdata() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_requestdividendadjustedstockdata() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HistoricalPriceDataRequest::clear_has_requestdividendadjustedstockdata() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HistoricalPriceDataRequest::clear_requestdividendadjustedstockdata() {
  requestdividendadjustedstockdata_ = 0u;
  clear_has_requestdividendadjustedstockdata();
}
inline ::google::protobuf::uint32 HistoricalPriceDataRequest::requestdividendadjustedstockdata() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.RequestDividendAdjustedStockData)
  return requestdividendadjustedstockdata_;
}
inline void HistoricalPriceDataRequest::set_requestdividendadjustedstockdata(::google::protobuf::uint32 value) {
  set_has_requestdividendadjustedstockdata();
  requestdividendadjustedstockdata_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.RequestDividendAdjustedStockData)
}

// optional uint32 Flag_1 = 10;
inline bool HistoricalPriceDataRequest::has_flag_1() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HistoricalPriceDataRequest::set_has_flag_1() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HistoricalPriceDataRequest::clear_has_flag_1() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HistoricalPriceDataRequest::clear_flag_1() {
  flag_1_ = 0u;
  clear_has_flag_1();
}
inline ::google::protobuf::uint32 HistoricalPriceDataRequest::flag_1() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRequest.Flag_1)
  return flag_1_;
}
inline void HistoricalPriceDataRequest::set_flag_1(::google::protobuf::uint32 value) {
  set_has_flag_1();
  flag_1_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRequest.Flag_1)
}

// -------------------------------------------------------------------

// HistoricalPriceDataResponseHeader

// optional int32 RequestID = 1;
inline bool HistoricalPriceDataResponseHeader::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalPriceDataResponseHeader::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalPriceDataResponseHeader::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalPriceDataResponseHeader::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalPriceDataResponseHeader::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataResponseHeader.RequestID)
  return requestid_;
}
inline void HistoricalPriceDataResponseHeader::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataResponseHeader.RequestID)
}

// optional .DTC_PB.HistoricalDataIntervalEnum RecordInterval = 2;
inline bool HistoricalPriceDataResponseHeader::has_recordinterval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalPriceDataResponseHeader::set_has_recordinterval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalPriceDataResponseHeader::clear_has_recordinterval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalPriceDataResponseHeader::clear_recordinterval() {
  recordinterval_ = 0;
  clear_has_recordinterval();
}
inline ::DTC_PB::HistoricalDataIntervalEnum HistoricalPriceDataResponseHeader::recordinterval() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataResponseHeader.RecordInterval)
  return static_cast< ::DTC_PB::HistoricalDataIntervalEnum >(recordinterval_);
}
inline void HistoricalPriceDataResponseHeader::set_recordinterval(::DTC_PB::HistoricalDataIntervalEnum value) {
  assert(::DTC_PB::HistoricalDataIntervalEnum_IsValid(value));
  set_has_recordinterval();
  recordinterval_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataResponseHeader.RecordInterval)
}

// optional uint32 UseZLibCompression = 3;
inline bool HistoricalPriceDataResponseHeader::has_usezlibcompression() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoricalPriceDataResponseHeader::set_has_usezlibcompression() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoricalPriceDataResponseHeader::clear_has_usezlibcompression() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoricalPriceDataResponseHeader::clear_usezlibcompression() {
  usezlibcompression_ = 0u;
  clear_has_usezlibcompression();
}
inline ::google::protobuf::uint32 HistoricalPriceDataResponseHeader::usezlibcompression() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataResponseHeader.UseZLibCompression)
  return usezlibcompression_;
}
inline void HistoricalPriceDataResponseHeader::set_usezlibcompression(::google::protobuf::uint32 value) {
  set_has_usezlibcompression();
  usezlibcompression_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataResponseHeader.UseZLibCompression)
}

// optional uint32 NoRecordsToReturn = 4;
inline bool HistoricalPriceDataResponseHeader::has_norecordstoreturn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoricalPriceDataResponseHeader::set_has_norecordstoreturn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoricalPriceDataResponseHeader::clear_has_norecordstoreturn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoricalPriceDataResponseHeader::clear_norecordstoreturn() {
  norecordstoreturn_ = 0u;
  clear_has_norecordstoreturn();
}
inline ::google::protobuf::uint32 HistoricalPriceDataResponseHeader::norecordstoreturn() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataResponseHeader.NoRecordsToReturn)
  return norecordstoreturn_;
}
inline void HistoricalPriceDataResponseHeader::set_norecordstoreturn(::google::protobuf::uint32 value) {
  set_has_norecordstoreturn();
  norecordstoreturn_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataResponseHeader.NoRecordsToReturn)
}

// optional float IntPriceDivisor = 5;
inline bool HistoricalPriceDataResponseHeader::has_intpricedivisor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoricalPriceDataResponseHeader::set_has_intpricedivisor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoricalPriceDataResponseHeader::clear_has_intpricedivisor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoricalPriceDataResponseHeader::clear_intpricedivisor() {
  intpricedivisor_ = 0;
  clear_has_intpricedivisor();
}
inline float HistoricalPriceDataResponseHeader::intpricedivisor() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataResponseHeader.IntPriceDivisor)
  return intpricedivisor_;
}
inline void HistoricalPriceDataResponseHeader::set_intpricedivisor(float value) {
  set_has_intpricedivisor();
  intpricedivisor_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataResponseHeader.IntPriceDivisor)
}

// -------------------------------------------------------------------

// HistoricalPriceDataReject

// optional int32 RequestID = 1;
inline bool HistoricalPriceDataReject::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalPriceDataReject::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalPriceDataReject::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalPriceDataReject::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalPriceDataReject::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataReject.RequestID)
  return requestid_;
}
inline void HistoricalPriceDataReject::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataReject.RequestID)
}

// optional string RejectText = 2;
inline bool HistoricalPriceDataReject::has_rejecttext() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalPriceDataReject::set_has_rejecttext() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalPriceDataReject::clear_has_rejecttext() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalPriceDataReject::clear_rejecttext() {
  if (rejecttext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_->clear();
  }
  clear_has_rejecttext();
}
inline const ::std::string& HistoricalPriceDataReject::rejecttext() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataReject.RejectText)
  return *rejecttext_;
}
inline void HistoricalPriceDataReject::set_rejecttext(const ::std::string& value) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(value);
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataReject.RejectText)
}
inline void HistoricalPriceDataReject::set_rejecttext(const char* value) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(value);
  // @@protoc_insertion_point(field_set_char:DTC_PB.HistoricalPriceDataReject.RejectText)
}
inline void HistoricalPriceDataReject::set_rejecttext(const char* value, size_t size) {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  rejecttext_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DTC_PB.HistoricalPriceDataReject.RejectText)
}
inline ::std::string* HistoricalPriceDataReject::mutable_rejecttext() {
  set_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rejecttext_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DTC_PB.HistoricalPriceDataReject.RejectText)
  return rejecttext_;
}
inline ::std::string* HistoricalPriceDataReject::release_rejecttext() {
  clear_has_rejecttext();
  if (rejecttext_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rejecttext_;
    rejecttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HistoricalPriceDataReject::set_allocated_rejecttext(::std::string* rejecttext) {
  if (rejecttext_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rejecttext_;
  }
  if (rejecttext) {
    set_has_rejecttext();
    rejecttext_ = rejecttext;
  } else {
    clear_has_rejecttext();
    rejecttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DTC_PB.HistoricalPriceDataReject.RejectText)
}

// -------------------------------------------------------------------

// HistoricalPriceDataRecordResponse

// optional int32 RequestID = 1;
inline bool HistoricalPriceDataRecordResponse::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalPriceDataRecordResponse::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalPriceDataRecordResponse::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.RequestID)
  return requestid_;
}
inline void HistoricalPriceDataRecordResponse::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.RequestID)
}

// optional sfixed64 StartDateTime = 2;
inline bool HistoricalPriceDataRecordResponse::has_startdatetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_startdatetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_startdatetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalPriceDataRecordResponse::clear_startdatetime() {
  startdatetime_ = GOOGLE_LONGLONG(0);
  clear_has_startdatetime();
}
inline ::google::protobuf::int64 HistoricalPriceDataRecordResponse::startdatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.StartDateTime)
  return startdatetime_;
}
inline void HistoricalPriceDataRecordResponse::set_startdatetime(::google::protobuf::int64 value) {
  set_has_startdatetime();
  startdatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.StartDateTime)
}

// optional double OpenPrice = 3;
inline bool HistoricalPriceDataRecordResponse::has_openprice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_openprice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_openprice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoricalPriceDataRecordResponse::clear_openprice() {
  openprice_ = 0;
  clear_has_openprice();
}
inline double HistoricalPriceDataRecordResponse::openprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.OpenPrice)
  return openprice_;
}
inline void HistoricalPriceDataRecordResponse::set_openprice(double value) {
  set_has_openprice();
  openprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.OpenPrice)
}

// optional double HighPrice = 4;
inline bool HistoricalPriceDataRecordResponse::has_highprice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_highprice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_highprice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoricalPriceDataRecordResponse::clear_highprice() {
  highprice_ = 0;
  clear_has_highprice();
}
inline double HistoricalPriceDataRecordResponse::highprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.HighPrice)
  return highprice_;
}
inline void HistoricalPriceDataRecordResponse::set_highprice(double value) {
  set_has_highprice();
  highprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.HighPrice)
}

// optional double LowPrice = 5;
inline bool HistoricalPriceDataRecordResponse::has_lowprice() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_lowprice() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_lowprice() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoricalPriceDataRecordResponse::clear_lowprice() {
  lowprice_ = 0;
  clear_has_lowprice();
}
inline double HistoricalPriceDataRecordResponse::lowprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.LowPrice)
  return lowprice_;
}
inline void HistoricalPriceDataRecordResponse::set_lowprice(double value) {
  set_has_lowprice();
  lowprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.LowPrice)
}

// optional double LastPrice = 6;
inline bool HistoricalPriceDataRecordResponse::has_lastprice() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_lastprice() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_lastprice() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HistoricalPriceDataRecordResponse::clear_lastprice() {
  lastprice_ = 0;
  clear_has_lastprice();
}
inline double HistoricalPriceDataRecordResponse::lastprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.LastPrice)
  return lastprice_;
}
inline void HistoricalPriceDataRecordResponse::set_lastprice(double value) {
  set_has_lastprice();
  lastprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.LastPrice)
}

// optional double Volume = 7;
inline bool HistoricalPriceDataRecordResponse::has_volume() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_volume() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_volume() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HistoricalPriceDataRecordResponse::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double HistoricalPriceDataRecordResponse::volume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.Volume)
  return volume_;
}
inline void HistoricalPriceDataRecordResponse::set_volume(double value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.Volume)
}

// optional uint32 NumTrades = 8;
inline bool HistoricalPriceDataRecordResponse::has_numtrades() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_numtrades() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_numtrades() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HistoricalPriceDataRecordResponse::clear_numtrades() {
  numtrades_ = 0u;
  clear_has_numtrades();
}
inline ::google::protobuf::uint32 HistoricalPriceDataRecordResponse::numtrades() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.NumTrades)
  return numtrades_;
}
inline void HistoricalPriceDataRecordResponse::set_numtrades(::google::protobuf::uint32 value) {
  set_has_numtrades();
  numtrades_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.NumTrades)
}

// optional double BidVolume = 9;
inline bool HistoricalPriceDataRecordResponse::has_bidvolume() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_bidvolume() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_bidvolume() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HistoricalPriceDataRecordResponse::clear_bidvolume() {
  bidvolume_ = 0;
  clear_has_bidvolume();
}
inline double HistoricalPriceDataRecordResponse::bidvolume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.BidVolume)
  return bidvolume_;
}
inline void HistoricalPriceDataRecordResponse::set_bidvolume(double value) {
  set_has_bidvolume();
  bidvolume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.BidVolume)
}

// optional double AskVolume = 10;
inline bool HistoricalPriceDataRecordResponse::has_askvolume() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_askvolume() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_askvolume() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HistoricalPriceDataRecordResponse::clear_askvolume() {
  askvolume_ = 0;
  clear_has_askvolume();
}
inline double HistoricalPriceDataRecordResponse::askvolume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.AskVolume)
  return askvolume_;
}
inline void HistoricalPriceDataRecordResponse::set_askvolume(double value) {
  set_has_askvolume();
  askvolume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.AskVolume)
}

// optional uint32 IsFinalRecord = 11;
inline bool HistoricalPriceDataRecordResponse::has_isfinalrecord() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HistoricalPriceDataRecordResponse::set_has_isfinalrecord() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HistoricalPriceDataRecordResponse::clear_has_isfinalrecord() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HistoricalPriceDataRecordResponse::clear_isfinalrecord() {
  isfinalrecord_ = 0u;
  clear_has_isfinalrecord();
}
inline ::google::protobuf::uint32 HistoricalPriceDataRecordResponse::isfinalrecord() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse.IsFinalRecord)
  return isfinalrecord_;
}
inline void HistoricalPriceDataRecordResponse::set_isfinalrecord(::google::protobuf::uint32 value) {
  set_has_isfinalrecord();
  isfinalrecord_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse.IsFinalRecord)
}

// -------------------------------------------------------------------

// HistoricalPriceDataTickRecordResponse

// optional int32 RequestID = 1;
inline bool HistoricalPriceDataTickRecordResponse::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalPriceDataTickRecordResponse::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse.RequestID)
  return requestid_;
}
inline void HistoricalPriceDataTickRecordResponse::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse.RequestID)
}

// optional double DateTime = 2;
inline bool HistoricalPriceDataTickRecordResponse::has_datetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse::set_has_datetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline double HistoricalPriceDataTickRecordResponse::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse.DateTime)
  return datetime_;
}
inline void HistoricalPriceDataTickRecordResponse::set_datetime(double value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse.DateTime)
}

// optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 3;
inline bool HistoricalPriceDataTickRecordResponse::has_atbidorask() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse::set_has_atbidorask() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_has_atbidorask() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_atbidorask() {
  atbidorask_ = 0;
  clear_has_atbidorask();
}
inline ::DTC_PB::AtBidOrAskEnum HistoricalPriceDataTickRecordResponse::atbidorask() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse.AtBidOrAsk)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(atbidorask_);
}
inline void HistoricalPriceDataTickRecordResponse::set_atbidorask(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_atbidorask();
  atbidorask_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse.AtBidOrAsk)
}

// optional double Price = 4;
inline bool HistoricalPriceDataTickRecordResponse::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double HistoricalPriceDataTickRecordResponse::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse.Price)
  return price_;
}
inline void HistoricalPriceDataTickRecordResponse::set_price(double value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse.Price)
}

// optional double Volume = 5;
inline bool HistoricalPriceDataTickRecordResponse::has_volume() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse::set_has_volume() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_has_volume() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double HistoricalPriceDataTickRecordResponse::volume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse.Volume)
  return volume_;
}
inline void HistoricalPriceDataTickRecordResponse::set_volume(double value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse.Volume)
}

// optional uint32 IsFinalRecord = 6;
inline bool HistoricalPriceDataTickRecordResponse::has_isfinalrecord() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse::set_has_isfinalrecord() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_has_isfinalrecord() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HistoricalPriceDataTickRecordResponse::clear_isfinalrecord() {
  isfinalrecord_ = 0u;
  clear_has_isfinalrecord();
}
inline ::google::protobuf::uint32 HistoricalPriceDataTickRecordResponse::isfinalrecord() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse.IsFinalRecord)
  return isfinalrecord_;
}
inline void HistoricalPriceDataTickRecordResponse::set_isfinalrecord(::google::protobuf::uint32 value) {
  set_has_isfinalrecord();
  isfinalrecord_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse.IsFinalRecord)
}

// -------------------------------------------------------------------

// HistoricalPriceDataRecordResponse_Int

// optional int32 RequestID = 1;
inline bool HistoricalPriceDataRecordResponse_Int::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalPriceDataRecordResponse_Int::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.RequestID)
  return requestid_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.RequestID)
}

// optional sfixed64 StartDateTime = 2;
inline bool HistoricalPriceDataRecordResponse_Int::has_startdatetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_startdatetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_startdatetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_startdatetime() {
  startdatetime_ = GOOGLE_LONGLONG(0);
  clear_has_startdatetime();
}
inline ::google::protobuf::int64 HistoricalPriceDataRecordResponse_Int::startdatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.StartDateTime)
  return startdatetime_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_startdatetime(::google::protobuf::int64 value) {
  set_has_startdatetime();
  startdatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.StartDateTime)
}

// optional int32 OpenPrice = 3;
inline bool HistoricalPriceDataRecordResponse_Int::has_openprice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_openprice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_openprice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_openprice() {
  openprice_ = 0;
  clear_has_openprice();
}
inline ::google::protobuf::int32 HistoricalPriceDataRecordResponse_Int::openprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.OpenPrice)
  return openprice_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_openprice(::google::protobuf::int32 value) {
  set_has_openprice();
  openprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.OpenPrice)
}

// optional int32 HighPrice = 4;
inline bool HistoricalPriceDataRecordResponse_Int::has_highprice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_highprice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_highprice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_highprice() {
  highprice_ = 0;
  clear_has_highprice();
}
inline ::google::protobuf::int32 HistoricalPriceDataRecordResponse_Int::highprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.HighPrice)
  return highprice_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_highprice(::google::protobuf::int32 value) {
  set_has_highprice();
  highprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.HighPrice)
}

// optional int32 LowPrice = 5;
inline bool HistoricalPriceDataRecordResponse_Int::has_lowprice() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_lowprice() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_lowprice() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_lowprice() {
  lowprice_ = 0;
  clear_has_lowprice();
}
inline ::google::protobuf::int32 HistoricalPriceDataRecordResponse_Int::lowprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.LowPrice)
  return lowprice_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_lowprice(::google::protobuf::int32 value) {
  set_has_lowprice();
  lowprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.LowPrice)
}

// optional int32 LastPrice = 6;
inline bool HistoricalPriceDataRecordResponse_Int::has_lastprice() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_lastprice() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_lastprice() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_lastprice() {
  lastprice_ = 0;
  clear_has_lastprice();
}
inline ::google::protobuf::int32 HistoricalPriceDataRecordResponse_Int::lastprice() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.LastPrice)
  return lastprice_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_lastprice(::google::protobuf::int32 value) {
  set_has_lastprice();
  lastprice_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.LastPrice)
}

// optional int32 Volume = 7;
inline bool HistoricalPriceDataRecordResponse_Int::has_volume() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_volume() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_volume() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline ::google::protobuf::int32 HistoricalPriceDataRecordResponse_Int::volume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.Volume)
  return volume_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_volume(::google::protobuf::int32 value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.Volume)
}

// optional uint32 NumTrades = 8;
inline bool HistoricalPriceDataRecordResponse_Int::has_numtrades() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_numtrades() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_numtrades() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_numtrades() {
  numtrades_ = 0u;
  clear_has_numtrades();
}
inline ::google::protobuf::uint32 HistoricalPriceDataRecordResponse_Int::numtrades() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.NumTrades)
  return numtrades_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_numtrades(::google::protobuf::uint32 value) {
  set_has_numtrades();
  numtrades_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.NumTrades)
}

// optional int32 BidVolume = 9;
inline bool HistoricalPriceDataRecordResponse_Int::has_bidvolume() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_bidvolume() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_bidvolume() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_bidvolume() {
  bidvolume_ = 0;
  clear_has_bidvolume();
}
inline ::google::protobuf::int32 HistoricalPriceDataRecordResponse_Int::bidvolume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.BidVolume)
  return bidvolume_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_bidvolume(::google::protobuf::int32 value) {
  set_has_bidvolume();
  bidvolume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.BidVolume)
}

// optional int32 AskVolume = 10;
inline bool HistoricalPriceDataRecordResponse_Int::has_askvolume() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_askvolume() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_askvolume() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_askvolume() {
  askvolume_ = 0;
  clear_has_askvolume();
}
inline ::google::protobuf::int32 HistoricalPriceDataRecordResponse_Int::askvolume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.AskVolume)
  return askvolume_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_askvolume(::google::protobuf::int32 value) {
  set_has_askvolume();
  askvolume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.AskVolume)
}

// optional uint32 IsFinalRecord = 11;
inline bool HistoricalPriceDataRecordResponse_Int::has_isfinalrecord() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HistoricalPriceDataRecordResponse_Int::set_has_isfinalrecord() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_has_isfinalrecord() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HistoricalPriceDataRecordResponse_Int::clear_isfinalrecord() {
  isfinalrecord_ = 0u;
  clear_has_isfinalrecord();
}
inline ::google::protobuf::uint32 HistoricalPriceDataRecordResponse_Int::isfinalrecord() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataRecordResponse_Int.IsFinalRecord)
  return isfinalrecord_;
}
inline void HistoricalPriceDataRecordResponse_Int::set_isfinalrecord(::google::protobuf::uint32 value) {
  set_has_isfinalrecord();
  isfinalrecord_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataRecordResponse_Int.IsFinalRecord)
}

// -------------------------------------------------------------------

// HistoricalPriceDataTickRecordResponse_Int

// optional int32 RequestID = 1;
inline bool HistoricalPriceDataTickRecordResponse_Int::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalPriceDataTickRecordResponse_Int::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.RequestID)
  return requestid_;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.RequestID)
}

// optional double DateTime = 2;
inline bool HistoricalPriceDataTickRecordResponse_Int::has_datetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_has_datetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_datetime() {
  datetime_ = 0;
  clear_has_datetime();
}
inline double HistoricalPriceDataTickRecordResponse_Int::datetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.DateTime)
  return datetime_;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_datetime(double value) {
  set_has_datetime();
  datetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.DateTime)
}

// optional int32 Price = 3;
inline bool HistoricalPriceDataTickRecordResponse_Int::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 HistoricalPriceDataTickRecordResponse_Int::price() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.Price)
  return price_;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.Price)
}

// optional int32 Volume = 4;
inline bool HistoricalPriceDataTickRecordResponse_Int::has_volume() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_has_volume() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_has_volume() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline ::google::protobuf::int32 HistoricalPriceDataTickRecordResponse_Int::volume() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.Volume)
  return volume_;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_volume(::google::protobuf::int32 value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.Volume)
}

// optional .DTC_PB.AtBidOrAskEnum AtBidOrAsk = 5;
inline bool HistoricalPriceDataTickRecordResponse_Int::has_atbidorask() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_has_atbidorask() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_has_atbidorask() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_atbidorask() {
  atbidorask_ = 0;
  clear_has_atbidorask();
}
inline ::DTC_PB::AtBidOrAskEnum HistoricalPriceDataTickRecordResponse_Int::atbidorask() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.AtBidOrAsk)
  return static_cast< ::DTC_PB::AtBidOrAskEnum >(atbidorask_);
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_atbidorask(::DTC_PB::AtBidOrAskEnum value) {
  assert(::DTC_PB::AtBidOrAskEnum_IsValid(value));
  set_has_atbidorask();
  atbidorask_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.AtBidOrAsk)
}

// optional uint32 IsFinalRecord = 6;
inline bool HistoricalPriceDataTickRecordResponse_Int::has_isfinalrecord() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_has_isfinalrecord() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_has_isfinalrecord() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HistoricalPriceDataTickRecordResponse_Int::clear_isfinalrecord() {
  isfinalrecord_ = 0u;
  clear_has_isfinalrecord();
}
inline ::google::protobuf::uint32 HistoricalPriceDataTickRecordResponse_Int::isfinalrecord() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.IsFinalRecord)
  return isfinalrecord_;
}
inline void HistoricalPriceDataTickRecordResponse_Int::set_isfinalrecord(::google::protobuf::uint32 value) {
  set_has_isfinalrecord();
  isfinalrecord_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataTickRecordResponse_Int.IsFinalRecord)
}

// -------------------------------------------------------------------

// HistoricalPriceDataResponseTrailer

// optional int32 RequestID = 1;
inline bool HistoricalPriceDataResponseTrailer::has_requestid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoricalPriceDataResponseTrailer::set_has_requestid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoricalPriceDataResponseTrailer::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoricalPriceDataResponseTrailer::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 HistoricalPriceDataResponseTrailer::requestid() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataResponseTrailer.RequestID)
  return requestid_;
}
inline void HistoricalPriceDataResponseTrailer::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataResponseTrailer.RequestID)
}

// optional double FinalRecordLastDateTime = 2;
inline bool HistoricalPriceDataResponseTrailer::has_finalrecordlastdatetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoricalPriceDataResponseTrailer::set_has_finalrecordlastdatetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoricalPriceDataResponseTrailer::clear_has_finalrecordlastdatetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoricalPriceDataResponseTrailer::clear_finalrecordlastdatetime() {
  finalrecordlastdatetime_ = 0;
  clear_has_finalrecordlastdatetime();
}
inline double HistoricalPriceDataResponseTrailer::finalrecordlastdatetime() const {
  // @@protoc_insertion_point(field_get:DTC_PB.HistoricalPriceDataResponseTrailer.FinalRecordLastDateTime)
  return finalrecordlastdatetime_;
}
inline void HistoricalPriceDataResponseTrailer::set_finalrecordlastdatetime(double value) {
  set_has_finalrecordlastdatetime();
  finalrecordlastdatetime_ = value;
  // @@protoc_insertion_point(field_set:DTC_PB.HistoricalPriceDataResponseTrailer.FinalRecordLastDateTime)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace DTC_PB

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::DTC_PB::DTCVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::DTCVersion>() {
  return ::DTC_PB::DTCVersion_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::DTCMessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::DTCMessageType>() {
  return ::DTC_PB::DTCMessageType_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::EncodingEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::EncodingEnum>() {
  return ::DTC_PB::EncodingEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::LogonStatusEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::LogonStatusEnum>() {
  return ::DTC_PB::LogonStatusEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::MessageSupportedEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::MessageSupportedEnum>() {
  return ::DTC_PB::MessageSupportedEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::TradeModeEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::TradeModeEnum>() {
  return ::DTC_PB::TradeModeEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::RequestActionEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::RequestActionEnum>() {
  return ::DTC_PB::RequestActionEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::OrderStatusEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::OrderStatusEnum>() {
  return ::DTC_PB::OrderStatusEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::OrderUpdateReasonEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::OrderUpdateReasonEnum>() {
  return ::DTC_PB::OrderUpdateReasonEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::AtBidOrAskEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::AtBidOrAskEnum>() {
  return ::DTC_PB::AtBidOrAskEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::MarketDepthUpdateTypeEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::MarketDepthUpdateTypeEnum>() {
  return ::DTC_PB::MarketDepthUpdateTypeEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::OrderTypeEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::OrderTypeEnum>() {
  return ::DTC_PB::OrderTypeEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::TimeInForceEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::TimeInForceEnum>() {
  return ::DTC_PB::TimeInForceEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::BuySellEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::BuySellEnum>() {
  return ::DTC_PB::BuySellEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::OpenCloseTradeEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::OpenCloseTradeEnum>() {
  return ::DTC_PB::OpenCloseTradeEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::MarketDataFeedStatusEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::MarketDataFeedStatusEnum>() {
  return ::DTC_PB::MarketDataFeedStatusEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::PriceDisplayFormatEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::PriceDisplayFormatEnum>() {
  return ::DTC_PB::PriceDisplayFormatEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::SecurityTypeEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::SecurityTypeEnum>() {
  return ::DTC_PB::SecurityTypeEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::PutCallEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::PutCallEnum>() {
  return ::DTC_PB::PutCallEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::SearchTypeEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::SearchTypeEnum>() {
  return ::DTC_PB::SearchTypeEnum_descriptor();
}
template <> struct is_proto_enum< ::DTC_PB::HistoricalDataIntervalEnum> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DTC_PB::HistoricalDataIntervalEnum>() {
  return ::DTC_PB::HistoricalDataIntervalEnum_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_DTCProtocol_2eproto__INCLUDED
